<!DOCTYPE html>
<html class="telFlasherClass">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Telink Flasher v8.0</title>
<style type="text/css">
/* basic sytles */

body {
  font-family: Arial, 'Open Sans', sans-serif;
  color: #204056;
}

h1 {
  font-size: 28px;
  font-weight: 400;
  text-align: center;
  margin-top: 12px;
  margin-bottom: 18px;
}

hr {
	height: 10px;
	border: 0;
	box-shadow: 0 10px 10px -10px #8c8b8b inset;
}

span#info {
  font-style: italic;
}

.button, [type='button'] {
  background-color: #1a73e8; 
  border: none;
  border-radius: 4px;
  color: white;
  padding: 8px 24px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 14px;
  margin: 6px 6px;
  cursor: pointer;
  box-shadow: 0 3px 1px -2px #0003, 0 2px 2px #00000024, 0 1px 5px #0000001f;
}

.button, [type='button'].ok {
  background-color: #4CAF50; /* Green */
  color: white;
  border-color: #4CAF50;
}

.button, [type='button'].danger {
  background-color: #f44336; /* Green */
  color: white;
  border-color: #f44336;
}

.button, [type='button']:disabled {
  cursor: not-allowed;
  opacity: 0.6;
}

input[type="checkbox"] + label {
  margin-right: 8px;
}

div#div_v {
	height:400px;
	margin-top: 16px;
	margin-bottom: 16px;
}

div#labdiv {
	margin-top: 16px;
	margin-bottom: 16px;
}

div#log {
  padding: 12px;
  font-style: italic;
  font-size: 16px;
}

div#MAC {
  font-style: smaller;
  margin: 8px;
}

div#percent {
  font-style: italic;
  font-size: 16px;
  text-align: center;
  background-color: #eef6fc;
  padding-top: 5px;
  padding-bottom: 5px;
  margin-top: 8px;
}

div#tempHumiData{
  text-align: center;
  background-color: #eef6fc;
  padding-top: 5px;
  padding-bottom: 5px;
}

input {
  padding: 4px;
  margin: 4px;
}

select {
  padding: 4px;
}

/* menu */

.navbar {
  width: 95%;
  /* box-shadow: 0 1px 4px rgb(146 161 176 / 15%);*/
  position: absolute;
  top: 0;
}

.nav-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  height: 62px;
}

.navbar .menu-items {
  display: flex;
}

.navbar .nav-container li {
  list-style: none;
}

.navbar .nav-container a {
  font-size: 1.0rem;
  font-weight: 400;
}

.navbar .nav-container a:hover{
    font-weight: bolder;
}

.nav-container {
  display: block;
  position: relative;
  height: 60px;
}

.nav-container .checkbox {
  position: absolute;
  display: block;
  height: 32px;
  width: 32px;
  top: 20px;
  left: 20px;
  z-index: 5;
  opacity: 0;
  cursor: pointer;
}

.nav-container .hamburger-lines {
  display: block;
  height: 26px;
  width: 32px;
  position: absolute;
  top: 17px;
  left: 20px;
  z-index: 2;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}

.nav-container .hamburger-lines .line {
  display: block;
  height: 4px;
  width: 100%;
  border-radius: 10px;
  background: #0e2431;
}

.nav-container .hamburger-lines .line1 {
  transform-origin: 0% 0%;
  transition: transform 0.4s ease-in-out;
}

.nav-container .hamburger-lines .line2 {
  transition: transform 0.2s ease-in-out;
}

.nav-container .hamburger-lines .line3 {
  transform-origin: 0% 100%;
  transition: transform 0.4s ease-in-out;
}

.navbar .menu-items {
  position: relative;
  padding-top: 55px;
  box-shadow: 5px 3px 13px 0px rgb(204 204 204 / 80%);
  min-height: 100vh;
  width: 60%;
  transform: translate(-150%);
  display: flex;
  flex-direction: column;
  transition: transform 0.5s ease-in-out;
  text-align: center;
  z-index: 1;
  background: white;
}

.navbar .menu-items li {
  margin-bottom: 12px;
  font-size: 1.2rem;
  font-weight: 800;
}


.nav-container input[type="checkbox"]:checked ~ .menu-items {
  transform: translateX(0);
}

.nav-container input[type="checkbox"]:checked ~ .hamburger-lines .line1 {
  transform: rotate(45deg);
}

.nav-container input[type="checkbox"]:checked ~ .hamburger-lines .line2 {
  transform: scaleY(0);
}

.nav-container input[type="checkbox"]:checked ~ .hamburger-lines .line3 {
  transform: rotate(-45deg);
}

.nav-container input[type="checkbox"]:checked ~ .logo{
  display: none;
}
</style>
</head>
<body>
<script>
//BLE values
var bluetoothDevice, gattServer, Theservice, writeCharacteristic;
var ServiceMain, writeCharacteristicSpeed = null, nitifiyCharTemp, time_char, enc_main, enc_10, enc_19;
//Firmware values
var fwmaxsize = 0x20000;
var otafiles = { loaded: false };
var otazfiles = { loaded: false };
var fzigbeeota = { used : false };
var firmwareArray = "",
	startTime = 0,
	blockCount = 0;
var flg_memo_act = false;
var devinfo = { hrstr: null, srstr: null, frstr: null };
var devSens = {};
var fwname = '';
//Connection values
var state = 0,
	connectTrys = 0;
//Custom firmware
var customEnabled, devTest = false;
var settingsCharacteristics = null;
// Custom config
var MAX_RF_TX_Power = false;
var cfg = {enable: false, ver: 0, hver: 0, ext_hw_id: 0, flg: 0, flg2: 0, temp_offset: 0, humi_offset: 0, advertising_interval: 32, measure_interval: 5, rf_tx_power: 191, connect_latency: 49, lcd_tint: 55, av_meas_mem: 60, step_time: 16000000};
var trg = {enable: false, tmp_thr: 2100, hm_thr: 5000, tmp_hst: -1, hm_hst: 0, flg: 0, rds_type: 0, rds_rpint: 0};
var cmf = {enable: false, tmp_lo: 2100, tmp_hi: 2600, hm_lo: 3000, hm_hi: 6000};
var dnm = {enable: false, name: ""};
var devtime = {};
var pincode = {enable: false, value: 0};
//Mi values
var miEnabled = false,
	otaEnabled = false,
	EnabledQinping = false,
	devInfEnabled = false,
	miConnected = false,
	devIdEnabled = false,
	bigOtaEnabled = false,
	mode_activation;
//Login values
var mi_random_key, mi_random_key_recv, mi_device_info_recv, mi_device_info_send, device_known_id, expected_device_infos, is_logged_in = false;
//Activation values
var keypair, is_activated, own_public_key, device_public_key, shared_key, derived_key, mi_write_did;
var device_new_id = "00626c742e332e31323976" + makeRandomID(6) + "673030"; // 0+"blt.6.129v"+rand[6]+"g00"
var $ = function(id) { return document.getElementById(id);}
function resetVariables() {
	fwmaxsize = 0x20000;
	busy = false;
	gattServer = null;
	Theservice = null;
	mikeys.restore = false;
	mikeys.mac = null;
	mikeys.id = null;
	mikeys.token = null;
	mikeys.bindkey = null
	mikeys.cbindkey = null
	mikeys.cfg = null;
	mikeys.delkeys = null;
	ext.enable = false;
	pincode.enable = false;
	cfg.enable = false;
	trg.enable = false;
	cmf.enable = false;
	dnm.enable = false;
	cnt_buf11 = 0;
	writeCharacteristic = null;
	settingsCharacteristics = null;
	miConnected = false;
	bigOtaEnabled = false;
	is_logged_in = false;
	devinfo.hrstr = null;
	devinfo.srstr = null;
	devinfo.frstr = null;
	//fzigbeeota.used = false;
	//fwname = '';
	devtime = {};
	writeCharacteristicSpeed = null;
	$("ldfrmw").innerHTML ='';
	$("custcfg").innerHTML = '';
	$("tempHumiData").innerHTML = "Temp/Humidity: waiting notify for data after connecting";
	$("percent").innerHTML = "Status: Disconnected";
}

function handleError(error) {
	if (connectTrys == 1000) {
		disconnect();
	} else {
		addLog(error);
		resetVariables();
		if (connectTrys < 5) {
			connectTrys++;
			addLog("Reconnect " + connectTrys + " from " + 5);
			doConnect();
		} else {
			addLog("Something went wrong, too many reconnects");
			connectTrys = 0;
		}
	}
}

function disconnect() {
	if (bluetoothDevice != null) bluetoothDevice.gatt.disconnect();
	$("MAC").innerHTML = '';
	$("ldfile").hidden = true;
	cfg.hver = null;
	hwver_id = null;
	resetVariables();
}

function onDisconnected() {
	addLog('Disconnected.');
	$("MAC").innerHTML = '';
	$("ldfile").hidden = true;
	cfg.hver = null;
	hwver_id = null;
	resetVariables();
}

function connect() {
	var deviceOptions = {
		optionalServices: ['00001f10-0000-1000-8000-00805f9b34fb','00010203-0405-0607-0809-0a0b0c0d1912', 'ebe0ccb0-7a0a-4b0c-8a1a-6ff2997da3a6', '22210000-554a-4546-5542-46534450464d', 0x180a, 0x181c, 0x181e, 0xfe95, 0x1f10, 0x1f11, 0x181a, 0xfff9, 0xfdcd, 0xffe0, 0xfcd2],
		services: [0x180a, 0x181c, 0x181e, 0xfe95, 0x1f10, 0x1f11, 0x181a, 0xfff9, 0xfcd2, 0xfdcd, 0xffe0],
		acceptAllDevices: true };
	const namePrefix = $('namePrefix').value;
	if (namePrefix) {
		deviceOptions.acceptAllDevices = false;
		deviceOptions.filters = namePrefix.split(",")
			.map((x) => ({ namePrefix: x }));
	}/* else {
		deviceOptions.acceptAllDevices = false;
		deviceOptions.filters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz_#@!*0123456789';,.<>{}[]"
			.split("")
			.map((x) => ({ namePrefix: x }));
	} */
	addClog(deviceOptions)
	if (bluetoothDevice != null) bluetoothDevice.gatt.disconnect();
	resetVariables();
	addAlog("Searching for devices");
	connectTrys = 0;
	navigator.bluetooth.requestDevice(deviceOptions).then(device => {
		bluetoothDevice = device;
		if($("advmac").checked)
			catchAdvertisement(device);
		bluetoothDevice.addEventListener('gattserverdisconnected', onDisconnected);
		addLog("Connecting to: " + bluetoothDevice.name);
		setStatus("Connecting to: " + bluetoothDevice.name + " ...");
		if(!$("advmac").checked)
				doConnect();
	}).catch(handleError);
}

const tabid2name = [
  { id: 0x01AA, name: "LYWSDCGQ"},
  { id: 0x045B, name: "LYWSD02"},
  { id: 0x055B, name: "LYWSD03MMC"},
  { id: 0x1203, name: "XMWSDJ04MMC"},
  { id: 0x04E1, name: "XMMF01JQD"},
  { id: 0x0098, name: "HHCCJCY01"},
  { id: 0x03BC, name: "GCLS002"},
  { id: 0x015D, name: "HHCCPOT002"},
  { id: 0x040A, name: "WX08ZM"},
  { id: 0x098B, name: "MCCGQ02HL"},
  { id: 0x0083, name: "YM-K1501"},
  { id: 0x0113, name: "YM-K1501EU"},
  { id: 0x045C, name: "V-SK152"},
  { id: 0x0863, name: "SJWS01LM"},
  { id: 0x07F6, name: "MJYD02YL"},
  { id: 0x03DD, name: "MUE4094RT"},
  { id: 0x0A8D, name: "RTCGQ02LM"},
  { id: 0x00DB, name: "MMC-T201-1"},
  { id: 0x0489, name: "M1S-T500"},
  { id: 0x0C3C, name: "CGC1"},
  { id: 0x0576, name: "CGD1"},
  { id: 0x066F, name: "CGDK2"},
  { id: 0x0347, name: "CGG1"},
  { id: 0x0B48, name: "CGG1-ENCRYPTED"},
  { id: 0x03D6, name: "CGH1"},
  { id: 0x0A83, name: "CGPR1"},
  { id: 0x06d3, name: "MHO-C303"},
  { id: 0x0387, name: "MHO-C401"},
  { id: 0x02DF, name: "JQJCY01YM"},
  { id: 0x0997, name: "JTYJGD03MI"},
  { id: 0x1568, name: "K9B-1BTN"},
  { id: 0x1569, name: "K9B-2BTN"},
  { id: 0x0DFD, name: "K9B-3BTN"},
  { id: 0x07BF, name: "YLAI003"},
  { id: 0x0153, name: "YLYK01YL"},
  { id: 0x068E, name: "YLYK01YL-FANCL"},
  { id: 0x04E6, name: "YLYK01YL-VENFAN"},
  { id: 0x03BF, name: "YLYB01YL-BHFRC"},
  { id: 0x03B6, name: "YLKG07YL/YLKG08YL"},
  { id: 0x069E, name: "ZNMS16LM"},
  { id: 0x069F, name: "ZNMS17LM"},
  { id: 0x04E9, name: "MJZNMSQ01YD"},
  { id: 0x098C, name: "XMZNMST02YD"},
  { id: 0x2832, name: "MJWSD05MMC"}
];
function id2name(dev_id) {
	let did = tabid2name.map(el => el.id);
	let i = did.indexOf(dev_id);
	if(i != -1) return tabid2name[i].name;
	return "?";
}
const tabDoor2event = [
  { id: 0, name: "opened"},
  { id: 1, name: "closed"},
  { id: 2, name: "closing timeout"},
  { id: 3, name: "device reset"}
];
function Door2event(id) {
	let did = tabDoor2event.map(el => el.id);
	let i = did.indexOf(id);
	if(i != -1) return tabDoor2event[i].name;
	return "?";
}
const tabHaBle2name = [
  { id: 0, name: "PacketId", unit: "", factor: 1},
  { id: 1, name: "battery", unit: "%", factor: 1},
  { id: 2, name: "temperature", unit: "°C", factor: 0.01},
  { id: 3, name: "humidity", unit: "%", factor: 0.01},
  { id: 4, name: "pressure", unit: "hPa", factor: 0.01},
  { id: 5, name: "illuminance", unit: "lux", factor: 0.01},
  { id: 6, name: "weight", unit: "kg", factor: 0.01},
  { id: 7, name: "weight", unit: "kg", factor: 1},
  { id: 8, name: "dewpoint", unit: "°C", factor: 0.01},
  { id: 9, name: "count", unit: "", factor: 1},
  { id: 10, name: "energy", unit: "kWh", factor: 0.001},
  { id: 11, name: "power", unit: "W", factor: 0.01},
  { id: 12, name: "voltage", unit: "V", factor: 0.001},
  { id: 13, name: "pm2x5", unit: "kg/m3", factor: 1},
  { id: 14, name: "pm10", unit: "kg/m3", factor: 1},
  { id: 15, name: "boolean", unit: "", factor: 1},
  { id: 16, name: "switch", unit: "", factor: 1},
  { id: 17, name: "opened", unit: "", factor: 1}
];

function catchAdvertisement(device) {
  addAlog("Get Advertising MAC (Web Experimental Features!)");
  const abortController = new AbortController();
  device.addEventListener('advertisementreceived', (event) => {
	addClog('Received advertisement from "' + device.name + '"...');
	event.serviceData.forEach((b, key) => {
	const buf = new Uint8Array(b.buffer);
	addClog(buf, device, event);
	let s = 'MAC: ?';
	if(key == '0000fe95-0000-1000-8000-00805f9b34fb') { // mi
		if(b.byteLength >= 2) { // custom mi
			let ctrl = b.getUint16(0, true);
			s = 'MiVer'+ (ctrl>>12);
			let i = 2;
			if((ctrl&0xf000) >= 0x2000 && b.byteLength >= i + 3) {
				let dev_id = b.getUint16(i, true);
				let frcntr = b.getUint8(i+2);
				i += 3;
				s += ', DevID: 0x'+ hex(dev_id, 4);
				s += "-" + id2name(dev_id);
				s += ', FnCnt: '+ frcntr;
				s += ', CtrID: 0x'+ hex(ctrl, 4);
				if(ctrl & 0x100)
					s +=' Registered and bound';
				else
					s +=' Not bound';
				if(ctrl & 0x200)
					s +=', Request APP to register and bind';
				switch((ctrl>>10)&3) {
					case 0:
						s +=', Old version certification';
						break;
					case 1:
						s +=', Safety certification';
						break;
					case 2:
						s +=', Standard certification';
						break;
					//case 3:
					//	s +=' reserved';
					//	break;
				}
				if(ctrl & 0x200)
					s +=', Request APP to register and bind';
				if((ctrl & 0x10) && b.byteLength >= i + 6) {
					s += ', MAC: '+hex(buf[i+5],2)+hex(buf[i+4],2)+hex(buf[i+3],2)+hex(buf[i+2],2)+hex(buf[i+1],2)+hex(buf[i],2);
					i += 6;
				}
				if((ctrl & 0x20) && b.byteLength >= i + 1) {
					let cap = b.getUint8(i);
					i += 1;
					s +=', Capability: 0x'+ hex(cap,2);
					switch((cap>>3) & 3) {
						case 0:
							s +=' - no binding';
							break;
						case 1:
							s +=' - front binding';
							break;
						case 2:
							s +=' - back binding';
							break;
						case 3:
							s +=' - Combo';
							break;
					}
					if(cap & 0x20 && b.byteLength >= i + 2) {
						s +=', IO: 0x'+ hex(b.getUint16(i, true), 4);
						i += 2;
					}
				}
				if((ctrl & 0x40)) {
					if(b.byteLength >= i + 4) {
						if(ctrl & 8) {
								s += ', Data encrypted';
						} else {
							let data_id = b.getUint16(i, true);
							let data_len = b.getUint8(i+2);
							i += 3;
							if(b.byteLength >= i + data_len) switch(data_id) {
								case 0x1006:
									if(data_len == 2) {
										let humi = b.getInt16(i, true) / 10.0;
										s += ', Humi: '+humi+'%';
									}
									break;
								case 0x1004:
									if(data_len == 2) {
										let temp = b.getInt16(i, true) / 10.0;
										s += ', Temp: '+temp+'°C';
									}
									break;
								case 0x100a:
									if(data_len == 1) {
										s += ', Bat: '+ b.getUint8(i) + '%';
										if(b.byteLength >= i + 3 && b.getUint8(i+1) == 2) {
											let Vbat = b.getUint16(i+2, true);
											s += ', Vbat: '+ Vbat + ' mV';
											i += 3;
										}
									}
									break;
								case 0x100d:
									if(data_len == 4 && b.byteLength >= i + 3) {
										let temp = b.getInt16(i, true) / 10.0;
										let humi = b.getInt16(i+2, true) / 10.0;
										s += ', Temp: '+temp+'°C Humi: '+humi+'%';
									}
									break;
								case 0x1019:
									if(data_len == 1) {
										s += ', Door: '+ Door2event(b.getUint8(i));
									}
									break;
								default:
									s += ', DataID: 0x'+hex(data_id,4);
									let data_value = 0;
									if(data_len == 1)
										s += ' Value: 0x'+hex(b.getUint8(i),2);
									else if(data_len == 2)
										s += ' Value: 0x'+hex(b.getUint16(i, true),4);
									else if(data_len == 4)
										s += ' Value: 0x'+hex(b.getUint32(i, true), 8);
									else
										s += ' DataLen: ' + data_len;
									break;
							}
							i += data_len;
						}
					}
				}
				if(ctrl & 0x80)
					s +=', Mesh Data';
			}
		}
	} else if(key == '0000181a-0000-1000-8000-00805f9b34fb') {
		if(b.byteLength >= 15) { // pvvx
			// 70 58 56 38 C1 A4 69 0A 60 09 25 0B 48 70 04
			let temp = b.getInt16(6, true) / 100.0;
			let humi = b.getInt16(8, true) / 100.0;
			let vbat = b.getUint16(10, true);
			let bat = b.getUint8(12);
			let cnt = b.getUint8(13);
			let flg = b.getUint8(14);
			s = 'MAC: '+hex(buf[5],2)+hex(buf[4],2)+hex(buf[3],2)+hex(buf[2],2)+hex(buf[1],2)+hex(buf[0],2);
			s += ', Bat: '+bat+'%, Vbat: '+vbat+' mV , Temp: '+temp+'°C, Humi: '+humi+'%, Count: '+cnt+', Flg: '+flg;
		} else if(b.byteLength == 13) { // atc1441
			// A4 C1 38 56 58 70 01 0A 18 48 0B 25 70
			let temp = b.getInt16(6, false) / 10.0;
			let humi = b.getUint8(8);
			let bat = b.getUint8(9);
			let vbat = b.getUint16(10, false);
			let cnt = b.getUint8(12);
			s = 'MAC: '+hex(buf[0],2)+hex(buf[1],2)+hex(buf[2],2)+hex(buf[3],2)+hex(buf[4],2)+hex(buf[5],2);
			s += ', Bat: '+bat+'%, Vbat: '+vbat+' mV, Temp: '+temp+'°C, Humi: '+humi+'%, Count: '+cnt;
		}
	} else if(key == '0000fff9-0000-1000-8000-00805f9b34fb') { // CGG1 "Goose"
		// 0801 AE1610342D58 0104 1401 4601 0201 58
		if(b.byteLength >= 16 && b.getUint16(0, true) == 0x0108 && b.getUint16(8, true) == 0x0401 && b.getUint16(14, true) == 0x0102) {
			let temp = b.getInt16(10, true) / 10.0;
			let humi = b.getInt16(12, true) / 10.0;
			let bat = b.getUint8(16);
			let s = 'MAC: '+hex(buf[2],2)+hex(buf[3],2)+hex(buf[4],2)+hex(buf[5],2)+hex(buf[6],2)+hex(buf[7],2);
			s += ', Bat: '+bat+'%, Temp: '+temp+'°C, Humi: '+humi+'%';
			log(s);
		}
	} else if(key == '0000fdcd-0000-1000-8000-00805f9b34fb') {	// Qingping / ClearGrass
		// CGPR1 0812 005E60342D58 0201 64 0F01 72 0904 08000000
		//	 0812 005E60342D58 0201 64 0F01 6E 0904 91140000
		//	 4812 005E60342D58 0804 01 911400 0F01 6F
		//		 4812 005E60342D58 1101 01 0F01 85
		//	 4812 005E60342D58 1101 00 0F01 8C
		let msg_length = b.byteLength;
		if(msg_length >= 11 && (b.getUint8(0)&0x3f) == 0x08) {
			let device_id = b.getUint8(1);
			s = 'MAC: '+hex(buf[2],2)+hex(buf[3],2)+hex(buf[4],2)+hex(buf[5],2)+hex(buf[6],2)+hex(buf[7],2);
			if(device_id == 0x01) s+=' CGG1 "Goose"';
			else if (device_id == 0x07) s+=' CGG1';
			else if (device_id == 0x09) s+=' CGP1W';
			else if (device_id == 0x0C) s+=' CGD1';
			else if (device_id == 0x12) s+=' CGPR1';
			//if((b.getUint8(0)&0x40)!=0) s+=', Event';
			let xdata_point = 10;
				while (xdata_point < msg_length) {
				let xdata_id = b.getUint8(xdata_point-2);
				let xdata_size = b.getUint8(xdata_point-1);
				if(xdata_point + xdata_size <= msg_length) {
				 if((xdata_id == 0x01)&&(xdata_size == 4)) {
					let temp = b.getInt16(xdata_point, true) / 10.0;
					let humi = b.getInt16(xdata_point+2, true) / 10.0;
					s += ', Temp: '+temp+'°C, Humi: '+humi+'%';
				 } else if((xdata_id == 0x02)&&(xdata_size == 1)) {
					s += ', Bat: '+b.getUint8(xdata_point)+'%';
				 } else if((xdata_id == 0x07)&&(xdata_size == 2)) {
					s += ', Pressure: '+(b.getInt16(xdata_point, true) / 100.0);
				 } else if((xdata_id == 0x08)&&(xdata_size == 4)) {
					s += ', Motion: '+ b.getUint8(xdata_point)+' & Light: '+(b.getUint16(xdata_point+1, true)+b.getUint8(xdata_point+3)*256);
				 } else if((xdata_id == 0x09)&&(xdata_size == 4)) {
					s += ', Light: '+(b.getUint32(xdata_point, true));
				 } else if((xdata_id == 0x0F)&&(xdata_size == 1)) {
					s += ', Count: '+b.getUint8(xdata_point);
				 } else if((xdata_id == 0x11)&&(xdata_size == 1)) {
					if(b.getUint8(xdata_point) == 0) s += ', Light Off';
					else s += ', Light On';
				 } else if (xdata_size == 1) {
					s += ', id: 0x'+hex(xdata_id,2)+' - data: 0x'+hex(buf[xdata_point],2);
				 } else if (xdata_size == 2) {
					s += ', id: 0x'+hex(xdata_id,2)+' - data: 0x'+hex(buf[xdata_point],2)+hex(buf[xdata_point+1],2);
				 } else if (xdata_size == 4) {
					s += ', id: 0x'+hex(xdata_id,2)+' - data: 0x'+hex(buf[xdata_point],2)+hex(buf[xdata_point+1],2)+hex(buf[xdata_point+2],2)+hex(buf[xdata_point+3],2);
				 }
				} else break;
				xdata_point = xdata_point + xdata_size + 2;
			}
		}
	} else if(key == '00001f11-0000-1000-8000-00805f9b34fb') {	// AdScanerTrg
		if(b.byteLength > 10) {
			let temp = b.getInt16(0, true) / 100.0; // temp
			let humi = b.getInt16(2, true)	/ 100.0; // humi
			let lumi = b.getInt16(4, true); // light
			let mtimer = b.getUint16(6, true)
			let motion = b.getUint8(8);
			let jlight = b.getUint8(9);
			let flg = b.getUint8(10);
			s = ("AdScanerTrg# Temp: "+temp.toFixed(2)+
			", Humi: "+humi.toFixed(2)+
			", Lumi: " +lumi.toFixed(0)+
			", MTimer: " +mtimer+
			", HiMotion: " +motion+
			", JLight: "+jlight+
			", Flg: 0x"+hex(flg,2)+
			" # ReedSwitchOut: "+(flg&1)+
			", TempHumiOut: "+((flg>>1)&1)+
			", LightMotionOut: "+((flg>>2)&1)+
			", TempEvent: "+((flg>>3)&1)+
			", HumiEvent: "+((flg>>4)&1)+
			", LightEvent: "+((flg>>5)&1));
		}
	} else if(key == '0000181c-0000-1000-8000-00805f9b34fb') {	// BTHome
		if(b.byteLength > 1) {
			s += " BTHomeV1";
			let len = b.byteLength;
			let i = 0;
			while(i < len) {
				let sl = b.getUint8(i)&31; // size
				if(i+sl+1 > len) break;
				let st = b.getUint8(i)>>5;
				if(sl > 0) {
					let dd = b.getUint8(i+1);
					let value = 0;
					let did = tabHaBle2name.map(el => el.id);
					let e = did.indexOf(dd);
					let f = 1;
					if(e != -1) f = tabHaBle2name[e].factor;
					if(st == 0) {
						if(sl == 2)
							value = b.getUint8(i+2);
						else if(sl == 3)
							value = b.getUint16(i+2, true);
						else if(sl == 4)
							value = b.getUint16(i+2, true) + (b.getUint8(i+4)<<16);
						else if(sl == 5)
							value = b.getUint32(i+2, true);
						if(f != 1)	value = (value*f).toFixed(3);
					} else if(st == 1) {
						if(sl == 2)
							value = b.getInt8(i+2);
						else if(sl == 3)
							value = b.getInt16(i+2, true);
						else if(sl == 4) {
							value = b.getUint16(i+2, true) | (b.getInt8(i+4)<<16);
						} else if(sl == 5)
							value = b.getInt32(i+2, true);
						if(f != 1)	value = (value*f).toFixed(3);
					} else
						value = "?";
					if(e != -1) {
						s += ', '+tabHaBle2name[e].name+': '+value+tabHaBle2name[e].unit;
					} else
						s += ', '+st+'?: '+value;
				}
				i += sl+1;
			}
		}
	} else if(key == '0000181e-0000-1000-8000-00805f9b34fb') {	// BTHome
		s += " BTHomeV1, Data encrypted";
	} else if(key == '0000fcd2-0000-1000-8000-00805f9b34fb') {	// BTHome v2
		if(b.byteLength > 1) {
			let ver = b.getUint8(8);
			if(ver & 0xe0 == 0x40) {
				s += " BTHomeV2";
				if(ver & 1 != 0)
					s += ", Data encrypted";
			}
		}
	}
	addAlog(s);
	abortController.abort();
	doConnect();
	})
  }, { once: true });
  addClog('Catching advertisement from "' + device.name + '"...');
  device.watchAdvertisements({ signal: abortController.signal })
  .catch(error => {
	addClog('Error: ' + error);
  });
}
var cusService, cus017Chr, cus018Chr, cus100Chr;
function sendCmdClear() {
	cus017Chr.writeValue(new Uint8Array([0x01,0x0e]))
	.then(() => { disconnect(); });
}
function getMTimer() {
	cus017Chr.writeValue(new Uint8Array([0x01,0x13]));
}
function setMTimer() {
	let t = parseInt($("mtimer").value);
	if(t > 100) {
		cus017Chr.writeValue(new Uint8Array([0x05,0x10,t&0xff,(t>>8)&0xff,(t>>16)&0xff,(t>>24)&0xff]))
		.then(() => { cus017Chr.writeValue(new Uint8Array([0x01,0x13])); });
	}
}
function CustomQingpingParse(value) {
	//let value = event.target.value;
	let cid = value.getUint16(0, true);
	if(cid == 0x1706) {
		let temp = value.getInt16(2, true)/10;
		let humi = value.getInt16(4, true)/10;
		let s = "Temp: "+temp+"C, Humi: "+humi+"%";
		$("tempHumiData").innerHTML = '<hr>'+s;
		addClog(s);
	} else if(cid == 0x0202) {
		addLog("Battery: "+ value.getUint8(2) + "%");
	} else if(cid == 0x0305) {
		let mt = value.getUint8(2);
		let lx = value.getUint16(3, true) + (value.getUint8(5) << 16);
		let tempString = "MotionT: " + mt + ", Illumination: "+ lx + " lx";
		$("tempHumiData").innerHTML = '<hr>'+tempString;
		addClog(tempString);
	} else
		addClog("CustNotify100: "+bytesToHex(event.target.value.buffer));
}

function CGPR1_Action() {
	addLog("Detected Qingping CGPR1 device");
	$("custcfg").innerHTML = '<hr>When doing an activation here the device is needed to be activated in the Mi app again when wanted to use there.<br>Press and hold the button on the device the device for 2 seconds until the LED starts flashing, and then press the "Connect" and "Activate" buttons on the TeLinkMiFlasher.<br><button type="button" onclick="sendRegister();">Do Activation</button> <button type="button" onclick="skipActivation();">Skip Activation</button>	 <button type="button" onclick="keyMiLogin();">Login</button><br>Device known id:<br><input size="40" type="text" id="known_id" value=""><br>Mi Token:<br><input size="40" type="text" id="mi_token" value=""><br>Mi Bind Key:<br><input size="40" type="text" id="mi_bind_key" value=""><br><br><button type="button" onclick="sendCmdClear();">Clear all settings and reset device (into Qingping mode)</button><br><br>MTimer: <input type="text" id="mtimer" value="?"> ms <button type="button" onclick="getMTimer();">Get</button> <button type="button" onclick="setMTimer();">Set</button><br>';
	gattServer.getPrimaryService("22210000-554a-4546-5542-46534450464d")
		.then(service => {
			addClog("Found Custom service");
			cusService = service;
			return cusService.getCharacteristic(0x0017);
		}).then(characteristic => {
			cus017Chr = characteristic;
			addClog('Found 0x0017 characteristic');
			return cusService.getCharacteristic(0x0018);
		}).then(characteristic => {
			cus018Chr = characteristic;
			addClog('Found 0x0018 characteristic');
			return cus018Chr.addEventListener('characteristicvaluechanged', event => {
				let value = event.target.value;
				addClog("CustNotify018: " + bytesToHex(event.target.value.buffer));
				let cid = value.getUint16(0, true);
				if(cid == 0x0202) {
						addLog("Battery: "+ value.getUint8(2) + "%");
				} else if(cid == 0x0405) {
					let adc = value.getUint32(2, true);
					addLog("Level: " + adc);
				} else if(cid == 0x0305) {
					let mt = value.getUint8(2);
					let lx = value.getUint16(3, true) + (value.getUint8(5) << 16);
					addLog("Event: " + mt + ", Illumination: "+ lx + " lx");
				} else if(cid == 0x1305) {
					let tm = value.getUint32(2, true);
					addLog("Timer: "+ tm + " ms (" + (tm/1000) + " sec)");
					$("mtimer").value = tm.toString(10);
				} else if(cid == 0xff04) {
					let cmd = value.getUint8(2);
					let err = value.getUint8(3);
					if(err == 0) {
						if(cmd == 0x10)	addLog("Set timer - ok");
						else if(cmd == 0x0e) addLog("Clear - ok (Mode Qingping)");
						else addLog("Command " + cmd.toString(16) + " - ok");
					} else addLog("Command " + cmd.toString(16) + " - Error " + err.toString(16));
				} else
					addLog("CustNotify018: " + bytesToHex(event.target.value.buffer));
			});
		}).then(_ => {
			return cus018Chr.startNotifications();
		}).then(_ => {
			return cusService.getCharacteristic(0x0100);
		}).then(characteristic => {
			cus100Chr = characteristic;
			addClog('Found 0x0100 characteristic');
			return cus100Chr.startNotifications().then(() => {
				cus100Chr.addEventListener('characteristicvaluechanged', event => CustomQingpingParse(event.target.value));
				cus017Chr.writeValue(new Uint8Array([0x01,0x02]))
					.then(() => { cus017Chr.writeValue(new Uint8Array([0x01,0x13])); });
				miAuthorization();
			});
		}).catch(handleError);
}
function CGDK2_Action() {
	cus017Chr = null;
	addLog("Detected Qingping CGDK2 device");
	//if(devinfo.frstr && devinfo.frstr.substr(0,5) == "2.2.3") addAlog("Warning! The device with this Firmware Revision is not supported!");
	$("custcfg").innerHTML = '<hr>When doing an activation here the device is needed to be activated in the Mi app again when wanted to use there.<br><button type="button" onclick="sendRegister();">Do Activation</button> <button type="button" onclick="keyMiLogin();">Login</button><br>Device known id:<br><input size="40" type="text" id="known_id" value=""><br>Mi Token:<br><input size="40" type="text" id="mi_token" value=""><br>Mi Bind Key:<br><input size="40" type="text" id="mi_bind_key" value="">';
	gattServer.getPrimaryService("22210000-554a-4546-5542-46534450464d")
		.then(service => {
			addClog("Found Custom service");
			cusService = service;
			return cusService.getCharacteristic(0x0100);
		}).then(characteristic => {
			cus100Chr = characteristic;
			addClog('Found 0x0100 characteristic');
			return cus100Chr.startNotifications().then(() => {
				cus100Chr.addEventListener('characteristicvaluechanged',
					event => CustomQingpingParse(event.target.value));
				miAuthorization();
			});
		}).catch(handleError);
}
function CGG1_Action(model) {
	cus017Chr = null;
	addLog("Detected Qingping CGG1 device " + model);
	$("custcfg").innerHTML = '<hr>When doing an activation here the device is needed to be activated in the Mi app again when wanted to use there.<br>Press and hold the button on the back of CGG1-M for 2 seconds until the Bluetooth icon starts blinking on the e-ink display, and then click the "Connect" and "Do Activation" buttons.<br><button type="button" onclick="sendRegister();">Do Activation</button>	<button type="button" onclick="keyMiLogin();">Login</button><br>Device known id:<br><input size="40" type="text" id="known_id" value=""><br>Mi Token:<br><input size="40" type="text" id="mi_token" value=""><br>Mi Bind Key:<br><input size="40" type="text" id="mi_bind_key" value=""><br><br>';
	gattServer.getPrimaryService("22210000-554a-4546-5542-46534450464d")
		.then(service => {
			addClog("Found Custom service");
			cusService = service;
			return cusService.getCharacteristic(0x0100);
		}).then(characteristic => {
			cus100Chr = characteristic;
			addClog('Found 0x0100 characteristic');
			return cus100Chr.startNotifications().then(() => {
				cus100Chr.addEventListener('characteristicvaluechanged',
					event => CustomQingpingParse(event.target.value));
				miAuthorization();
			});
		}).catch(handleError);
}
//var micharacteristics;
function miAction() {
	writeCharacteristicSpeed = null;
	gattServer.getPrimaryService('ebe0ccb0-7a0a-4b0c-8a1a-6ff2997da3a6')
		.then(service => {
			addClog("Found MiMain service");
			ServiceMain = service;
			addClog("Check micharacteristics:");
			return ServiceMain.getCharacteristics();
		}).then(characteristics => {
			//micharacteristics = characteristics;
			for (let i = 0; i < characteristics.length; i++) {
				addClog(characteristics[i].uuid);
				if (characteristics[i].uuid == "ebe0ccd8-7a0a-4b0c-8a1a-6ff2997da3a6") {
					ServiceMain.getCharacteristic(characteristics[i].uuid).then (characteristic =>
					{ addClog("Found MiSet characteristic Speed");
					 writeCharacteristicSpeed = characteristic; });
				}
				else if (characteristics[i].uuid == "ebe0ccc1-7a0a-4b0c-8a1a-6ff2997da3a6") {
					ServiceMain.getCharacteristic(characteristics[i].uuid).then ( characteristic =>
					{ addClog('Found MiTemp characteristic');
						nitifiyCharTemp = characteristic;
						return nitifiyCharTemp.startNotifications().then(() => {
							nitifiyCharTemp.addEventListener('characteristicvaluechanged', event => {
							let value = event.target.value;
							let temp = value.getInt16(0, true) / 100;
							let hum = value.getUint8(2);
							let vbat = value.getUint16(3,true);
							let tempTempString = "Temp: " + temp + "°C, Humi: " + hum + "%, "+vbat+" mV";
							$("tempHumiData").innerHTML = '<hr>'+tempTempString;
							addClog(tempTempString); });
						});
					});
				}
			}
			miAuthorization()
		}).catch(handleError);
}
var buf11;
var cnt_buf11 = 0;
var cnt_delkeys = 0;
var id_buf11 = 0x1000;
var mikeys = {mac: null, id: null, token: null, bindkey: null, cfg: null, delkeys: null, restore: false, cbindkey: null};
var ext = {big_number: 0, small_number: 0, vtime: 60, flg: 0xc7, enable: false};

function concatUint8ArrayArrays(a, b) { // a, b TypedArray of same type
	let c = new Uint8Array(a.byteLength + b.byteLength);
	c.set(a, 0);
	c.set(b, a.byteLength);
	return c;
}
function dump(ar, len) {
	let s = '';
	for(let i=0; i < len; i++) {
		s += hex(ar[i],2);
	}
	return s;
}
var atc_mac, atc_rmac;
function CustomBlkParse(value) {
	let len = value.byteLength;
	let s = '';
	if(len == 0) return;
	len--;	// size from cmd
	let blkid = value.getUint8(0);
	if(devTest) {
		s = 'Custom (0xffe1) Notifications id: 0x'+hex(blkid,2)+' ['+bytesToHex(value.buffer.slice(1))+']';
		addAlog(s);
		return;
	}
	if(blkid == 0x55 && len >= 9) {
		cfg.ver = value.getUint8(1);
		cfg.flg = value.getUint8(2);
		cfg.flg2 = value.getUint8(3);
		if(cfg.ver < 0x47) {
			cfg.temp_offset = value.getInt8(4);
			cfg.humi_offset = value.getInt8(5);
		}
		cfg.advertising_interval = value.getUint8(6);
		cfg.measure_interval = value.getUint8(7);
		cfg.rf_tx_power = value.getUint8(8);
		if((cfg.rf_tx_power &0x80)==0) MAX_RF_TX_Power=true;
		cfg.connect_latency = value.getUint8(9);
		if(len >= 10) cfg.lcd_tint = value.getUint8(10);
		else cfg.lcd_tint = 55;
		if(len >= 11) {
			cfg.hver = value.getUint8(11);
			if(cfg.ver < 0x36) cfg.hver &= 0x87;
		} else if(cfg.hver == null) cfg.hver = 0x80;
		if(len >= 12) cfg.av_meas_mem = value.getUint8(12); else cfg.av_meas_mem = 0;
		let s = 'Hardware Version: ';
		if(cfg.ver < 0x48)
			hwver_id = cfg.hver & 0x0F;
		else
			hwver_id = cfg.hver;
		if((hwver_id == 0)||(hwver_id == 3)||(hwver_id == 4)||(hwver_id == 5)||(hwver_id == 10)) s +='LYWSD03MMC';
		else if(hwver_id == 1) s +='MHO-C401';
		else if(hwver_id == 2) s +='CGG1';
		else if(hwver_id == 6) s +='CGDK2';
		else if(hwver_id == 7) s +='CGG1-M';
		else if(hwver_id == 8) s +='MHO-C401N';
		else if(hwver_id == 9) { s +='MJWSD05MMC'; bigOtaEnabled = true; }
		else if(hwver_id == 11) { s +='MHO-C122'; bigOtaEnabled = true; }
		else {
			if(cfg.ver < 0x48) {
				if((hwver_id == 15)&&(len >= 11))  {
					cfg.ext_hw_id = cfg.lcd_tint & 0x7f;
					hwver_id = 16 + cfg.ext_hw_id;
					if((cfg.lcd_tint & 0x80) != 0) bigOtaEnabled = true;
				}
			}
			if(hwver_id == 17) s +='TS0201';
			else if(hwver_id == 18) s +='TNKS1';
			else if(hwver_id == 22) s +='TH03Z';
			else if(hwver_id == 27) s +='ZTH01';
			else if(hwver_id == 28) s +='ZTH02';
			else s += 'Unknown or DIY ('+hwver_id+')';
		}
		if(cfg.ver > 0x45 && hwver_id <= 15) bigOtaEnabled = true;
		if(devinfo.hrstr) s += ' ' + devinfo.hrstr;
		s += ', Software Version: '+(cfg.ver>>4)+'.'+(cfg.ver&0x0f);
		setStatus(s);
		if(hwver_id <= 15 && cfg.ver > 0x33) {
			if((cfg.hver & 0x80) == 0) s += ', Sensor: SHT4x';
			else s += ', Sensor: SHTC3 (SHTV3)';
		} else {
			if(hwver_id == 17) s +=', Sensor: CHT8305';
			else if(hwver_id == 18) s +=', Sensor: AHT25';
			else if(hwver_id == 22) s +=', Sensor: GXHT30';
			else if(hwver_id == 27) s +=', Sensor: AHT30';
			else if(hwver_id == 28) s +=', Sensor: AHT20';
		}
		addAlog(s);
		addAlog('Custom config HEX string: 55' + bytesToHex(value.buffer.slice(2)));
		if(cfg.ver >= 5) CustomConfig();
		else addLog('Old version - out of service!');
	} else if(blkid == 0x33 && len >= 8) {
		let vbat = value.getUint16(1, true);
		let temp = value.getInt16(3, true) / 100.0;
		let humi = value.getInt16(5, true) / 100.0;
		let count = value.getUint16(7, true);
		let flg = 0;
		let rds_count = 0;
		if(len > 8) {
			flg = value.getUint8(9);
			if(len > 12)
				rds_count = value.getUint32(10, true);
		}
		let sw = 'Open';
		if((flg & 1) == 0) sw = 'Close';
		let s = '';
		if(cfg.ver >= 0x37)
			s = 'Vbat: '+vbat+' mV , Temp: '+temp.toFixed(2)+'°C, Humi: '+humi.toFixed(2)+'%, ID: '+count+', Reed switch counter: '+ rds_count+', Switch ' + sw +', TRG Out "' + ((flg & 2) >> 1) + '", flg: 0x'+hex(flg,2);
		else
			s = 'Vbat: '+vbat+' mV , Temp: '+temp.toFixed(2)+'°C, Humi: '+humi.toFixed(2)+'%, ID: '+count+', Switch ' + sw +', TRG Out "' + ((flg & 2) >> 1) + '", flg: 0x'+hex(flg,2);
		$("tempHumiData").innerHTML = s;
		addClog(s);
	} else if(blkid == 0x22 && len >= 7) {
		if(hwver_id == 9) {
			ext.big_number = value.getInt32(1, true); // -9950..199950, x0.01
			ext.small_number = 0;
		} else {
			ext.big_number = value.getInt16(1, true); // -995..19995, x0.1
			ext.small_number = value.getInt16(3, true); // -9..99, x1
		}
		ext.vtime = value.getUint16(5, true); // in sec
		ext.flg = value.getUint8(7);
		s = 'ExtShow: big_number: '+ext.big_number+', small_number: '+ext.small_number+', ext.vtime: '+ext.vtime+' s, flg: '+hex(ext.flg,2);
		addAlog(s); UpdExt();
	} else if((blkid == 0x25 || blkid == 0x26) && (len > 16)) {
	// CMD_ID_CFS Get/Set sensor config
	    devSens.temp_k = value.getUint32(1, true);
	    devSens.humi_k = value.getUint32(5, true);
	    devSens.temp_z = value.getInt16(9, true);
	    devSens.humi_z = value.getInt16(11, true);

		$('inpTempK').value  = (devSens.temp_k/100.0).toFixed(2);
		$('inpHumK').value = (devSens.humi_k/100.0).toFixed(2);
		$('inpTempZ').value = (devSens.temp_z/100.0).toFixed(2);
		$('inpHumZ').value  = (devSens.humi_z/100.0).toFixed(2);

		devSens.i2c_addr = value.getUint8(17);
		let st = "Unknown";
		if(len > 17) { // ver 4.9
			devSens.id = value.getUint32(13, true);
				let sentype = value.getUint8(18);
				if(sentype == 1)
					st = "SHTV3(C3)";
				else if(sentype == 2)
					st = "SHT4x";
				else if(sentype == 3)
					st = "SHT30";
				else if(sentype == 4)
					st = "CHT8305";
				else if(sentype == 5)
					st = "ANT20/30";
				else if(sentype == 6)
					st = "CHT8215";
				else if(sentype == 0)
				    st = "None"
		} else {
			devSens.id = value.getUint32(13, false);
			if((devSens.id & 0xFFFF) == 0x2000)
				st = "AHT20/30";
			else if((devSens.id & 0xFFFF) == 0x3000)
				st = "SHT30";
			else if(devSens.id == 0x83055959)
				st = "CHT8305";
			else if(devSens.i2c_addr == 0xE0)
				st = "SHTv3";
			else if(devSens.i2c_addr == 0x88 || devSens.i2c_addr == 0x8A)
				st = "SHT4x";
		}
		$('lblSensor').innerHTML = "<b>Sensor Settings:</b> (" + st + ", I2C address: 0x"+hex(devSens.i2c_addr,2) + ", ID: " + hex(devSens.id, 8) + ")";
		addAlog("Sensor "+st+" id: "+hex(devSens.id, 8)
		   + ", I2C address: 0x" + hex(devSens.i2c_addr,2)
		   + ", Kt: " + devSens.temp_k
		   + ", Kh: " + devSens.humi_k
		   + ", Zt: " + devSens.temp_z
		   + ", Zh: " + devSens.humi_z);

	} else if(blkid == 0x44 && len >= 7) {
		trg.tmp_thr = value.getInt16(1, true) / 100.0; // temp threshold
		trg.hm_thr = value.getInt16(3, true) / 100.0; // humi threshold
		trg.rds_type = 0;
		trg.rds_rpint = 0;
		if(len >= 9) {
			trg.tmp_hst = value.getInt16(5, true) / 100.0;		  // temp hysteresis
			trg.hm_hst = value.getInt16(7, true) / 100.0;		 // humi hysteresis
			if((len >= 12) && (cfg.ver >= 0x37)) {
				trg.rds_rpint = value.getUint16(9, true);
				trg.rds_type = value.getUint8(11);
				trg.flg = value.getUint8(12);
			} else
				trg.flg = value.getUint8(9);
		} else {
			trg.tmp_hst = value.getInt8(5) / 10.0;		  // temp hysteresis
			trg.hm_hst = value.getInt8(6) / 10.0;		 // humi hysteresis
			trg.flg = value.getInt8(7);
		}
		let s = '';
		if(cfg.ver >= 0x37)
			s = 'Threshold Temp/Humi: '+trg.tmp_thr.toFixed(2)+'°C/'+trg.hm_thr.toFixed(2)+'%, Hysteresis T/H: '+trg.tmp_hst.toFixed(2)+'°/'+trg.hm_hst.toFixed(2)+'%, Reed switch mode: '+trg.rds_type+', Rs rep.interval: '+trg.rds_rpint+' sec, flg: 0x'+hex(trg.flg,2);
		else
			s = 'Threshold Temp/Humi: '+trg.tmp_thr.toFixed(2)+'°C/'+trg.hm_thr.toFixed(2)+'%, Hysteresis T/H: '+trg.tmp_hst.toFixed(2)+'°/'+trg.hm_hst.toFixed(2)+'%, flg: 0x'+hex(trg.flg,2);
		if((cfg.ver >= 0x39)&&((trg.rds_type&0x10)!=0)) s += ', RS input inversion'
		addAlog(s); UpdTrg();
	} else if(blkid >= 0x10 && blkid <= 0x14 && len >= 1) {
		let lb = value.getUint8(1);
		// addClog('id: '+blkid+', lb: '+lb+ ', len: ' + len);
		if(lb != 0) {
			len -= 1;
			if(cnt_buf11 == 0){
				//addClog('New miKey length: '+lb);
				buf11 = new Uint8Array(lb);
			}
			for(let i = 0; i < len && i < lb; i++ )
				buf11[cnt_buf11++] = value.getUint8(i+2);
			if(len == lb) {
				if(cnt_buf11 == buf11.length) {
					s = '';
					if(blkid == 0x14)  {
						if(cnt_delkeys == 0) {
							mikeys.delkeys = [];
						}
						s = 'Marked as delete Key'+cnt_delkeys+': ';
						cnt_delkeys += 1;
						mikeys.delkeys.push(buf11);
					}
					if(cnt_buf11 == 28) {
						s +=  'miToken: '+dump(buf11.slice(0, 12), 12)+', miBindKey: '+dump(buf11.slice(12), 16);
						if(blkid == 0x12) {
							cnt_delkeys = 0;
							mikeys.token = buf11.slice(0, 12);
							mikeys.bindkey = buf11.slice(12);
							CustomConfig();
						} else if(blkid == 0x14) {
							if(mikeys.token) mikeys.restore = true;
						}
						addLog(s);
					} else if(cnt_buf11 == 20) {
						let str = new TextDecoder("utf-8").decode(buf11.slice(1));
						s += 'miDevId: "'+str+'" '+dump(buf11.slice(1), 19);
						if(blkid == 0x11) {
							cnt_delkeys = 0;
							mikeys.id = buf11;
						}
						addLog(s);
					} else if(cnt_buf11 == 8) {
						// * public_mac:		[0][1][2][3][4][5], const: [3]=38;[4]=C1;[5]=A4
						// * random_static_mac: [0][1][2][6][7]C0
						m = hex(buf11[5],2)+hex(buf11[4],2)+hex(buf11[3],2)+hex(buf11[2],2)+hex(buf11[1],2)+hex(buf11[0],2);
						s += 'MAC: '+m+', RandMAC: '+'C0'+hex(buf11[7],2)+hex(buf11[6],2)+hex(buf11[2],2)+hex(buf11[1],2)+hex(buf11[0],2);
						if(blkid == 0x10) {
							cnt_delkeys = 0;
							mikeys.mac = buf11;
							addLog(s);
							$("mi_mac").value = m + hex(buf11[7],2)+hex(buf11[6],2);
						}
					} else if(cnt_buf11 == 4) {
						s += 'miCfg: '+dump(buf11, 4);
						if(blkid == 0x13) {
							cnt_delkeys = 0;
							mikeys.cfg = buf11;
							addLog(s);
						}
					} else
						s += 'miKey: '+dump(buf11, cnt_buf11);
					addClog(s);
				}
				cnt_buf11 = 0;
			}
		} else if(cnt_buf11 != 0) {
			cnt_buf11 = 0;
			addClog("Error read mi keys!");
		} else {
			if(blkid == 0x11) addAlog('No miDevId!');
			else if(blkid == 0x12) addAlog('No miToken and miBindKey!');
			else if(blkid == 0x13) addAlog('No miCFG!');
			else if(blkid == 0x14) {addClog("End keys"); CustomConfig();}
			else addClog("End keys");
			cnt_buf11 = 0;
		}
	} else if(blkid == 0x18 && len >= 1) { // Get/set beacon bkey in EEP
		if(len >= 16) {
			mikeys.cbindkey = value.buffer.slice(1);
			let s = bytesToHex(mikeys.cbindkey,16);
			addAlog("Read bindkey: "+ s);
			if($("cbind_key"))
				$("cbind_key").value = s;
		} else {
			if(len == 1 && value.getUint8(1) == 0xff)
				addAlog("No bindkey in EEP!");
			else
				addAlog("Error read bindkey from EEP!");
			if($("cbind_key"))
				$("cbind_key").value = '?';
		}
	} else if(blkid == 0x60 && len >= 6) {
		s = 'LCD data: '+bytesToHex(value.buffer.slice(1));
		addAlog(s);
	} else if(blkid == 0x61 && len >= 1) {
		let s = 'LCD flg: '+hex(value.getUint8(1), 2);
		addClog(s);
	} else if(blkid == 0x35) {
		if(flg_memo_act) {
			if(len >= 12) {
				let cnt = value.getUint16(1, true);
				let tc = value.getUint32(3, true);
				let tm = value.getInt16(7, true) / 100.0;
				let hm = value.getUint16(9, true) / 100.0;
				let vb = value.getUint16(11, true);
				let dt = new Date(tc*1000);
				addAlog(((dt.toISOString().slice(0, -1)).replace('T',' ')).replace('.000','')+' # Vbat: '+vb+' mV , Temp: '+tm+'°C, Humi: '+hm+'%, Count: '+cnt);
			} else if(len >= 2) {
				let cnt = value.getUint16(1, true);
				addAlog('Memo end: '+cnt);
				flg_memo_act = false;
			}
		}
	} else if(blkid == 0x23 && len >= 4) {
		devtime.cur = value.getUint32(1,true);
		addClog('Device Time: 0x' + hex(devtime.cur,8));
		let dt = new Date(devtime.cur*1000);
		addAlog('Device Date: '+(dt.toISOString().slice(0, -1)).replace('T',' '));
		if(len >= 8) {
			devtime.set = value.getUint32(5,true);
			addClog('Last clock setting Time: 0x' + hex(devtime.set,8));
			if(devtime.step == 1) {
				if(devtime.set > 0x60000000) {
					devtime.period = devtime.cur - devtime.set;
					let time = Date.now()/1000;
					time -= (new Date()).getTimezoneOffset() * 60;
					devtime.cmp = time;
					let odt = new Date(devtime.set*1000);
					addAlog('Last clock setting: '+(odt.toISOString().slice(0, -1)).replace('T',' '));
					addAlog('DevPeriod: ' + devtime.period.toFixed(1) + ' sec');
					let rp = devtime.cmp - devtime.set;
					let delta = rp - devtime.period;
					addClog('RealPeriod: ' + rp.toFixed(1) + ' sec, Delta: ' + delta.toFixed(1) + ' sec');
					if(rp >= 10800) { // 10800
						devtime.step = 2;
						addClog("Send cmd Get StepTimeSec...");
						settingsCharacteristics.writeValue(new Uint8Array([0x24])).then(_ => {
							addAlog('Get StepTimeSec...');
						});
					} else {
						devtime.step = 0;
						addAlog('The minimum period for calculation is 3 hours!');
					}

				} else {
					devtime.step = 0;
					addAlog('The clock must be set beforehand!');
				}
			}
		}
	} else if(blkid == 0x24 && len >= 4) {
		cfg.step_time = value.getUint32(1,true);
		addClog('step_time: ' + cfg.step_time);
		addAlog('Device StepTimeSec: ' + (cfg.step_time / 16.0).toFixed(3) + ' us');
		if($("cfg_time_step") && cfg.ver >= 0x24) {
			if(devtime.step == 2) {
						devtime.step = 0;
				let rp = devtime.cmp - devtime.set;
				let k = devtime.period/rp;
				addClog('koef: ' + k);
				let nstep_time = cfg.step_time * k;
				$("cfg_time_step").value = nstep_time - 16000000;
				addClog('step_time: ' + nstep_time.toFixed(1));
			} else
				$("cfg_time_step").value = cfg.step_time - 16000000;
		}
	} else if(blkid == 0x20 && len >= 8) {
		cmf.tmp_lo = value.getInt16(1, true); // temp lo
		cmf.tmp_hi = value.getInt16(3, true); // temp hi
		cmf.hm_lo = value.getUint16(5, true); // humi lo
		cmf.hm_hi = value.getUint16(7, true); // humi lo
		let s = 'Comfort Temp: '+(cmf.tmp_lo/100.0).toFixed(2)+'..'+(cmf.tmp_hi/100.0).toFixed(2)+'°C, Humi: '+(cmf.hm_lo/100.0).toFixed(2)+'..'+(cmf.hm_hi/100.0).toFixed(2)+'%';
		addAlog(s); UpdCmf();
	} else if(blkid == 0x73 && len >= 9) {
		let e = value.getUint8(1);
		let faddr = value.getUint32(2, true);
		let fszk = value.getUint32(6, true); // in kbytes
		let s = 'OTA region: 0x'+hex(faddr,6)+', size: '+fszk+' kbytes';
		if(e == 1) s += ' -> OTA works';
		else if(e == 2) s += ' -> Ext.OTA busy';
		else if(e == 3) s += ' -> Ext.OTA ready';
		else if(e == 4) s += ' -> Ext.OTA event';
		else if(e > 0x80) s += ' -> Ext.OTA error';
		else e += ' ('+e+')';
		addClog(s);
		if(e == 4) {
			s = 'Erase the Flash sector at: 0x'+hex(faddr,6)+'...';
			setStatus(s);
			addClog(s);
		} else if(e == 3) {
			s = 'Clean Flash OTA region: 0x'+hex(faddr,6)+', size: '+fszk+' kbytes. Go OTA...';
			setStatus(s);
			addLog(s);
			fwmaxsize = (fszk << 10) + 4096;
			if(bigOtaEnabled) setTimeout(updateBegin(), 1000);
		} else	addClog(s);
	} else if(blkid == 0x01 && len >= 1) {
		dnm.name = new TextDecoder("utf-8").decode(value.buffer.slice(1));
		if($("dev_name"))
			$("dev_name").value = dnm.name;
		addAlog("DevName: ["+dnm.name+"]");
	} else if(blkid == 0x02 && len > 1) {
		let addr = value.getUint8(1);
		s = 'Sensor: ';
		if(addr != 0)
			s += 'I2C addres 0x'+hex(addr >> 1,2);
		else
			s += 'None!';
		s += ', LCD driver: ';
		addr = value.getUint8(2);
		if(addr != 0)
			s += 'I2C addres 0x'+hex(addr >> 1,2);
		else
			s += 'SPI or UART';
		if(len > 2) {
			addr = value.getUint8(3);
			s += ', RTC: ';
			if(addr != 0)
				s += 'I2C addres 0x'+hex(addr >> 1,2);
			else
				s += 'Unknown';
		}
		addAlog(s);
	} else if(blkid == 0x04 && len > 0) {
		let wr = value.getUint8(1);
		if(len == 1)
				s = 'I2C Read/Write fault! ('+wr+')';
		else {
			let addr = value.getUint8(2);
			s = 'I2C addres 0x'+hex(addr,2);
			if(wr != 0)
				s += ', write '+wr+' bytes';
			if(len > 2)
				s += ', read '+ (len-2) +' bytes: '+bytesToHex(value.buffer.slice(3));
		}
		addAlog(s);
	} else if(blkid == 0x05 && len > 3) {
		addAlog('Sensor ID: ' + hex(value.getUint32(1,true),8));
	} else if(blkid == 0x45) {
		let flg = value.getUint8(1);
		let sw = 'Close';
		if((flg & 1) == 0) sw = 'Open';
		let s = 'Switch ' + sw +', TRG Out "' + ((flg & 2) >> 1) + '", flg: 0x'+hex(flg,2);
		$("tempHumiData").innerHTML = s;
		addClog(s);
	} else {
		let s = 'Custom (0x1f1f) Notifications id: 0x'+hex(blkid,2)+' ['+bytesToHex(value.buffer.slice(1))+']';
		addClog(s);
	}
}

function decimalToHex00(d) {
    var hex = Number(d).toString(16);
    while (hex.length < 2) {
        hex = "0" + hex;
    }
    return hex;
}
function mapper_toggle() {
  var mapper_content_div = $("mapper_content");
  var mapper_button = $("mapper_toggle_button");
  if (mapper_content_div.style.display === "none") {
    mapper_content_div.style.display = "block";
	mapper_button.innerText  = "Hide LCD Segment Mapper";
  } else {
    mapper_content_div.style.display = "none";
	mapper_button.innerText  = "Show LCD Segment Mapper";
  }
}
function mapper_send() {
	var byte0 = 0;
	var byte1 = 0;
	var byte2 = 0;
	var byte3 = 0;
	var byte4 = 0;
	var byte5 = 0;

	if($("check00").checked)byte0 += 1;
	if($("check01").checked)byte0 += 2;
	if($("check02").checked)byte0 += 4;
	if($("check03").checked)byte0 += 8;
	if($("check04").checked)byte0 += 16;
	if($("check05").checked)byte0 += 32;
	if($("check06").checked)byte0 += 64;
	if($("check07").checked)byte0 += 128;

	if($("check10").checked)byte1 += 1;
	if($("check11").checked)byte1 += 2;
	if($("check12").checked)byte1 += 4;
	if($("check13").checked)byte1 += 8;
	if($("check14").checked)byte1 += 16;
	if($("check15").checked)byte1 += 32;
	if($("check16").checked)byte1 += 64;
	if($("check17").checked)byte1 += 128;

	if($("check20").checked)byte2 += 1;
	if($("check21").checked)byte2 += 2;
	if($("check22").checked)byte2 += 4;
	if($("check23").checked)byte2 += 8;
	if($("check24").checked)byte2 += 16;
	if($("check25").checked)byte2 += 32;
	if($("check26").checked)byte2 += 64;
	if($("check27").checked)byte2 += 128;

	if($("check30").checked)byte3 += 1;
	if($("check31").checked)byte3 += 2;
	if($("check32").checked)byte3 += 4;
	if($("check33").checked)byte3 += 8;
	if($("check34").checked)byte3 += 16;
	if($("check35").checked)byte3 += 32;
	if($("check36").checked)byte3 += 64;
	if($("check37").checked)byte3 += 128;

	if($("check40").checked)byte4 += 1;
	if($("check41").checked)byte4 += 2;
	if($("check42").checked)byte4 += 4;
	if($("check43").checked)byte4 += 8;
	if($("check44").checked)byte4 += 16;
	if($("check45").checked)byte4 += 32;
	if($("check46").checked)byte4 += 64;
	if($("check47").checked)byte4 += 128;

	if($("check50").checked)byte5 += 1;
	if($("check51").checked)byte5 += 2;
	if($("check52").checked)byte5 += 4;
	if($("check53").checked)byte5 += 8;
	if($("check54").checked)byte5 += 16;
	if($("check55").checked)byte5 += 32;
	if($("check56").checked)byte5 += 64;
	if($("check57").checked)byte5 += 128;

	var segment_bytes_to_send = "dd" + decimalToHex00(byte0)+ decimalToHex00(byte1)+ decimalToHex00(byte2)+ decimalToHex00(byte3)+ decimalToHex00(byte4)+ decimalToHex00(byte5);
	addLog("Sending Segment bytes: " + segment_bytes_to_send);
	sendCustomSetting(segment_bytes_to_send);
}


function customAction() {
	gattServer.getPrimaryService('00001f10-0000-1000-8000-00805f9b34fb').then(service => {
		addClog("Found custom Main service (0x1f10)");
		ServiceMain = service;
		return ServiceMain.getCharacteristic('00001f1f-0000-1000-8000-00805f9b34fb');
	}).then(characteristic => {
		settingsCharacteristics = characteristic;
		addClog("Found custom read-write characteristic (0x1f1f)");
		if(devIdEnabled) {
			addClog("Start Notifications (0x1f1f)");
			settingsCharacteristics.startNotifications()
			.then(characteristic => {
				addClog("Add EventListener (0x1f1f)");
				settingsCharacteristics.addEventListener('characteristicvaluechanged', event => CustomBlkParse(event.target.value));
				addClog("Read Characteristics (0x1f1f)");
				settingsCharacteristics.readValue()
				.then(value => {
					$("ldfile").hidden = false;
					addClog("Send cmd (3303): Query 3 measurements");
					settingsCharacteristics.writeValue(new Uint8Array([0x33,0x03]))
					.then(_ => {addClog('Send cmd ok');})
					.catch(error => addClog(error));
				}).catch(error => { addClog(error);
					addLog("Detected alternative Firmware? Use: https://pvvx.github.io/ATC_MiThermometer/TelinkOTA.html");
					setStatus('Detected alternative Firmware? <a href="https://pvvx.github.io/ATC_MiThermometer/TelinkOTA.html" target="_blank">TelinkOTA</a>');
				});
			}).catch(error => addClog(error));
		} else {
			$("custcfg").innerHTML = '<b>ATC1441 firmware:</b> Use <a href="https://atc1441.github.io/TelinkFlasher.html" target="_blank">Atc1441 TelinkOTA</a> or <a href="https://pvvx.github.io/ATC_MiThermometer/TelinkOTA.html">SDK TelinkOTA</a>!<br><br>Send commands to custom firmware:<br><input type="text" id="cmdTXT" value=""><button type="button" onclick="sendCustomSetting($(&quot;cmdTXT&quot;).value,settingsCharacteristics);">Send</button><br>Settings: <button type="button" onclick="sendCustomSetting(&quot;DF&quot;);">Save current settings in flash</button><button type="button" onclick="sendCustomSetting(&quot;DE&quot;);">Reset settings to default</button><br><br>Smiley: <button type="button" onclick="sendCustomSetting(&quot;A0&quot;);">Off</button> <button type="button" onclick="sendCustomSetting(&quot;A1&quot;);">Happy</button> <button type="button" onclick="sendCustomSetting(&quot;A2&quot;);">Sad</button> <button type="button" onclick="sendCustomSetting(&quot;AB&quot;);">Blinking</button> <button type="button" onclick="sendCustomSetting(&quot;A3&quot;);">Comfort Indicator</button><br><br>Advertising Type:<button type="button" onclick="sendCustomSetting(&quot;AE&quot;);">Custom</button> <button type="button" onclick="sendCustomSetting(&quot;AF&quot;);">Mi Like</button> <br><br> Sensor display: <button type="button" onclick="sendCustomSetting(&quot;CC&quot;);">In °C</button> <button type="button" onclick="sendCustomSetting(&quot;FF&quot;);">In °F</button> <br><br> Sensor advertising: <button type="button" onclick="sendCustomSetting(&quot;0C&quot;);">In °C</button> <button type="button" onclick="sendCustomSetting(&quot;0F&quot;);">In °F</button> <br><br> Show battery in LCD: <button type="button" onclick="sendCustomSetting(&quot;B1&quot;);">Enabled</button> <button type="button" onclick="sendCustomSetting(&quot;B0&quot;);">Disabled</button> <br><br> Advertising interval: <button type="button" onclick="sendCustomSetting(&quot;FE01&quot;);">10 Seconds</button> <button type="button" onclick="sendCustomSetting(&quot;FE06&quot;);">1 Minute</button> <button type="button" onclick="sendCustomSetting(&quot;FE1E&quot;);">5 Minutes</button> <button type="button" onclick="sendCustomSetting(&quot;FE3C&quot;);">10 Minutes</button> <br><br> Sensor offset: <button type="button" onclick="sendCustomSetting(&quot;FA00&quot;);">Temp 0°C offset</button> <button type="button" onclick="sendCustomSetting(&quot;FB00&quot;);">Humi 0% offset</button><br> To set a precise offset use the text input field with FA+offset for Temp and FB+offset for Humiditiy convert an int8 to hex. <br><br> Sensor instant Advertising: <button type="button" onclick="sendCustomSetting(&quot;FC05&quot;);">Temp 0,5°C instant alarm</button> <button type="button" onclick="sendCustomSetting(&quot;FD05&quot;);">Humi 5% instant alarm</button><br> To set other values use the text input with FC+temp alarm or FD+humi alarm with uint8_t values. This can be used to get instant advertising if the sensor data changes to fast. Temp divided by 10 <br> To set a precise offset use the text input field with FA+offset for Temp and FB+offset for Humiditiy convert an int8 to hex. <br><hr> <div id="mapper"><button id="mapper_toggle_button" type="button" onclick="mapper_toggle();">Show LCD Segment Mapper</button><br> <div style="display: none" id="mapper_content"> <div> Byte0 <input type="checkbox" id="check00">0</input> <input type="checkbox" id="check01">1</input> <input type="checkbox" id="check02">2</input> <input type="checkbox" id="check03">3</input> <input type="checkbox" id="check04">4</input> <input type="checkbox" id="check05">5</input> <input type="checkbox" id="check06">6</input> <input type="checkbox" id="check07">7</input></div> <div>Byte1: <input type="checkbox" id="check10">0</input>  <input type="checkbox" id="check11">1</input>  <input type="checkbox" id="check12">2</input>  <input type="checkbox" id="check13">3</input>  <input type="checkbox" id="check14">4</input>  <input type="checkbox" id="check15">5</input>  <input type="checkbox" id="check16">6</input>  <input type="checkbox" id="check17">7</input> </div> <div> Byte2:  <input type="checkbox" id="check20">0</input>  <input type="checkbox" id="check21">1</input>  <input type="checkbox" id="check22">2</input>  <input type="checkbox" id="check23">3</input>  <input type="checkbox" id="check24">4</input>  <input type="checkbox" id="check25">5</input>  <input type="checkbox" id="check26">6</input>  <input type="checkbox" id="check27">7</input> </div> <div> Byte3:  <input type="checkbox" id="check30">0</input>  <input type="checkbox" id="check31">1</input>  <input type="checkbox" id="check32">2</input>  <input type="checkbox" id="check33">3</input>  <input type="checkbox" id="check34">4</input>  <input type="checkbox" id="check35">5</input>  <input type="checkbox" id="check36">6</input>  <input type="checkbox" id="check37">7</input> </div> <div> Byte4:  <input type="checkbox" id="check40">0</input>  <input type="checkbox" id="check41">1</input>  <input type="checkbox" id="check42">2</input>  <input type="checkbox" id="check43">3</input>  <input type="checkbox" id="check44">4</input>  <input type="checkbox" id="check45">5</input>  <input type="checkbox" id="check46">6</input>  <input type="checkbox" id="check47">7</input> </div> <div> Byte5:  <input type="checkbox" id="check50">0</input>  <input type="checkbox" id="check51">1</input>  <input type="checkbox" id="check52">2</input>  <input type="checkbox" id="check53">3</input>  <input type="checkbox" id="check54">4</input>  <input type="checkbox" id="check55">5</input>  <input type="checkbox" id="check56">6</input>  <input type="checkbox" id="check57">7</input> </div> <button type="button" onclick="mapper_send()">Send bytes</button><br> </div> </div>';
		}
	}).catch(handleError);
}

function getTestCharacteristic() {
	gattServer.getPrimaryService('0000ffe0-0000-1000-8000-00805f9b34fb').then(service => {
		addClog("Found custom Main service (0xffe0)");
		ServiceMain = service;
		return ServiceMain.getCharacteristic('0000ffe1-0000-1000-8000-00805f9b34fb');
	}).then(characteristic => {
		settingsCharacteristics = characteristic;
		addClog("Found custom read-write characteristic (0xffe1)");
		addClog("Start Notifications (0xffe1)");
		settingsCharacteristics.startNotifications().then(characteristic => {
			addClog("Add EventListener (0xffe1)");
			settingsCharacteristics.addEventListener('characteristicvaluechanged', event => CustomBlkParse(event.target.value));
			addLog("Detected alternative Firmware? Use: https://pvvx.github.io/ATC_MiThermometer/TelinkOTA.html");
			setStatus('Detected alternative Firmware? <a href="https://pvvx.github.io/ATC_MiThermometer/TelinkOTA.html" target="_blank">TelinkOTA</a>');
		});
	}).catch(handleError);
}

function menuUpgrade() {
	let is = "";
	$("ldfile").hidden = false;
	if(hwver_id != null) {
		if(otafiles.loaded && otafiles.version) {
			if(otafiles.custom != null) {
				let fn = otafiles.custom[hwver_id];
				if(fn != null && fn != "" && fn != "?" && fn != "/") {
					try {
						if(fn.slice(0,6) == "https:")
							fn = (new URL(fn)).pathname.split("/").pop();
					} catch (error) {
						console.log(error);
					}
					fn = fn.substring(fn.lastIndexOf('/')+1);
					is += '<button type="button" id="firmupg" onclick="FirmwareUpgrade();">Custom Firmware: ' + fn + '</button>';
				}
			}
			if(otafiles.betafw && otafiles.betaver != null) {
				let fn = otafiles.betafw[hwver_id];
				if(fn != null && fn != "" && fn != "?" && fn != "/") {
					try {
						if(fn.slice(0,6) == "https:")
							fn = (new URL(fn)).pathname.split("/").pop();
					} catch (error) {
						console.log(error);
					}
					fn = fn.substring(fn.lastIndexOf('/')+1);
					is += ' <button type="button" id="btfrmupg" onclick="BetaFirmwareUpgrade();">Beta Firmware: ' + fn + '</button><br>';
				}
			}
			if(otafiles.zbjson != null && otazfiles.loaded) {
				let fn = otazfiles.bin[hwver_id];
				if(fn != null && fn != "" && fn != "?" && fn != "/") {
					try {
						if(fn.slice(0,6) == "https:")
							fn = (new URL(fn)).pathname.split("/").pop();
					} catch (error) {
						console.log(error);
					}
					fn = fn.substring(fn.lastIndexOf('/')+1);
					is +=' <button type="button" id="btzrupg" onclick="FirmwareZigbee();">Zigbee Firmware: ' + fn +'</button><br>';
				}
			}
			if(otafiles.original != null) {
				let fn = otafiles.original[hwver_id];
				if(fn != null && fn != "" && fn != "?" && fn != "/") {
					try {
						if(fn.slice(0,6) == "https:")
							fn = (new URL(fn)).pathname.split("/").pop();
					} catch (error) {
						console.log(error);
					}
					fn = fn.substring(fn.lastIndexOf('/')+1);
					is +=' <button type="button" id="btorupg" onclick="BackToOriginal();">' + fn +'</button><br>';
				}
			}
			if(hwver_id == 0 || hwver_id == 3 || hwver_id == 4 || hwver_id == 5 || hwver_id ==10)
				is +=' <button type="button" id="btzdevbis" onclick="FirmwareZdevbis();">Zigbee devbis Firmware: 1.1.0.0</button><br>';
		}
	}
	if(fwname != "" && firmwareArray != "") {
		if(is != "") is += '<br>';
		is += '<button type="button" onclick="startDFU();">Start Flashing</button> fw: \''+fwname+'\'';
	}
	$("ldfrmw").innerHTML = is;
}

function miAuthorization() {
	gattServer.getPrimaryService(0xfe95)
		.then(service => {
			addClog("Found Main service");
			enc_main = service;
			return enc_main.getCharacteristic(0x0010);
		}).then(characteristic => {
			addClog("Found enc_10 char");
			enc_10 = characteristic;
			return enc_main.getCharacteristic(0x0019);
		}).then(characteristic => {
			addClog('Found enc_19 char');
			enc_19 = characteristic;
			miConnected = true;
			return enc_10.startNotifications().then(() => {
				enc_10.addEventListener('characteristicvaluechanged', event => {
					var value = bytesToHex(event.target.value.buffer);
					addClog("Enc_10: " + value);
					if (value == "11000000") { // REG_SUCCESS
						setStatus("Registration successful");
						addLog("Registration successful");
						sendLogin();
					} else if (value == "12000000") { // REG_FAILED
						addLog("Registration failed!");
						setStatus("Registration failed!");
					} else if (value == "13000000") { // REG_VERIFY_SUCC
						addLog("Registration verify successful");
						setStatus("Registration verify successful");
					} else if (value == "14000000") { // REG_VERIFY_FAIL
						addLog("Registration verify failed!");
						setStatus("Registration verify failed!");
					} else if (value == "21000000") { // LOG_SUCCESS
						is_logged_in = true;
						addLog("Login successful");
						setStatus("Login successful");
						menuUpgrade();
					} else if (value == "22000000") { // LOG_INVALID_LTMK
						addLog("Login invalid LMTK!");
						setStatus("Login invalid LMTK!");
					} else if (value == "23000000") { // LOG_FAILED
						addLog("Login Failed!");
						setStatus("Login Failed!");
					} else	if (value == "e0000000") { // ERR_NOT_REGISTERED
						addLog("Not registered!");
						setStatus("Not registered!");
					} else	if (value == "e1000000") { // ERR_REGISTERED
						addLog("Error Registered!");
						setStatus("Error Registered!");
					} else	if (value == "e2000000") { // ERR_REPEAT_LOGIN
						is_logged_in = true;
						addLog("Repeat login!");
						setStatus("Repeat login!");
						menuUpgrade();
					} else	if (value == "e3000000") { // ERR_INVALID_OOB
						addLog("Error: Invalid OOB!");
						setStatus("Invalid OOB!");
					}
				});
			}).then(characteristic => {
				return enc_19.startNotifications().then(() => {
					enc_19.addEventListener('characteristicvaluechanged', event => {
						var value = bytesToHex(event.target.value.buffer);
						addClog("Enc_19: " + value);
						if (value.substring(0, 6) == "000004") {
							if (value.substring(6, 8) == "00") {
								mainCharSend("00000500" + value.substring(8), enc_19).then(function(character) {
								}).catch(function(err) {updateFail(err);});
							} else if (value.substring(6, 8) == "01") {
								mainCharSend("00000501" + value.substring(8), enc_19).then(function(character) {
									setTimeout(sendLogin, 250);
								}).catch(function(err) {updateFail(err);});
							}
						} else if (mode_activation == 1) {
							if (value.substring(0, 16) == "0000020001000000") {
								device_new_id = value.substring(16);
								$("known_id").value = hex2ascii(device_new_id.substring(2));
								mainCharSend("00000100", enc_19).then(function(character) {
									setTimeout(startRegister, 250);
								}).catch(function(err) { updateFail(err); });
							} else if (value == "000000000100") {
								is_activated = false;
								mainCharSend("00000101", enc_19);
							} else if (value == "000000000200") {
								is_activated = true;
								mainCharSend("00000101", enc_19);
							} else if ((is_activated == true) && (state == 0) && value.substring(0, 4) == "0100") {
								device_known_id = value.substring(4);
							} else if ((is_activated == true) && (state == 0) && value.substring(0, 4) == "0200") {
								device_known_id += value.substring(4);
								device_new_id = device_known_id.substring(8);
								$("known_id").value = hex2ascii(device_known_id.substring(10));
								mainCharSend("00000100", enc_19).then(function(character) {
									setTimeout(startRegister, 250);
								}).catch(function(err) { updateFail(err); });
							} else if (value == "010001000000") {
								mainCharSend("00000100", enc_19).then(function(character) {
									setTimeout(startRegister, 250);
								}).catch(function(err) { updateFail(err); });
							} else if ((state == 1) && (value == "00000101")) {
								state = 2;
								mainCharSend("0100" + own_public_key.substring((36 * 0) + 2, (36 * 0) + 36 + 2), enc_19).then(function(character) {
									mainCharSend("0200" + own_public_key.substring((36 * 1) + 2, (36 * 1) + 36 + 2), enc_19).then(function(character) {
										mainCharSend("0300" + own_public_key.substring((36 * 2) + 2, (36 * 2) + 36 + 2), enc_19).then(function(character) {
											mainCharSend("0400" + own_public_key.substring((36 * 3) + 2, (36 * 3) + 36 + 2), enc_19);
										}).catch(function(err) { updateFail(err); });
									}).catch(function(err) { updateFail(err); });
								}).catch(function(err) { updateFail(err); });
							} else if (value == "000000030400")
								mainCharSend("00000101", enc_19);
							else if ((state == 2) && value.substring(0, 4) == "0100") {
								device_public_key = "04" + value.substring(4);
							} else if ((state == 2) && value.substring(0, 4) == "0200") {
								device_public_key += value.substring(4);
							} else if ((state == 2) && value.substring(0, 4) == "0300") {
								device_public_key += value.substring(4);
							} else if ((state == 2) && value.substring(0, 4) == "0400") {
								device_public_key += value.substring(4);
								mainCharSend("00000100", enc_19).then(function(character) {
									makeSharedKey();
								}).catch(function(err) { updateFail(err); });
							} else if ((state == 2) && (value == "00000101")) {
								state = 3;
								mainCharSend("0100" + mi_write_did.substring(36 * 0, (36 * 0) + 36), enc_19).then(function(character) {
									mainCharSend("0200" + mi_write_did.substring(36 * 1, (36 * 1) + 36), enc_19);
								}).catch(function(err) { updateFail(err); });
							} else if ((state == 3) && (value == "00000100")) {
								state = 0;
								mainCharSend("13000000", enc_10); // REG_VERIFY_SUCC ?
							} else if (value == "000001050100") {
								addLog("Received Timeout from device");
							} else if (value == "12000000") {
								addLog("Register Failed!");
							} else if (value == "11000000") {
								addLog("Register successful");
							}
						} else { //Mode Login
							if ((state == 0) && (value == "00000101")) {
								state = 1;
								mainCharSend("0100" + mi_random_key, enc_19);
							} else if ((state == 1) && (value == "0000000d0100")) {
								state = 2;
								mainCharSend("00000101", enc_19);
							} else if ((state == 1) && (value.substring(0, 8) == "0000020d")) {
								state = 12;
								mi_random_key_recv = value.substring(8);
								do_login_generate();
								mainCharSend("00000300", enc_19);
							} else if ((state == 2) && value.substring(0, 4) == "0100") {
								state = 3;
								mi_random_key_recv = value.substring(4);
								do_login_generate();
								mainCharSend("00000100", enc_19);
							} else if ((state == 3) && (value == "0000000c0200")) {
								state = 4;
								mainCharSend("00000101", enc_19);
							} else if ((state == 12) && (value.substring(0, 8) == "0000020c")) {
								state = 13;
								mi_device_info_recv = value.substring(8);
								mainCharSend("00000300", enc_19).then(function(character) {
									if (expected_device_infos == mi_device_info_recv) {
										addLog("Received device infos are correct");
										mainCharSend("0000000a0100", enc_19);
									} else {
										addLog("Received device infos are not correct");
										state = 0;
										mainCharSend("00000100", enc_19);
									}
								}).catch(function(err) {updateFail(err);});
							} else if ((state == 4) && value.substring(0, 4) == "0100") {
								state = 5;
								mi_device_info_recv = value.substring(4);
							} else if ((state == 5) && value.substring(0, 4) == "0200") {
								state = 6;
								mi_device_info_recv += value.substring(4);
								if (expected_device_infos == mi_device_info_recv)
									addLog("Received device infos are correct");
								else
									addLog("Received device infos are not correct");
								mainCharSend("00000100", enc_19).then(function(character) {
									mainCharSend("0000000a0200", enc_19);
								})
							} else if ((state == 6) && (value == "00000101")) {
								state = 7;
								mainCharSend("0100" + mi_device_info_send.substring(36 * 0, (36 * 0) + 36), enc_19).then(function(character) {
									mainCharSend("0200" + mi_device_info_send.substring(36 * 1, (36 * 1) + 36), enc_19);
								}).catch(function(err) { updateFail(err); });
							} else if ((state == 13) && (value == "00000101")) {
								state = 14;
								mainCharSend("0100" + mi_device_info_send, enc_19);
							} else if ((state == 14) && (value == "00000100")) {
								state = 0;
								addClog("Waiting for terminating code ...");
							}
						}
					});
					addLog("Connected");
					if(bluetoothDevice.name == 'LYWSD03MMC') {
						let shwsr = devinfo.hrstr.substr(0,4);
						if(shwsr == 'B1.4' || shwsr == '0000') cfg.hver = 0x80; // sensor SHTC3
						else if(shwsr == 'B1.5') cfg.hver = 10;
						else if(shwsr == 'B1.6') cfg.hver = 3;
						else if(shwsr == 'B1.9') cfg.hver = 4;
						else if(shwsr == 'B1.7' || shwsr == 'B2.0') cfg.hver = 5;
						//else if(shwsr == 'B1.8') cfg.hver = 0; // ??
						else {
							cfg.hver = 0;
							// $("ldfile").hidden = false;
						}
					} else if (bluetoothDevice.name.substr(0,8) == 'MHO-C401') {
						let swnum = parseInt(devinfo.srstr.substr(0,4));
						if(swnum > 14) {
							addLog("Found new version of SW:"+swnum+" MHO-C401N");
							cfg.hver = 8;
						} else {
							addLog("Found old version of SW:"+swnum+" MHO-C401");
							cfg.hver = 1;
						}
					} else if (bluetoothDevice.name.substr(0,4) == 'C121') cfg.hver = 11; // MHO-C122
					else if (bluetoothDevice.name.substr(0,20) == "Qingping Temp & RH M") cfg.hver = 2;
					else if (bluetoothDevice.name.substr(0,18) == "Qingping Temp RH M") cfg.hver = 7;
					else if (bluetoothDevice.name.substr(0,21) == "Qingping Temp RH Lite") cfg.hver = 6;
					else if (bluetoothDevice.name == "MJWSD05MMC") cfg.hver = 9;
					else {
						cfg.hver = null;
						$("ldfile").hidden = false;
					}
					if(cfg.hver != null)
						hwver_id = cfg.hver & 0x0f;
					let s="'"+bluetoothDevice.name;
					if (devinfo.hrstr) s+=" HW:"+devinfo.hrstr;
					s+="' connected, you can now Do the Activation to either get the Token or flash a new Firmware";
					setStatus(s);
				});
			});
		}).catch(handleError);
}
function startRegister() {
	mainCharSend("15000000", enc_10).then(function(character) {
		mode_activation = 1;
		state = 1;
		doGenerate();
		mainCharSend("000000030400", enc_19);
	}).catch(function(err) { updateFail(err);});
}
function sendRegister() {
	if (miConnected == false) {
		addLog("Not connected");
		return;
	}
	addLog("Activating now, please wait...");
	state = 0;
	mode_activation = 1;
	doGenerate();
	mainCharSend("a2000000", enc_10);
}
function sendLogin() {
	addLog("Send Login, please wait...");
	mi_random_key = bytesToHex(window.crypto.getRandomValues(new Uint8Array(16)));
	state = 0;
	mode_activation = 0;
	mainCharSend("24000000", enc_10).then(function(character) {
		mainCharSend("0000000b0100", enc_19);
	}).catch(function(err) {updateFail(err);});
}

function getStrVersion(infoservice, suuid) {
 return new Promise((resolve, reject) => {
	infoservice.getCharacteristic(suuid).then(characteristic => {
		characteristic.readValue().then(value => {
			return resolve(new TextDecoder("utf-8").decode(value));
		}).catch(error => {addClog(error);	return resolve(null); });
	}).catch(error => {addClog(error);	return resolve(null); });
})};

var infoservice;
function getDevVersion(devInfEnabled) {
	return new Promise((resolve, reject) => {
	devinfo.hrstr = null;
	devinfo.srstr = null;
	devinfo.frstr = null;
	devinfo.flg = 0;
	if (devInfEnabled == true) {
		gattServer.getPrimaryService(0x180a).then(service => {
			addClog("Found Device Information Service");
			infoservice = service;
			return getStrVersion(infoservice, 0x2a26).then(value => {
				devinfo.flg |= 1;
				devinfo.frstr = value;
				return getStrVersion(infoservice, 0x2a27).then(value => {
					devinfo.flg |= 2;
					devinfo.hrstr = value;
					return getStrVersion(infoservice, 0x2a28).then(value => {
						devinfo.flg |= 4;
						devinfo.srstr = value;
						return resolve(devinfo.flg);
					}).catch(error => { addClog(error); return resolve(null);});
				}).catch(error => { addClog(error); return resolve(null);});
			}).catch(error => { addClog(error); return resolve(null);});
		}).catch(error => { addClog(error); return resolve(null);});
	} else	return resolve(null);
	}).catch(error => { addClog(error); return resolve(null);});
}

function doConnect() {
 if(bluetoothDevice != null) {
	bluetoothDevice.gatt.connect().then(server => {
		addClog("Found GATT server");
		gattServer = server;
		return gattServer.getPrimaryServices().then(services => {
		miEnabled = false;
		otaEnabled = false;
		customEnabled = false;
		devIdEnabled = false;
		devTest = false;
		devInfEnabled = false;
		EnabledQinping = false;
		phy62x2bthome = false;
		for (var i = 0; i < services.length; i++) {
			addClog("Services: " + services[i].uuid);
			if (services[i].uuid == "00010203-0405-0607-0809-0a0b0c0d1912") otaEnabled = true;
			else if (services[i].uuid == "00001f10-0000-1000-8000-00805f9b34fb") customEnabled = true;
			else if (services[i].uuid == "22210000-554a-4546-5542-46534450464d") EnabledQinping = true;
			else if (services[i].uuid == "ebe0ccb0-7a0a-4b0c-8a1a-6ff2997da3a6") miEnabled = true;
			else if (services[i].uuid == "0000181a-0000-1000-8000-00805f9b34fb") devIdEnabled = true;
			else if (services[i].uuid == "0000ffe0-0000-1000-8000-00805f9b34fb") devTest = true;
			else if (services[i].uuid == "0000fcd2-0000-1000-8000-00805f9b34fb") phy62x2bthome = true;
			else if (services[i].uuid == "0000180a-0000-1000-8000-00805f9b34fb") devInfEnabled = true; // Device Information Service
		}
		if(otaEnabled)
			return gattServer.getPrimaryService('00010203-0405-0607-0809-0a0b0c0d1912');
		else {
			addAlog("Not found Telink OTA service!");
			if(phy62x2bthome) {
				addAlog('<a href="https://pvvx.github.io/THB2/web/PHY62x2BTHome.html" target="_blank">PHY62x2BTHome</a>');
			}
		}
		connectTrys = 1000;
		return resolve(null);
	}).then(service => {
		addClog("Found Telink OTA service");
		Theservice = service;
		return Theservice.getCharacteristic('00010203-0405-0607-0809-0a0b0c0d2b12');
	}).then(characteristic => {
		addClog("Found Telink OTA write characteristic");
		writeCharacteristic = characteristic;

	    getDevVersion(devInfEnabled).then(_ => {
		if (devinfo.hrstr) addLog('Hardware Revision String: ' + devinfo.hrstr);
		if (devinfo.srstr) addLog('Software Revision String: ' + devinfo.srstr);
		if (devinfo.frstr) addLog('Firmware Revision String: ' + devinfo.frstr);
		if (miEnabled) {
			addLog("Detected Mi device");
			setStatus("Detected Mi device");
			$("custcfg").innerHTML = '<hr>When doing an activation here the device is needed to be activated in the Mi app again when wanted to use there.<br><button type="button" onclick="sendRegister();">Do Activation</button> <button type="button" onclick="keyMiLogin();">Login</button><br>Device known id:<br><input size="40" type="text" id="known_id" value=""><br>Mi Token:<br><input size="40" type="text" id="mi_token" value=""><br>Mi Bind Key:<br><input size="40" type="text" id="mi_bind_key" value=""><br><br>';
			if (bluetoothDevice.name.substr(0,10) == "MJWSD05MMC") fwmaxsize = 0x34000;
			if ((bluetoothDevice.name.substr(0,10) == "LYWSD03MMC") && (devinfo.frstr.substr(0,2) == "2.")) {
			    s = "(!) Version: "+devinfo.frstr+" is temporarily not supported (!)";
				addLog(s);
				connectTrys = 1000;
				disconnect();
			} else
				miAction();
		} else if (customEnabled) {
			let s = '<button type="button" onclick="sendCustomSetting(&quot;55&quot;);">Get Config</button><br>Send commands to custom firmware:<br><input type="text" id="cmdTXT" value=""><button type="button" onclick="sendCustomSetting($(&quot;cmdTXT&quot;).value,settingsCharacteristics);">Send</button><br>';
			if (devTest) {
				addLog("Detected Test device");
				setStatus("Detected Test device");
				getTestCharacteristic();
				s += '<a href="https://pvvx.github.io/ATC_MiThermometer/TelinkOTA.html" target="_blank">TelinkOTA</a><br>';
			} else {
				addLog("Detected custom Firmware");
				setStatus("Detected custom Firmware");
				customAction();
			}
			$("custcfg").innerHTML = s;
		} else if(EnabledQinping){
			if(bluetoothDevice.name.substr(0,15) == "Qingping Motion")
				CGPR1_Action();
			else if(bluetoothDevice.name.substr(0,21) == "Qingping Temp RH Lite")
				CGDK2_Action();
			else if(bluetoothDevice.name.substr(0,20) == "Qingping Temp & RH M")
				CGG1_Action("2020-2021");
			else if(bluetoothDevice.name.substr(0,18) == "Qingping Temp RH M")
				CGG1_Action("2022");
		    else
				addLog("Unknown Qingping Firmware");
				setStatus("Unknown Qingping Firmware");
		} else {
			setStatus("Connected.")
//			$("custcfg").innerHTML = '<b>Unknown firmware:</b> Use <a href="https://pvvx.github.io/ATC_MiThermometer/TelinkOTA.html">SDK TelinkOTA</a>';
			miEnabled = true;
			miAuthorization();	//	miConnected
			$("ldfile").hidden = false;
			$("custcfg").innerHTML = '<hr>When doing an activation here the device is needed to be activated in the Mi app again when wanted to use there.<br><button type="button" onclick="sendRegister();">Do Activation</button> <button type="button" onclick="skipActivation();">Skip Activation</button>	 <button type="button" onclick="keyMiLogin();">Login</button><br>Device known id:<br><input size="40" type="text" id="known_id" value=""><br>Mi Token:<br><input size="40" type="text" id="mi_token" value=""><br>Mi Bind Key:<br><input size="40" type="text" id="mi_bind_key" value=""><br><br>';
		}}).catch(handleError);
	}).catch(error => {addLog(error); });
	}).catch(handleError);
 }
}

function reConnect() {
	if (bluetoothDevice != null) bluetoothDevice.gatt.disconnect();
	resetVariables();
	addLog("Reconnect");
	connectTrys = 0;
	doConnect();
}

function skipActivation() {
	if(cus017Chr && EnabledQinping)
		$("custcfg").innerHTML = '<hr><button type="button" onclick="sendCmdClear();">Clear all settings and reset device (into Qingping mode)</button><br><br>MTimer: <input type="text" id="mtimer" value="?"> ms <button type="button" onclick="getMTimer();">Get</button> <button type="button" onclick="setMTimer();">Set</button><br>';
	else
		$("custcfg").innerHTML = '';
	is_logged_in = true;
}

function startDFU() {
	addLog("Start DFU");
	if ((miConnected==true) && (is_logged_in==false)){
		addLog("Please do the Activation first!");
		return;
	}
	if (fzigbeeota.used || blockCount*16 > fwmaxsize){
		if(bigOtaEnabled && settingsCharacteristics){
			let szk = (blockCount*16+1023) >> 10;
			if(!confirm('All data for MiHome and measurement memory will be erased?')) return;
			let s = 'Clear Ext.OTA region ('+szk+'kib)...';
			addAlog(s);
			setStatus(s)
			settingsCharacteristics.writeValue(new Uint8Array([0x73, 0,0,4,0, szk&0xff, (szk>>8)&0xff, (szk>>16)&0xff, (szk>>24)&0xff]));
			return;
		} else {
			let szk = fwmaxsize >> 10;
			let s = 'OTA (size over '+szk+'k) is not supported! Use custom firmware version 4.6 or higher.';
			setStatus(s);
			addAlog(s);
			return;
		}
	}
	updateBegin();
}

function addLog(logTXT) {
	var time = new Date().toLocaleTimeString();
	var logString = time + ": " + logTXT;
	$("log").innerHTML += logString + "<br>";
}

function addClog(logTXT) {
	console.log(logTXT);
}

function addAlog(logTXT) {
	console.log(logTXT);
	addLog(logTXT);
}

function clearLog() {
	$("log").innerHTML = "";
}

function setStatus(status) {
	addClog("Status: " + status);
	$("percent").innerHTML = "Status: " + status;
}

function updateFail(err) {
	addLog("Update error: " + err);
	setStatus("Update error: " + err);
}

function decimalToHex(d, padding) {
	var hex = Number(d).toString(16);
	while (hex.length < 4) {
		hex = "0" + hex;
	}
	return hex;
}

function hexToBytes(hex) {
	for (var bytes = [], c = 0; c < hex.length; c += 2)
		bytes.push(parseInt(hex.substr(c, 2), 16));
	return new Uint8Array(bytes);
}

function bytesToHex(data) {
	return new Uint8Array(data).reduce(function(memo, i) {
		return memo + ("0" + i.toString(16)).slice(-2);
	}, "");
}

function makeRandomID(length) {
	var result = '';
	var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
	var charactersLength = characters.length;
	for (var i = 0; i < length; i++) {
		result += characters.charAt(Math.floor(Math.random() * charactersLength));
	}
	return bytesToHex(new TextEncoder("utf-8").encode(result));
}

function crc16_modbus(buffer) {
	var crc = 0xFFFF;
	var odd;
	for (var i = 0; i < buffer.length; i++) {
		crc = crc ^ buffer[i];
		for (var j = 0; j < 8; j++) {
			odd = crc & 0x0001;
			crc = crc >> 1;
			if (odd) {
				crc = crc ^ 0xA001;
			}
		}
	}
	return crc;
};
//-------------
function hex2ascii(hexx) {
	var hex = hexx.toString();
	var str = '';
	for (var i = 0;
		(i < hex.length && hex.substr(i, 2) !== '00'); i += 2)
		str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
	return str;
}
var crc32 = (function() {
	let table = new Uint32Array(256);
	for(var i=256; i--;) {
		let tmp = i;
		for(let k=8; k--;) {
			tmp = tmp & 1 ? 0xEDB88320 ^ tmp >>> 1 : tmp >>> 1;
		}
		table[i] = tmp;
	}
	return function( data ) {
		let crc = -1;
		let l = data.length;
		for(let i=0; i<l; i++) {
			crc = crc >>> 8 ^ table[ crc & 255 ^ data[i] ];
		}
		return (crc >>> 0);
	};
})();

function testOTAFirmware(data) {
	let fsize = data.byteLength;
	addClog("File size = 0x"+ fsize.toString(16));
	if (fsize < 2048)
		return "Wrong binary Telink OTA firmware size!";
	if(bigOtaEnabled) {
		if(fsize > 208*1024) // 208kB for BLE
			return "Size firmware is more 208 kbytes!";
	} else if(fsize > fwmaxsize)
			return "Size firmware is more "+fwmaxsize+" bytes!";
	let head = new DataView(data, 0, 0x40);
	if(head.getUint32(0, true) == 0x0beef11e) { // Zigbee OTA
		if(head.getUint16(4, true) != 0x100	|| head.getUint16(6, true) != 56)
			return "Unknown Zigbee OTA header!";
		fzigbeeota.size = head.getUint32(0x3A, true);
		if(fzigbeeota.size < 2048 || fzigbeeota.size + 0x3e > fsize)
			return "Wrong binary Zigbee OTA firmware size!";
		fzigbeeota.man_code = head.getUint16(0x0a, true);
		fzigbeeota.image_type = head.getUint16(0x0c, true);
		fzigbeeota.fwversion = head.getUint32(0x0e, true);
		fzigbeeota.ota_version = head.getUint8(0x12);
		fzigbeeota.used = true;
		fsize = fzigbeeota.size;
		addAlog("Zigbee OTA Info: ManCode: "+hex(fzigbeeota.man_code, 4)+ ", ImageType: " + hex(fzigbeeota.image_type,4) + ", FwVer: " + hex(fzigbeeota.fwversion, 8));
		addAlog("APP Release: " + ((fzigbeeota.fwversion >> 28)&0x0f) + "." + ((fzigbeeota.fwversion >> 24)&0x0f)
		+ " Build: " + ((fzigbeeota.fwversion >> 20)&0x0f) + "." + ((fzigbeeota.fwversion >> 16)&0x0f)
		+ ", Stack Version: " + ((fzigbeeota.fwversion >> 12)&0x0f) + "." + ((fzigbeeota.fwversion >> 8)&0x0f)
		+ " Release: " + ((fzigbeeota.fwversion >> 4)&0x0f) + "." + (fzigbeeota.fwversion&0x0f));
		if(!bigOtaEnabled) {
			if(fzigbeeota.image_type == 0x0203)
				return "The current firmware version does not support EXT OTA for image type `"+hex(fzigbeeota.image_type, 4)+"`. Update the new custom BLE version (4.6 or higher)!";
			if(fsize > fwmaxsize)
				return "The current firmware version does not support EXT OTA. Update the new custom BLE version (4.6 or higher)!";
		}
		data = data.slice(0x3e);
	 	head = new DataView(data, 0, 0x20);
	} else
		fzigbeeota.used = false;
	if(head.getUint32(0x08, true) != 0x544c4e4b){
		return "Incorrect head in Telink OTA binary firmware";
	}
	let hsize = head.getUint32(0x18, true);
	addClog("Size in head = 0x" + hsize.toString(16));
	if((hsize > fsize) || ((hsize & 0x0f) != 4)) {
		return "Invalid size pointer in Telink OTA binary firmware!";
	}
	let fcrc = new Uint32Array(2);
	fcrc[0] = crc32(new Uint8Array(data.slice(0, hsize - 4)));
	let x = new DataView(data, hsize - 4, 4);
	fcrc[1] = x.getUint32(0, true);
	addClog("File CRC = 0x" + fcrc[1].toString(16) + ", Check CRC = 0x" + fcrc[0].toString(16));
	if(fcrc[0] != fcrc[1]) {
		return "Incorrect CRC in Telink OTA binary firmware!";
	}
	return "ok";
}
//-------------
function getFirmwareArray(data, filename) {
	addAlog("File: " + filename);
	addClog("File: " + filename);
	let s = testOTAFirmware(data);
	if(s != "ok") {
		addAlog(s);
		blockCount = 0;
		firmwareArray = "";
		fwname = "";
		$("ldfrmw").innerHTML=s;
		alert(s);
		return;
	}
	if(fzigbeeota.used)
		firmwareArray = bytesToHex(data.slice(0x3E, fzigbeeota.size+0x3E));
	else
		firmwareArray = bytesToHex(data);
	addAlog("File size: " + (firmwareArray.length/2).toString(10) + " bytes");
	if (firmwareArray.length % 32 !== 0) { // pad last block to 16bytes
		var padHex = "ffffffffffffffffffffffffffffffff";
		firmwareArray += padHex.substr(0, 32 - firmwareArray.length % 32);
	}
	blockCount = firmwareArray.length / 32;
	addAlog("Count: " + blockCount);
	fwname = filename;
	menuUpgrade();
}

function ajax_file(filename, fn, rawurl = "https://raw.githubusercontent.com/pvvx/ATC_MiThermometer/master/") {
	let xhr;
	if(window.XMLHttpRequest) xhr = new XMLHttpRequest();
	else if(window.ActiveXObject) xhr = new ActiveXObject("Microsoft.XMLHTTP")
	if (!xhr) { addClog(msg("Your browser does not support AJAX!")); fn(); return;};
	xhr.onreadystatechange = function() {
		if (xhr.readyState == 4) {
			if (xhr.status == 200) fn(xhr.response, filename);
			else { addClog('XMLHttpRequest: response ' + xhr.status); fn();}
			xhr.abort();
			xhr = null;
		}
	};
	xhr.ontimeout = function() { addClog('XMLHttpRequest: timeout'); fn();};
	xhr.onerror = function () { addClog('XMLHttpRequest error!'); fn();};
	xhr.open('GET', rawurl+filename, true);
	xhr.timeout = 10000;
	xhr.responseType = "arraybuffer";
	xhr.send();
}

function getZOtaJson(d, name) {
	if (!d) {
		addClog("No load index file!");
	} else {
		let str = '';
		if (typeof d === 'string')
			str = d;
		else
			str = new TextDecoder("utf-8").decode(d);
		let x = JSON.parse(str);
		if(x.version) {
			otazfiles = x;
			otazfiles.loaded = true;
			addClog(otazfiles);
		}
	}
}

function getOtaJson(d, name) {
	if (!d) {
		addClog("No load index file!");
	} else {
		let str = '';
		if (typeof d === 'string')
			str = d;
		else
			str = new TextDecoder("utf-8").decode(d);
		let x = JSON.parse(str);
		if(x.version) {
			otafiles = x;
			otafiles.loaded = true;
			addClog(otafiles);
			if(otafiles.zbjson != null && otafiles.zbjson.slice(0,6) == "https:") {
				ajax_file(otafiles.zbjson, getZOtaJson, "" );
			}
		}
	}
}

function FirmwareZdevbis() {
		if(!confirm("Attention: Zigbee firmware converts the thermometer to the Zigbee protocol! All data for MiHome and measurement memory will be erased! The devbis version consumes twice as much as ZigbeeTlc!"))
		   return;
		let fn = "https://raw.githubusercontent.com/pvvx/ZigbeeTLc/master/bin/devbis/db15-0203-11003001-z03mmc.zigbee";
		addAlog("Load firmware file '"+fn+"'...");
		ajax_file(fn, getFirmwareArray, "");
}

function FirmwareZigbee() {
	if(hwver_id != null) {
		if(!confirm("Attention: This firmware is a Beta version for testing! Zigbee firmware converts the thermometer to the Zigbee protocol! All data for MiHome and measurement memory will be erased!"))
		   return;
		let fn = otazfiles.bin[hwver_id];
		addAlog("Load firmware file '"+fn+"'...");
		if(fn.slice(0,6) == "https:")
			ajax_file(fn, getFirmwareArray, "");
		else
			ajax_file(fn, getFirmwareArray);
	}
}
function FirmwareUpgrade() {
	if(hwver_id != null) {
		let fn = otafiles.custom[hwver_id];
		addAlog("Load firmware file '"+fn+"'...");
		if(fn.slice(0,6) == "https:")
			ajax_file(fn, getFirmwareArray, "");
		else
			ajax_file(fn, getFirmwareArray);
	}
}
function BetaFirmwareUpgrade() {
	if(hwver_id != null) {
		let fn = otafiles.betafw[hwver_id];
		addAlog("Load firmware file '"+fn+"'...");
		if(fn.slice(0,6) == "https:")
			ajax_file(fn, getFirmwareArray, "");
		else
			ajax_file(fn, getFirmwareArray);
	}
}
function BackToOriginal() {
	if(hwver_id != null) {
		let fn = otafiles.original[hwver_id];
		addAlog("Load firmware file '"+fn+"'...");
		ajax_file(fn, getFirmwareArray);
	}
}

window.onload = function() {
	//TODO Test enable -web-platform-features
	$("MAC").innerHTML= '#enable-experimental-web-platform-features may be needed to read MAC (copy link: <a href=chrome://flags/#enable-experimental-web-platform-features>Chrome<a>, <a href=opera://flags/#enable-experimental-web-platform-features>Opera<a>, <a href=edge://flags/#enable-experimental-web-platform-features>Edge<a>)';
	addClog("Load index file 'firmware.json'...");
	ajax_file('firmware.json', getOtaJson);
	document.querySelector("#file").addEventListener("change", function() {
		let reader = new FileReader();
		reader.fname = "";
		reader.onload = function() {getFirmwareArray(this.result, this.fname);};
		if (this.files[0] != null) {
			reader.fname = this.files[0].name;
			reader.readAsArrayBuffer(this.files[0]);
		} else	addLog("No file selected");	}, false);
}

function updateBegin() {
	if (blockCount <= 0) {
		addLog("No file selected aborting");
		return;
	} else if (blockCount*16 > fwmaxsize) {
		alert('EXT OTA is not supported! Update the new custom version (4.6 or higher)!');
		return;
	}
	// if Host is IOS = "1e0001"
	if (miEnabled && writeCharacteristicSpeed != null) mainCharSend("1e0000", writeCharacteristicSpeed); // this makes the upload faster
	setTimeout(function() {
		otaCharSend("00ff").then(function(character) {
			otaCharSend("01ff").then(function(character) {
				setTimeout(function() {
					startTime = new Date().getTime();
					sendOTAblock(0);
				}, 300);
			}).catch(function(err) {
				updateFail(err);
			});
		}).catch(function(err) {
			updateFail(err);
		});
	}, 500);
}

function sendOTAblock(blockNr) {
	if (blockNr >= blockCount) {
		sendLastOTA();
		return;
	}
	setStatus("Sending block nr: " + blockNr + " from " + blockCount + ", " + Math.floor(blockNr / (blockCount * 1.0) * 100) + "% done, time since start " + (new Date().getTime() - startTime) / 1000.0 + "s");
	var blockNrString = getHexBLockCount(blockNr);
	var blockString = blockNrString + firmwareArray.substring(blockNr * 32, blockNr * 32 + 32);
	var blockCRC = getHexCRC(blockString);
	otaCharSend(blockString + blockCRC).then(function(character) {
		setTimeout(function() {
			if ((blockNr + 1) % 8 == 0) {
				writeCharacteristic.readValue().then(function(result) {
					addClog('reading OTA');
					sendOTAblock(blockNr + 1);
				}).catch(function(err) {
					updateFail(err);
				});
			} else {
				sendOTAblock(blockNr + 1);
			}
		}, 0);
	}).catch(function(err) {
		updateFail(err);
	});
}

function getHexBLockCount(count) {
	var tempHEX = decimalToHex(count);
	return tempHEX.substring(2, 4) + tempHEX.substring(0, 2);
}

function getHexCRC(data) {
	var tempCRC = decimalToHex(crc16_modbus(hexToBytes(data)));
	return tempCRC.substring(2, 4) + tempCRC.substring(0, 2);
}

function sendLastOTA() {
	var data = "02ff" + getHexBLockCount(blockCount - 1) + getHexBLockCount(~(blockCount - 1) & 0xffff);
	otaCharSend(data).then(function(character) {
		addLog("Update done after " + (new Date().getTime() - startTime) / 1000 + " seconds");
		setStatus("Update done after " + (new Date().getTime() - startTime) / 1000 + " seconds");
	}).catch(function(err) {
		updateFail(err);
	});
}

var otaCharSend = function(data) {
	return new Promise(function(resolve, reject) {
		addClog("OTA: " + data);
		writeCharacteristic.writeValue(hexToBytes(data)).then(function(character) {
			resolve("ok");
		}).catch(function(err) {
			reject("some error while sending char data");
		});
	});
}

function sendCustomSetting(data){
	if((hexToBytes(data))[0] == 0x35)
		flg_memo_act = true;
	mainCharSend(data, settingsCharacteristics).then(function() {
		addLog("Settings " + data + " was sent successfully");
	}).catch(function(err) {
		addLog("Error on sending setting " + data);
	});
}

var mainCharSend = function(data, characteristic) {
	return new Promise(function(resolve, reject) {
		addClog("Send: " + data);
		characteristic.writeValue(hexToBytes(data)).then(function(character) {
			resolve("ok");
		}).catch(function(err) {
			reject("some error while sending char data");
		});
	});
}

function doGenerate() {
	window.crypto.subtle.generateKey({
			name: 'ECDH',
			namedCurve: 'P-256'
		}, false, ['deriveKey', 'deriveBits'])
		.then(own_key => {
			keypair = own_key
			return window.crypto.subtle.exportKey('raw', own_key.publicKey);
		})
		.then(ownPublicKeyExported => {
			own_public_key = bytesToHex(ownPublicKeyExported);
		})
		.catch(err => {
			addLog(err);
		});
}
function makeSharedKey() {
	window.crypto.subtle.importKey('raw', hexToBytes(device_public_key), {
			name: 'ECDH',
			namedCurve: 'P-256'
		}, true, [])
		.then(device_key_imported => {
			return window.crypto.subtle.deriveBits({
				name: 'ECDH',
				namedCurve: 'P-256',
				public: device_key_imported
			}, keypair.privateKey, 256)
		})
		.then(sharedSecret => {
			shared_key = bytesToHex(sharedSecret);
			deriveTheKey();
		})
		.catch(err => {
			addLog(err)
		})
}
function deriveTheKey() {
	var derived_key = sjcl.codec.hex.fromBits(sjcl.misc.hkdf(sjcl.codec.hex.toBits(shared_key), 8 * 64, null, "mible-setup-info", sjcl.hash["sha256"]));
	$("mi_token").value = derived_key.substring(0, 24);
	$("mi_bind_key").value = derived_key.substring(24, 56);
	var mi_bind_A = derived_key.substring(56, 88);
	mi_write_did = sjcl.codec.hex.fromBits(sjcl.mode.ccm.encrypt(new sjcl.cipher.aes(sjcl.codec.hex.toBits(mi_bind_A)), sjcl.codec.hex.toBits(device_new_id), sjcl.codec.hex.toBits("101112131415161718191A1B"), sjcl.codec.hex.toBits("6465764944"), 32));
	mainCharSend("000000000200", enc_19);
}
function do_login_generate() {
	var salt = hexToBytes(mi_random_key + mi_random_key_recv);
	var salt1 = hexToBytes(mi_random_key_recv + mi_random_key);
	var derived_key = sjcl.codec.hex.fromBits(sjcl.misc.hkdf(sjcl.codec.hex.toBits($("mi_token").value), 8 * 64, sjcl.codec.hex.toBits(bytesToHex(salt)), "mible-login-info", sjcl.hash["sha256"]));
	expected_device_infos = sjcl.codec.hex.fromBits(new sjcl.misc.hmac(sjcl.codec.hex.toBits(derived_key.substring(0, 32))).mac(sjcl.codec.hex.toBits(bytesToHex(salt1))));
	mi_device_info_send = sjcl.codec.hex.fromBits(new sjcl.misc.hmac(sjcl.codec.hex.toBits(derived_key.substring(32, 64))).mac(sjcl.codec.hex.toBits(bytesToHex(salt))));
}
function keyMiLogin() {
	let tk = $("mi_token").value;
	let bk = $("mi_bind_key").value;
	if(tk.length == 24) {
		if(bk.length == 32)
			sendLogin();
		else
			addLog("Bind Key must be 16 hex digits!")
	} else
		addLog("Mi Token must be 12 hex digits!")
}

const lcd_digcode = [0xf5,0x05,0xd3,0x97,0x27,0xb6,0xf6,0x15,0xf7,0xb7];
function lcd_clock() {
	let date = new Date();
	let hours = date.getHours();
	let minutes = date.getMinutes();
	let lcdb = new Uint8Array(7);
	lcdb[0] = 0x60;
	lcdb[1] = lcd_digcode[parseInt(minutes % 10)];
	lcdb[2] = lcd_digcode[parseInt(minutes / 10)];
	lcdb[4] = lcd_digcode[parseInt(hours % 10)];
	lcdb[5] = lcd_digcode[parseInt(hours / 10)];
	addClog("Send cmd (60): Set LCD data");
	settingsCharacteristics.writeValue(lcdb).then(_ => {addClog('Send data ok'); addLog("Send 'Send clock data on LCD' ok");});
}
function setDevTime() {
	let time = Date.now()/1000;
	time -= (new Date()).getTimezoneOffset() * 60;
	blk = new Uint8Array(5);
	blk[0] = 0x23;
	blk[1] = time & 0xff;
	blk[2] = (time >> 8) & 0xff;
	blk[3] = (time >> 16) & 0xff;
	blk[4] = (time >> 24) & 0xff;
	addClog("Send cmd Set DevTime ("+dump(blk, blk.length)+")...");
	settingsCharacteristics.writeValue(blk).then(_ => {
		addAlog('Send new DevTime ok');
	});
}
function calkDeltaTime() {
	devtime.step = 1;
	addClog("Send cmd Get DevTime...");
	blk = new Uint8Array(1);
	blk[0] = 0x23;
	settingsCharacteristics.writeValue(blk).then(_ => {
		addAlog('Get DevTime...');
	});
}
function lcd_restore() {
	addClog("Send cmd (6100): Restore show LCD");
	settingsCharacteristics.writeValue(new Uint8Array([0x61, 0])).then(_ => {addClog('Send data ok'); addLog("Send 'Repair LCD' ok");});
}

function sendPinCode() {
	if(pincode.enable) {
		let el = $("pincode");
		let x = parseInt(el.value);
		let s = ("0000000" + x.toString(10)).slice(-6);
		if(el.value.length == 6 && x <= 999999 && x >= 0) {
			el.value = s;
			addLog("PinCode: '"+s+"'");
			settingsCharacteristics.writeValue(new Uint8Array([0x70, x&0xff, (x>>8)&0xff, (x>>16)&0xff, (x>>24)&0xff])).then(_ => {addAlog('Send pincode ok');});
		} else	{
			el.value = s;
			addLog("Must be 6 decimal digits! 000000..999999, 6 digits, if '000000' - PinCode Disable.")
		}
	}
}
function CleanDevName() {
	addClog("Send cmd (0100) Clean DevName...");
	settingsCharacteristics.writeValue(new Uint8Array([0x01, 0])).then(_ => {
			addAlog('Send Clean DevName ok');
	});
}
function sendDevName() {
	if(dnm.enable) {
		let el = $("dev_name").value;
		if(el.length >= 1 && el.length <= 18) {
			let encoder = new TextEncoder();
			blk = new Uint8Array(el.length + 1);
			blk.set(encoder.encode(el), 1);
			blk[0] = 0x01;
			addClog("Send cmd New DevName ("+dump(blk, blk.length)+")...");
			settingsCharacteristics.writeValue(blk).then(_ => {
				addAlog('Send New DevName ok');
			});
		}
	}
}
function CleanMAC() {
	addClog("Send cmd Clean MAC (1000)...");
	settingsCharacteristics.writeValue(new Uint8Array([0x10, 0])).then(_ => {
		addAlog('Send Clean MAC ok');
	});
}
function sendMAC() {
	if(mikeys.mac) {
		let el = $("mi_mac").value;
		let len = el.length;
		addClog(len + ' ' + el);
		if(len == 12 || len == 16) {
			let mac = hexToBytes(el);
			len = mac.length;
			addClog(len + ' ' + el);
			if(len == 6 || len == 8) {
				let blk = new Uint8Array(len+2);
				blk[0] = 0x10;
				blk[1] = len;
				blk[2] = mac[5];
				blk[3] = mac[4];
				blk[4] = mac[3];
				blk[5] = mac[2];
				blk[6] = mac[1];
				blk[7] = mac[0];
				if(len == 8) {
					blk[8] = mac[7];
					blk[9] = mac[6];
				}
				addClog(blk);
				addClog("Send cmd New MAC ("+dump(blk, blk.length)+")...");
				settingsCharacteristics.writeValue(blk).then(_ => {
					s = "Send New MAC: "+dump(mac, 6);
					if(len == 8)
						s += " RAND:" +dump(mac.slice(6), 2);
					addAlog(s+" ok");
				});
			}
		}
		addLog("Must be 6 hex MAC digits [+ 2 hex RandMAC digits]!")
		return;
	}
}

function UpdExt() {
	if(ext.enable && $("extbignumb").value) {
		if(hwver_id == 9) {
			$("extbignumb").value = (ext.big_number / 100.0).toFixed(2);
			$("exttmpsmb").value = (ext.flg >> 4) & 0x07;
			$("extpersent").checked = ((ext.flg & 0x80) !=0 ? 1 : 0);
			$("extbattery").checked = ((ext.flg & 8) !=0 ? 1 : 0);
		} else {
			$("extbignumb").value = (ext.big_number / 10.0).toFixed(1);
			if(hwver_id == 2 || hwver_id == 6 || hwver_id == 7)	 // CGG1 & CGDK2
				$("extsmalnumb").value = (ext.small_number / 10.0).toFixed(1);
			else
				$("extsmalnumb").value = ext.small_number.toFixed(0);
			$("extpersent").checked = ((ext.flg & 8) !=0 ? 1 : 0);
			$("exttmpsmb").value = (ext.flg >> 5) & 0x07;
			$("extbattery").checked = ((ext.flg & 16) !=0 ? 1 : 0);
		}
		$("extsmiley").value = ext.flg & 7;
		$("extvtimed").value = ext.vtime;
	}
}

function sendExt() {
	if(ext.enable) {
		if(hwver_id == 9)  {
			ext.big_number = Math.round(100.0 * parseFloat($("extbignumb").value));
			ext.cfg = (parseInt($("extsmiley").value) & 7) +
			($("extbattery").checked ? 8 : 0) +
			($("extpersent").checked ? 0x80 : 0) +
			((parseInt($("exttmpsmb").value) & 0x07) << 4);
		} else {
			ext.big_number = Math.round(10.0 * parseFloat($("extbignumb").value));
			if(hwver_id == 2 || hwver_id == 6 || hwver_id == 7) // CGG1 & CGDK2
				ext.small_number = Math.round(10.0 * parseFloat($("extsmalnumb").value));
			else
				ext.small_number = parseInt($("extsmalnumb").value);
			ext.cfg = (parseInt($("extsmiley").value) & 7) +
			($("extpersent").checked ? 8 : 0) +
			($("extbattery").checked ? 16 : 0) +
			((parseInt($("exttmpsmb").value) & 7) << 5);
		}
		ext.vtime = parseInt($("extvtimed").value);
		if(ext.vtime < 2) ext.vtime = 2;
		else if(ext.vtime > 65535) ext.vtime = 65535;
		addClog("Send cmd (22 + ext data)...");
		let blk;
		if(hwver_id == 9){
			blk = new Uint8Array([0x22, ext.big_number&0xff, (ext.big_number>>8)&0xff, (ext.big_number>>16)&0xff, (ext.big_number>>24)&0xff, ext.vtime&0xff,(ext.vtime>>8)&0xff,ext.cfg]);
		} else{
			blk = new Uint8Array([0x22, ext.big_number&0xff, (ext.big_number>>8)&0xff,ext.small_number&0xff,(ext.small_number>>8)&0xff,ext.vtime&0xff,(ext.vtime>>8)&0xff,ext.cfg]);
		}
		settingsCharacteristics.writeValue(blk).then(_ => {
			addAlog('Send Ext data: '+dump(blk, blk.length)+' ok');
		});
	}
}
function UpdCmf() {
	if(cmf.enable && $("cmf_tmp_lo").value) {
		$("cmf_tmp_lo").value =	 (cmf.tmp_lo/100.0).toFixed(2);
		$("cmf_tmp_hi").value =	 (cmf.tmp_hi/100.0).toFixed(2);
		$("cmf_hm_lo").value =	(cmf.hm_lo/100.0).toFixed(2);
		$("cmf_hm_hi").value =	(cmf.hm_hi/100.0).toFixed(2);
	}
}
function SendCmf() {
	if(cmf.enable) {
		cmf.tmp_lo = Math.round(100.0 * parseFloat($("cmf_tmp_lo").value));
		cmf.tmp_hi = Math.round(100.0 * parseFloat($("cmf_tmp_hi").value));
		cmf.hm_lo = Math.round(100.0 * parseFloat($("cmf_hm_lo").value));
		cmf.hm_hi = Math.round(100.0 * parseFloat($("cmf_hm_hi").value));
		addClog("Send cmd (20 + cmf data)...");
		settingsCharacteristics.writeValue(new Uint8Array([0x20, cmf.tmp_lo&0xff, (cmf.tmp_lo>>8)&0xff, cmf.tmp_hi&0xff, (cmf.tmp_hi>>8)&0xff, cmf.hm_lo&0xff, (cmf.hm_lo>>8)&0xff, cmf.hm_hi&0xff, (cmf.hm_hi>>8)&0xff])).then(_ => {
			addAlog('Send Cmf data ok');
		});
	}
}
function UpdTrg() {
	if(trg.enable && $("trg_tmp_hst").value) {
		$("trg_tmp_thr").value =  trg.tmp_thr.toFixed(2);
		$("trg_hm_thr").value =	 trg.hm_thr.toFixed(2);
		$("trg_tmp_hst").value =  trg.tmp_hst.toFixed(2);
		$("trg_hm_hst").value =	 trg.hm_hst.toFixed(2);
		if(cfg.ver >= 0x37) {
			$("rds_rpint").value =	trg.rds_rpint;
			$("rds_type").value =  trg.rds_type & 3;
		}
		if(cfg.ver >= 0x39)
			$("rds_invert").checked = ((trg.rds_type & 0x10) != 0);
	}
}
function setNewTBKey() {
	let bk = $("mi_bind_key").value;
	if(bk.length == 32) {
		let bkey = hexToBytes(bk);
		if(bkey.length == 16) {
			let tk = $("mi_token").value;
			if(tk.length == 24) {
				let token = hexToBytes(tk);
				if(token.length == 12) {
					let blk = new Uint8Array(29);
					blk.set(token,1);
					blk.set(bkey,13);
					blk[0] = 0x12;
					addClog(blk);
					addClog("Send cmd MtuSizeExchange (7120)");
					settingsCharacteristics.writeValue(new Uint8Array([0x71,0x20])).then(_ => {
						addClog("Send cmd New bindkey ("+dump(blk, blk.length)+")...");
						settingsCharacteristics.writeValue(blk).then(_ => {
							addAlog("Send cmd New keys ok");
					})});
					return;
				}
			}
			addLog("Mi Token must be 12 hex digits!")
			return;
		}
	}
	addLog("Bind Key must be 16 hex digits!")
}
function sendTrg() {
	if(trg.enable) {
		let blk;
		trg.tmp_thr = Math.round(100.0 * parseFloat($("trg_tmp_thr").value));
		trg.hm_thr = Math.round(100.0 * parseFloat($("trg_hm_thr").value));
		if(cfg.ver >= 0x26) {
			trg.tmp_hst = Math.round(100.0 * parseFloat($("trg_tmp_hst").value));
			trg.hm_hst = Math.round(100.0 * parseFloat($("trg_hm_hst").value));
			addClog("Send cmd (44 + trg data)...");
			if(cfg.ver >= 0x37) {
				trg.rds_rpint = parseInt($("rds_rpint").value);
				trg.rds_type = $("rds_type").value & 3;
				if(cfg.ver >= 0x39) {
					if(trg.rds_type == 3) trg.rds_type += 0x10;
					else trg.rds_type += (($("rds_invert").checked)? 0x10 : 0);
				}
				blk = new Uint8Array([0x44, trg.tmp_thr&0xff, (trg.tmp_thr>>8)&0xff,trg.hm_thr&0xff,(trg.hm_thr>>8)&0xff,trg.tmp_hst&0xff,(trg.tmp_hst>>8)&0xff,trg.hm_hst&0xff,(trg.hm_hst>>8)&0xff,trg.rds_rpint&0xff,(trg.rds_rpint>>8)&0xff,trg.rds_type]);
			} else {
				blk = new Uint8Array([0x44, trg.tmp_thr&0xff, (trg.tmp_thr>>8)&0xff,trg.hm_thr&0xff,(trg.hm_thr>>8)&0xff,trg.tmp_hst&0xff,(trg.tmp_hst>>8)&0xff,trg.hm_hst&0xff,(trg.hm_hst>>8)&0xff]);
			}
		} else {
			trg.tmp_hst = Math.round(10.0 * parseFloat($("trg_tmp_hst").value));
			trg.hm_hst = Math.round(10.0 * parseFloat($("trg_hm_hst").value));
			addClog("Send cmd (44 + trg data)...");
			blk = new Uint8Array([0x44, trg.tmp_thr&0xff, (trg.tmp_thr>>8)&0xff,trg.hm_thr&0xff,(trg.hm_thr>>8)&0xff,trg.tmp_hst&0xff,trg.hm_hst&0xff]);
		}
		settingsCharacteristics.writeValue(blk).then(_ => {	addAlog('Send Trg data: '+dump(blk, blk.length)+' -ok');});
	}
}
function sendDeltaTime() {
	let dtim = parseInt($("cfg_time_step").value);
	if(dtim > -32768 && dtim < 32768) {
		addClog("Send cmd set delta (24 + delta: '+dtim+' )...");
		settingsCharacteristics.writeValue(new Uint8Array([0x24, dtim&0xff, (dtim>>8)&0xff])).then(_ => {
			addAlog('Send delta time ok');
			setDevTime();
		});
	} else {
		addAlog("Delta time -32767 to 32767!");
	}
}
function sendGetMemo(cnt) {
	let count = cnt & 0x7fff;
	let start = 0;
	if(count > 19632) count = 19632;
	if(start < 0) start = 0;
	else if(start >= count) start = count - 1;
	blk = new Uint8Array([0x35, count&0xff, (count>>8)&0xff,start&0xff,(start>>8)&0xff]);
	addClog("Send cmd GetMemo: ("+dump(blk, blk.length)+")...");
	settingsCharacteristics.writeValue(blk).then(_ => {
		flg_memo_act = true;
		addAlog('Send cmd GetMemo ok');
	});
}
function setSensCfg() {
	if(settingsCharacteristics != null) {
		devSens.temp_k = Math.round(100.0 * parseFloat($('inpTempK').value));
		devSens.humi_k = Math.round(100.0 * parseFloat($('inpHumK').value)); 
		devSens.temp_z = Math.round(100.0 * parseFloat($('inpTempZ').value));
		devSens.humi_z = Math.round(100.0 * parseFloat($('inpHumZ').value));

		blk = new Uint8Array([0x25, 
		    devSens.temp_k & 0xff, (devSens.temp_k >> 8) & 0xff, (devSens.temp_k >> 16) & 0xff, (devSens.temp_k >> 24) & 0xff,
		    devSens.humi_k & 0xff, (devSens.humi_k >> 8) & 0xff, (devSens.humi_k >> 16) & 0xff, (devSens.humi_k >> 24) & 0xff,
	    	devSens.temp_z & 0xff, (devSens.temp_z >> 8) & 0xff,
		    devSens.humi_z & 0xff, (devSens.humi_z >> 8) & 0xff
		    ]);
		settingsCharacteristics.writeValue(new Uint8Array(blk)).then(_ => {	addAlog("Send Sensor Settings: "+dump(blk, blk.length)+" - ok")})
		.catch(error => { addAlog("Send Sensor Settings Error: " + error); });
	}
}
function getSensCfg() {
	if(settingsCharacteristics != null) {
		addAlog("Get Sensor Settings...");
		settingsCharacteristics.writeValue(new Uint8Array([0x25])).catch(error => { addAlog("Get Sensor Settings Error: " + error); });
	}
}
function resetSensCfg() {
	if(settingsCharacteristics != null) {
		addAlog("Restore Sensor Default Settings...");
		settingsCharacteristics.writeValue(new Uint8Array([0x26])).catch(error => { addAlog("Restore Sensor Default Settings Error: " + error); });
	}
}
function getBKey() {
		settingsCharacteristics.writeValue(new Uint8Array([0x18])).then(_ => {
			addAlog('Get binkey from EEP...');
		});
}
function setBKey() {
	let bk = $("cbind_key").value;
	if(bk.length == 32) {
		let bkey = hexToBytes(bk);
		if(bkey.length == 16) {
			let blk = new Uint8Array(17);
			blk.set(bkey,1);
			blk[0] = 0x18;
			addClog("Send bindkey to EEP...");
			settingsCharacteristics.writeValue(blk).then(_ => {
				addAlog("Send new bindkey: " + bytesToHex(blk.slice(1)));
			});
			return;
		}
	}
	addLog("BindKey must be 16 hex digits!")
}
function InfoIntervals() {
		let advn = parseFloat($("cfg_adv_int").value);
		let meas = parseInt($("cfg_meas_int").value);
		if(advn != 0 && meas != 0) {
			advn = Math.round(advn/62.5) * 62.5;
			$("cfg_meas_int_val").innerHTML = "= " + String((advn * meas / 1000).toFixed(1)) + " sec";
			if(cfg.ver >= 0x20) {
				let memo = parseInt($("cfg_av_meas_mem").value);
				if(memo != 0) {
					let x = advn * meas * memo / 1000;
					if (x < 60)
						$("cfg_av_meas_mem_val").innerHTML = "= " +	 String(x.toFixed(1)) + " sec";
					else
						$("cfg_av_meas_mem_val").innerHTML = "= " +	 String(x.toFixed(1)) + " sec = " + String((x / 60).toFixed(1)) + " min";
				}
			}
		}
}
function CustomConfig() {
 menuUpgrade();
 let is = '';
 if(cfg.ver >= 0x10) {
  is = '<hr>Send commands to custom firmware:<br><input type="text" id="cmdTXT" value=""><button type="button" onclick="sendCustomSetting($(&quot;cmdTXT&quot;).value,settingsCharacteristics);">Send</button>';
  if(hwver_id <= 15) {
	if(hwver_id == 0)
		is += ' Test: [ <button type="button" onclick="lcd_clock();">Show clock on LCD</button> <button type="button" onclick="lcd_restore();">Repair LCD</button> ]<br>';
	is += '<br>Show on device screen:<br>';
	if(hwver_id == 2 || hwver_id == 6 || hwver_id == 7){
		is += '<input size="6" title="Big number: -99.5..1999.5" id="extbignumb" maxlength="5" value="123.4">';
		is += ' <select id="exttmpsmb"><option value="0">&nbsp;&nbsp;</option><option value="1">°Г</option><option value="2">&nbsp;-</option><option value="3">°F</option><option value="4">&nbsp;_</option><option value="5">°C</option><option value="6" selected>&nbsp;=</option><option value="7">°E</option></select>';
		is += ' <select id="extsmiley"><option value="0" selected>&nbsp;&nbsp;&nbsp;</option><option value="5">&nbsp;---&nbsp;</option></select>';
		is += '	<input size="5" title="Small number: -99.5..999.5" id="extsmalnumb" maxlength="5" value="56.7">';
	}else if(hwver_id == 9){
		is += '<input size="8" title="Big number: -999.50..19999.50" id="extbignumb" maxlength="8" value="123.45">';
		is += ' <select id="exttmpsmb"><option value="0">&nbsp;&nbsp;</option><option value="1">°г</option><option value="2">&nbsp;-</option><option value="3">°C</option><option value="4">&nbsp;i</option><option value="5">°Г</option><option value="6" selected>&nbsp;г</option><option value="7">°F</option></select>';
		is += ' <select id="extsmiley"><option value="0">&nbsp;&nbsp;&nbsp;</option><option value="1">&nbsp;^_^&nbsp;</option><option value="2">&nbsp;-&and;-&nbsp;</option><option value="3">&nbsp;&Delta;&#9651;&Delta;&nbsp;</option><option value="4">(&nbsp;&nbsp;&nbsp;)</option><option value="5">(^_^)</option><option value="6">(-&and;-)</option><option value="7" selected>(&Delta;&#9651;&Delta;)</option></select>';
	}else {
		is += '<input size="6" title="Big number: -99.5..1999.5" id="extbignumb" maxlength="5" value="123.4">';
		is += ' <select id="exttmpsmb"><option value="0">&nbsp;&nbsp;</option><option value="1">°Г</option><option value="2">&nbsp;-</option><option value="3">°F</option><option value="4">&nbsp;_</option><option value="5">°C</option><option value="6" selected>&nbsp;=</option><option value="7">°E</option></select>';
		is += ' <select id="extsmiley"><option value="0">&nbsp;&nbsp;&nbsp;</option><option value="1">&nbsp;^_^&nbsp;</option><option value="2">&nbsp;-&and;-&nbsp;</option><option value="3">&nbsp;&Delta;&#9651;&Delta;&nbsp;</option><option value="4">(&nbsp;&nbsp;&nbsp;)</option><option value="5">(^_^)</option><option value="6">(-&and;-)</option><option value="7" selected>(&Delta;&#9651;&Delta;)</option></select>';
		is += '	<input size="5" title="Small number: -9..99" id="extsmalnumb" maxlength="2" value="99">';
	}
	is += '&nbsp;%<input type="checkbox" id="extpersent">';
	is += '	<input size="5" title="Validity time = Show time in sec: 1..65535" id="extvtimed" maxlength="5" value="600">';
	is += '&nbsp;Battery:<input type="checkbox" id="extbattery">';
	is += '	<button type="button" onclick="sendCustomSetting(&quot;22&quot;);">Get OldData</button>';
	is += '	<button type="button" id="extsend" onclick="sendExt();">Show</button>';
	ext.enable = true;
	is += '<br><br><hr><br><b>Configuration:</b>&nbsp;<button type="button" onclick="sendCustomSetting(&quot;55&quot;);">Get Config</button><br><br>';
	if(cfg.ver >= 0x43)
		is += 'Screen Off: <input title="Screen Off" type="checkbox" id="cfg_scr_off"><br><br>';
	is += 'Temperature: <select id="cfg_flg_cf"><option value="0">°C</option><option value="1">°F</option></select>';
	if(hwver_id == 9)
		is += '&nbsp;&nbsp;12-hour clock:<input type="checkbox" id="cfg_flg_am_pm">&nbsp;&nbsp;T&H 2 decimal places<input type="checkbox" id="cfg_flg_x100">';
	is += '<br><br>';
	if((hwver_id == 2)||(hwver_id == 6)||(hwver_id == 7))
		is += 'Line: <select id="cfg_smiley"><option value="0" selected>&nbsp;&nbsp;&nbsp;</option><option value="5">&nbsp;---&nbsp;</option></select>';
	else if(hwver_id == 9)
		is += 'Show: <select id="cfg_scr_type"><option value="0">Time</option><option value="1">Temperature</option><option value="2">Humidity</option><option value="3">Battery %</option><option value="4">Battery V</option><option value="5">ExtNumber&Symbols</option></select>';
	else
		is += 'Smiley: <select id="cfg_smiley"><option value="0">&nbsp;&nbsp;&nbsp;</option><option value="1">&nbsp;^_^&nbsp;</option><option value="2">&nbsp;-&and;-&nbsp;</option><option value="3">&nbsp;&Delta;&#9651;&Delta;&nbsp;</option><option value="4">(&nbsp;&nbsp;&nbsp;)</option><option value="5">(^_^)</option><option value="6">(-&and;-)</option><option value="7">(&Delta;&#9651;&Delta;)</option></select>';
	is += ', Comfort: <input type="checkbox" id="cfg_flg_comfort">';
	if(hwver_id != 9)
		is += ', Show batt: <input type="checkbox" id="cfg_flg_show_batt">';
	if(cfg.ver >= 0x18) {
		if(hwver_id != 9)
			is += ', Clock: <input type="checkbox" id="cfg_flg_blinking"> ';
		is += '<button type="button" onclick="setDevTime();">Set Time</button> <button type="button" onclick="sendCustomSetting(&quot;23&quot;);">Get Time</button>';
	}else
		is += ', Blinking: <input type="checkbox" id="cfg_flg_blinking">';
	is += '<br><br>Sensor in "LowPower mode": <input title="Sensor measurements in Low Power mode" type="checkbox" id="cfg_flg_lp_meas">';
	is += ', Tx measures: <input title="When connected, start transferring measurements" type="checkbox" id="cfg_flg_tx_meas">';
  } else {
	is += '<br><hr><br><b>Configuration:</b>&nbsp;<button type="button" onclick="sendCustomSetting(&quot;55&quot;);">Get Config</button><br><br>';
	//is += 'Sensor in "LowPower mode": <input title="Sensor measurements in Low Power mode" type="checkbox" id="cfg_flg_lp_meas">';
	is += 'Tx measures: <input title="When connected, start transferring measurements" type="checkbox" id="cfg_flg_tx_meas">';
  }
	is += ' <button type="button" title="Start transferring measurements. Only in the current connection." onclick="sendCustomSetting(&quot;33ff&quot;);">Start Tx Measure</button>';
	is += ' <button type="button" title="Stop transferring measurements. Only in the current connection." onclick="sendCustomSetting(&quot;3300&quot;);">Stop Tx Measure</button><br><br>';
	if(cfg.ver < 0x47) {
		is += 'Temperature offset: <input size="5" title="-12.7..12.7°, default 0" id="cfg_tmp_off" maxlength="5" value="0"> °';
		is += ', Humidity offset: <input size="5" title="-12.7..12.7%, default 0" id="cfg_hm_off" maxlength="5" value="0"> %<br><br>';
	}
	if(cfg.ver >= 0x36) {
		if(cfg.ver >= 0x42)
			is += 'BT5+ PHY: <input title="Support BT5.0+ PHY (LE 2M/1M/500K/125K, CSA2)" type="checkbox" id="bt5_flags">, LE Long Range (only for BT5.0+ adapters!): <input title="Enable Extended Advertising Long Range (Coded PHY S8)" type="checkbox" id="longrange_flags"><br><br>';
		else if(cfg.ver >= 0x40)
			is += 'BT5+ PHY: <input title="Support BT5.0+ PHY (LE 2M/1M/500K/125K, CSA2)" type="checkbox" id="bt5_flags"><br><br>';
		else
			is += 'BT5+ PHY: <input title="Support BT5.0+ PHY (LE 2M/1M/500K/125K)" type="checkbox" id="bt5_flags">, CSA2: <input title="Channel Selection Algorithm 2 or 1" type="checkbox" id="csa2_flags"><br><br>';
	}
  if(hwver_id <= 15) {
		is += 'Advertising type: <select id="cfg_flg_adv_type"><option value="0">ATC1441</option><option value="1">PVVX (Custom)</option><option value="2">MIJIA (MiHome)</option><option value="3" selected>';
	if(cfg.ver >= 0x37)
		if(cfg.ver >= 0x45)
			is += 'BTHome v2</option></select>';
		else
			is += 'BTHome v1</option></select>';
	else
		is += 'All</option></select>';
	if(cfg.ver >= 0x30)
		is += ', AdFlags: <input title="Toggle support for third-party software" type="checkbox" id="adv_flags">';
	if(cfg.ver >= 0x22)
		is += ', Encrypted beacon: <input title="Bindkey encrypted beacon" type="checkbox" id="cfg_adv_crypto">';
	is += '<br><br>Advertising interval: <input size="5" title="62.5 ms .. 10 000 ms, step: 62.5 ms, default 2500 ms" id="cfg_adv_int" maxlength="6" value="40"> ms, step: 62.5 ms<br><br>';
	is += 'Measure interval: <input size="5" title="1..25 (62.5 ms .. 250 sec), default 4 (10 sec)" id="cfg_meas_int" maxlength="2" value="4"> x(Advertising interval) <span id="cfg_meas_int_val"></span><br><br>';
	if(cfg.ver > 0x40)
		is += 'Connect latency: <input size="5" title="0..1000 ms, default 1000 ms" id="cfg_con_lat" maxlength="4" value="1000"> ms, step 20 ms<br><br>';
	else
		is += 'Connect latency: <input size="5" title="0..4000 ms, default 2500 ms" id="cfg_con_lat" maxlength="4" value="2500"> ms, step 20 ms<br><br>';
  } else {
	if(cfg.ver < 0x48) {
	  	is += 'Advertising type: <select id="cfg_flg_adv_type"><option value="0">BTHome v2</option><option value="1"  selected>PVVX (Custom)</option><option value="2">MIJIA (MiHome)</option><option value="3">BTHome v1</option></select>';
	} else {
		is += 'Sensor in "LowPower mode": <input title="Sensor measurements in Low Power mode" type="checkbox" id="cfg_flg_lp_meas"><br><br>';
		is += 'Advertising type: <select id="cfg_flg_adv_type"><option value="0">ATC1441</option><option value="1">PVVX (Custom)</option><option value="2">MIJIA (MiHome)</option><option value="3" selected>BTHome v2</option></select>';
	}
	is += ', AdFlags: <input title="Toggle support for third-party software" type="checkbox" id="adv_flags">';
	is += ', Encrypted beacon: <input title="Bindkey encrypted beacon" type="checkbox" id="cfg_adv_crypto">';
	is += '<br><br>Advertising interval: <input size="5" title="62.5 ms .. 10 000 ms, step: 62.5 ms, default 2500 ms" id="cfg_adv_int" maxlength="6" value="40"> ms, step: 62.5 ms<br><br>';
	is += 'Measure interval: <input size="5" title="1..25 (62.5 ms .. 250 sec), default 4 (10 sec)" id="cfg_meas_int" maxlength="2" value="4"> x(Advertising interval) <span id="cfg_meas_int_val"></span><br><br>';
	is += 'Connect latency: <input size="5" title="0..1000 ms, default 1000 ms" id="cfg_con_lat" maxlength="4" value="1000"> ms, step 20 ms<br><br>';
	MAX_RF_TX_Power = true;
  }
	if(MAX_RF_TX_Power) is += 'RF TX Power: <select id="cfg_rf_tx"><option value="63">VBAT+10.46 dbm</option><option value="61">VBAT+10.29 dbm</option><option value="58">VBAT+10.01 dbm</option><option value="56">VBAT+9.81 dbm</option><option value="53">VBAT+9.48 dbm</option><option value="51">VBAT+9.24 dbm</option><option value="49">VBAT+8.97 dbm</option><option value="47">VBAT+8.73 dbm</option><option value="45">VBAT+8.44 dbm</option><option value="43">VBAT+8.13 dbm</option><option value="41">VBAT+7.79 dbm</option><option value="39">VBAT+7.41 dbm</option><option value="37">VBAT+7.02 dbm</option><option value="35">VBAT+6.60 dbm</option><option value="33">VBAT+6.14 dbm</option><option value="31">VBAT+5.65 dbm</option><option value="29">VBAT+5.13 dbm</option><option value="27">VBAT+4.57 dbm</option><option value="25">VBAT+3.94 dbm</option><option value="23">VBAT+3.23 dbm</option><option value="191" selected>VANT+3.01 dbm</option><option value="189">VANT+2.81 dbm</option><option value="187">VANT+2.61 dbm</option><option value="185">VANT+2.39 dbm</option><option value="182">VANT+1.99 dbm</option><option value="180">VANT+1.73 dbm</option><option value="178">VANT+1.45 dbm</option><option value="176">VANT+1.17 dbm</option><option value="174">VANT+0.90 dbm</option><option value="172">VANT+0.58 dbm</option><option value="169">VANT+0.04 dbm</option><option value="168">VANT-0.14 dbm</option><option value="164">VANT-0.97 dbm</option><option value="162">VANT-1.42 dbm</option><option value="160">VANT-1.89 dbm</option><option value="158">VANT-2.48 dbm</option><option value="156">VANT-3.03 dbm</option><option value="154">VANT-3.61 dbm</option><option value="152">VANT-4.26 dbm</option><option value="150">VANT-5.03 dbm</option><option value="148">VANT-5.81 dbm</option><option value="146">VANT-6.67 dbm</option><option value="144">VANT-7.65 dbm</option><option value="142">VANT-8.65 dbm</option><option value="140">VANT-9.89 dbm</option><option value="138">VANT-11.4 dbm</option><option value="136">VANT-13.29 dbm</option><option value="134">VANT-15.88 dbm</option><option value="132">VANT-19.27 dbm</option><option value="130">VANT-25.18 dbm</option></select><br><br>';
	else is += 'RF TX Power: <select id="cfg_rf_tx"><option value="191" selected>VANT+3.01 dbm</option><option value="189">VANT+2.81 dbm</option><option value="187">VANT+2.61 dbm</option><option value="185">VANT+2.39 dbm</option><option value="182">VANT+1.99 dbm</option><option value="180">VANT+1.73 dbm</option><option value="178">VANT+1.45 dbm</option><option value="176">VANT+1.17 dbm</option><option value="174">VANT+0.90 dbm</option><option value="172">VANT+0.58 dbm</option><option value="169">VANT+0.04 dbm</option><option value="168">VANT-0.14 dbm</option><option value="164">VANT-0.97 dbm</option><option value="162">VANT-1.42 dbm</option><option value="160">VANT-1.89 dbm</option><option value="158">VANT-2.48 dbm</option><option value="156">VANT-3.03 dbm</option><option value="154">VANT-3.61 dbm</option><option value="152">VANT-4.26 dbm</option><option value="150">VANT-5.03 dbm</option><option value="148">VANT-5.81 dbm</option><option value="146">VANT-6.67 dbm</option><option value="144">VANT-7.65 dbm</option><option value="142">VANT-8.65 dbm</option><option value="140">VANT-9.89 dbm</option><option value="138">VANT-11.4 dbm</option><option value="136">VANT-13.29 dbm</option><option value="134">VANT-15.88 dbm</option><option value="132">VANT-19.27 dbm</option><option value="130">VANT-25.18 dbm</option></select><br><br>';
  if(hwver_id <= 15) {
	if(hwver_id != 9)
		is += 'Minimum LCD refresh rate: <input size="5" title="0.5..12.75 sec, step: 0.05 s, default 2.45 s" id="cfg_lcd_tint" maxlength="6" value="2.45"> s, step: 0.05 s<br><br>';
	if(cfg.ver == 0x19) {
		is += 'Recording measurements to flash memory <input type="checkbox" id="cfg_flg2_memo" title="Recording measurements to flash memory (cyclic buffer for 19632 measurements)">';
		is += ' <button type="button" onclick="sendGetMemo(50);">Get the last 50 records</button> <a href="GraphMemo.html">GraphMemo.html target="_blank"</a><br><br>';
	}
	if(cfg.ver >= 0x20) {
		is += 'Recording averaging measurements to flash memory <input size="5" title="0..255, =0 - off, default 60. Set time/date!" id="cfg_av_meas_mem" maxlength="3" value="60"> x(measure interval) <span id="cfg_av_meas_mem_val"></span><br>';
		if(cfg.ver >= 0x23)
			is += '<button type="button" onclick="sendCustomSetting(&quot;361234&quot;);">!Delete all records!</button> '
		is += '<a href="GraphMemo.html" target="_blank">GraphMemo.html</a> <button type="button" onclick="setDevTime();">Set Time</button> <button type="button" onclick="sendGetMemo(50);">Get the last 50 records</button><br><br>';
	}
	is += '<button type="button" onclick="SendCustomConfig()">Send Config</button>';
	is += ' <button type="button" onclick="sendCustomSetting(&quot;56&quot;);">Set default</button><br>';
	if(cfg.ver >= 0x47)
		is += '<hr><label id="lblSensor"><b>Sensor Settings:</b></label><br>Temperature Slope factor: <input size="8" type="text" id="inpTempK" maxlength="8" title="Tk: Slope factor (linear function) for temperature calculation (T=RegT*Tk/65536+Tz)"> , Zero offset: <input size="8" type="text" id="inpTempZ" maxlength="8" title="Tz: Zero offset with correction value for temperature calculation (T=RegT*Tk/65536+Tz)"><br>Humidity Slope factor: <input size="8" type="text" id="inpHumK" maxlength="8" title="Hk: Slope factor (linear function) for humidity calculation (H=RegH*Hk/65536+Hz)"> , Zero offset: <input size="8" type="text" id="inpHumZ" maxlength="8" title="Hz: Zero offset with correction value for humidity calculation (H=RegH*Hk/65536+Hz)"><br><button type="button"id="btnGetSens" onclick="getSensCfg()">Get Sensor Settings</button> <button type="button"id="btnSetSens" onclick="setSensCfg()">Send Sensor Settings</button> <button type="button"id="btnRstSens" onclick="resetSensCfg()" title="Restore default sensor settings">Set Default</button><br>';
	if(cfg.ver >= 0x24 && hwver_id != 9) {
		is += '<hr><button type="button" title="Get time clock delta" onclick="sendCustomSetting(&quot;24&quot;);">Get delta time</button>';
		is += ' Adjust time clock delta: <input size="5" title="-32767..32767, in 1/16 us for 1 sec, default 0" id="cfg_time_step" maxlength="6" value="0">';
		is += ' <button type="button" onclick="sendDeltaTime();">Set delta time</button>';
		if(cfg.ver >= 0x36)
			is += ' <button type="button" title="The minimum period for calculation is 3 hours!" onclick="calkDeltaTime();">Calk delta time</button><br>';
		else
			is += '<br>';
	}
	if((hwver_id == 0)||(hwver_id == 3)||(hwver_id == 4)||(hwver_id == 5)||(hwver_id == 10))
		is += '<hr><b>Management GPIO_TRG</b> (mark "reset"):';
	else
		is += '<hr><b>Management GPIO_TRG:</b>';
	is += '&nbsp;<button type="button" title="Get/read current setings" onclick="sendCustomSetting(&quot;44&quot;);">Get TRG</button><br>';
	if(cfg.ver >= 0x26) {
		is += 'Temperature hysteresis: <input size="8" title="Step 0.01°, default -0.55°, =0 off, if less than zero - activation on decrease, if more than zero - activation on excess" id="trg_tmp_hst" maxlength="7" value="-0.55"> °';
		is += ', Humidity hysteresis: <input size="8" title="Step 0.01%, default 0, =0 off, if less than zero - activation on decrease, if more than zero - activation on excess" id="trg_hm_hst" maxlength="7" value="0.0"> %<br>';
	} else {
		is += 'Temperature hysteresis: <input size="8" title="-12.7..12.7°, default -0.1, =0 off, if less than zero - activation on decrease, if more than zero - activation on excess" id="trg_tmp_hst" maxlength="5" value="-0.1"> °';
		is += ', Humidity hysteresis: <input size="8" title="-12.7..12.7%, default 0, =0 off, if less than zero - activation on decrease, if more than zero - activation on excess" id="trg_hm_hst" maxlength="5" value="0.0"> %<br>';
	}
	is += 'Temperature threshold: <input size="8" title="-40.00..80.00°C, default 21.00°C" id="trg_tmp_thr" maxlength="6" value="21.00"> °';
	is += ', Humidity threshold: <input size="8" title="0..99.00%, default 50.00%" id="trg_hm_thr" maxlength="6" value="50.00"> %<br><br>';
	if(cfg.ver >= 0x37) {
		is += '<b>Management GPIO_RS (Reed Switch):</b><br><br>';
		is += 'RS mode: <select id="rds_type"><option value="0" selected>None</option><option value="1">Switch</option><option value="2">Counter</option>';
		if(cfg.ver >= 0x42 && hwver_id != 9)
			is += '<option value="3" selected>Connect</option>';
		if(cfg.ver >= 0x39)	is += '</select>, Invert RS event: <input type="checkbox" id="rds_invert">';
		is += '<br>RS report interval: <input size="8" title="0 - Off, 1..65535 sec, default 3600 sec" id="rds_rpint" maxlength="6" value="3600"> sec';
	}
	is += '<br> <button type="button" title="Set/save current setings" onclick="sendTrg();">Set TRG</button>';
	is += ' <button type="button" title="GPIO_TRG PullUp 10 kOm. Work only TRG off!" onclick="sendCustomSetting(&quot;4501&quot;);">Set pin to "1"</button>';
	is += ' <button type="button" title="GPIO_TRG PullDown 100 kOm. Work only TRG off!" onclick="sendCustomSetting(&quot;4500&quot;);">Set pin to "0"</button><br><hr>';
	if(cfg.ver >= 0x13) {
		is += '<b>Comfort parameters:</b>&nbsp;';
		is += '<button type="button" title="Get current comfort parameters. The parameters are processed if the configuration is set to &quot;Comfort: On&quot;." onclick="sendCustomSetting(&quot;20&quot;);">Get current comfort parameters</button><br>';
		is += 'Temperature Lo:<input size="8" title="-40.00..125.00°C, default 21.00°C" id="cmf_tmp_lo" maxlength="6" value="21.00">, ';
		is += 'Hi: <input size="8" title="-40.00..125.00°C, default 26.00°C" id="cmf_tmp_hi" maxlength="6" value="26.00"> °C<br>';
		is += 'Humidity Lo:<input size="8" title="0.0..99.99%, default 30.00" id="cmf_hm_lo" maxlength="5" value="30.00">, ';
		is += 'Hi:<input size="8" title="0.0..99.99%, default 60.00%" id="cmf_hm_hi" maxlength="5" value="60.00"> %<br>';
		is += '<button type="button" title="Set comfort parameters" onclick="SendCmf();">Set comfort parameters</button><br><hr>';
		cmf.enable = true;
	}
	trg.enable = true;
	is += '<b>Keys and Codes:</b>&nbsp;<button type="button" onclick="sendCustomSetting(&quot;15&quot;);">Show all mi keys</button><br>';
	if(cfg.ver >= 0x11) {
		is += '<input size="6" maxlength="6" type="text" title="000000..999999, 6 decimal digits, 000000 - PinCode Disable. Warning: If the PinCode is forgotten - only a hardware flasher!" id="pincode" value="000000"> <button title="Warning: If the PinCode is forgotten - only a hardware flasher!" type="button" onclick="sendPinCode();">!Set PinCode!</button><br>';
		pincode.enable = true;
		if(cfg.ver >= 0x14) {
			is += '<br><button type="button" onclick="sendCustomSetting(&quot;01&quot;);">Get device Name</button> <input size="10" maxlength="18" type="text" title="Device Name: 1..18 chars" id="dev_name" value=""> <button type="button" title="Set New Name" onclick="sendDevName();">Set New Name</button> <button title="Clean Name: ATC_xxxx" type="button" onclick="CleanDevName();">Set default Name</button><br>';
			dnm.enable = true;
		}
	}
	if(mikeys.mac) {
		is +='Device MAC [+ 2 Rand]:<br><input size="40" maxlength="16" type="text" id="mi_mac" title="Must be 6 hex MAC digits [+ 2 hex RandMAC digits]!" value="'+hex(mikeys.mac[5],2)+hex(mikeys.mac[4],2)+hex(mikeys.mac[3],2)+hex(mikeys.mac[2],2)+hex(mikeys.mac[1],2)+hex(mikeys.mac[0],2)+hex(mikeys.mac[7],2)+hex(mikeys.mac[6],2)+'">';
		// ', C0'+hex(mikeys.mac[7],2)+hex(mikeys.mac[6],2)+hex(mikeys.mac[2],2)+hex(mikeys.mac[1],2)+hex(mikeys.mac[0],2)'
		if(cfg.ver >= 0x14)
			is +=' <button type="button" title="Set Custom MAC. Warning: If the pin code is set, restart all Soft & Hard for the next connection!" onclick="sendMAC();">!Set MAC!</button> <button type="button" title="Clean MAC - Set Standart Random MAC: A4C138******. Warning: If the pin code is set, restart all Soft & Hard for the next connection!" onclick="CleanMAC();">!Clean MAC!</button>';
		is +='<br>';
	}
	if(mikeys.id) {
		let str = new TextDecoder("utf-8").decode(mikeys.id.slice(1));
		is +='Device known id:<br><input size="40" maxlength="19" type="text" id="known_id" value="'+str+'"><br>';
	}
	if(mikeys.bindkey && mikeys.token) {
		is +='Mi Token:<br><input size="40" maxlength="24" type="text" id="mi_token" value="'+dump(mikeys.token,12)+'"><br>';
		is +='Mi Bind Key:<br><input size="40" maxlength="32" type="text" id="mi_bind_key" value="'+dump(mikeys.bindkey,16)+'">';
		is +=' <button type="button" title="Set new Mi Token and Bind keys" onclick="setNewTBKey();">Set new Token & Bind keys</button><br>';
		if(cfg.ver >= 0x21)
			is +=' <button type="button" title="Erase all MiKeys" onclick="sendCustomSetting(&quot;17&quot;);">!Erase all Mi Keys!</button>';
		if(mikeys.restore) {
			is += '<br><button type="button" onclick="sendCustomSetting(&quot;16&quot;);">Swap previous token + bindkey</button>';
		}
		is += '<br>';
	}
	if(cfg.ver >= 0x28) {
		is +='BindKey:<br><input size="40" maxlength="32" title="Bind Key must be 16 hex digits" type="text" id="cbind_key" value="?">';
		is +=' <button type="button" title="Get BindKey" onclick="getBKey();">Get BindKey</button>';
		is +=' <button type="button" title="Set new BindKey" onclick="setBKey();">Set BindKey</button><br>';
	}
	$("custcfg").innerHTML = is;
	if(cfg.ver >= 0x43)
		$("cfg_scr_off").checked = (cfg.flg2&0x80) != 0
	$("cfg_flg_adv_type").value = cfg.flg&3;
	$("cfg_flg_comfort").checked = (cfg.flg&4) != 0;
	if(hwver_id == 9) {
		$("cfg_flg_am_pm").checked = (cfg.flg&32) != 0;
		$("cfg_flg_x100").checked = (cfg.flg&8) != 0;
		$("cfg_scr_type").value = cfg.flg2&7;
		$("adv_flags").checked = (cfg.flg2&0x10) != 0;
		$("bt5_flags").checked = (cfg.flg2&0x20) != 0;
		$("longrange_flags").checked = (cfg.flg2&0x40) != 0;
	} else {
		$("cfg_flg_blinking").checked = (cfg.flg&8) != 0;
		$("cfg_flg_show_batt").checked = (cfg.flg&32) != 0;
		$("cfg_smiley").value = cfg.flg2&7;
		if(cfg.ver == 0x19)
			$("cfg_flg2_memo").checked = (cfg.flg2&8) != 0;
		if(cfg.ver >= 0x30)
			$("adv_flags").checked = (cfg.flg2&0x10) != 0;
		if(cfg.ver >= 0x36) {
			$("bt5_flags").checked = (cfg.flg2&0x20) != 0;
			if(cfg.ver >= 0x42)
				$("longrange_flags").checked = (cfg.flg2&0x40) != 0;
			else if(cfg.ver < 0x40)
				$("csa2_flags").checked = (cfg.flg2&0x40) != 0;
		}
		$("cfg_lcd_tint").value = String((cfg.lcd_tint * 0.05).toFixed(2));
	}
	$("cfg_flg_cf").value = ((cfg.flg&16) != 0 ? 1 : 0);
	$("cfg_flg_tx_meas").checked = (cfg.flg&64) != 0;
	$("cfg_flg_lp_meas").checked = (cfg.flg&128) != 0;
	if(cfg.ver >= 0x22)
		$("cfg_adv_crypto").checked = (cfg.flg2&0x08) != 0;
	if(cfg.ver >= 0x20) {
		$("cfg_av_meas_mem").value = String(cfg.av_meas_mem);
		$("cfg_av_meas_mem").onchange = function() {InfoIntervals();};
	}
	if(cfg.ver < 0x47) {
		$("cfg_tmp_off").value = String((cfg.temp_offset / 10.0).toFixed(1));
		$("cfg_hm_off").value = String((cfg.humi_offset / 10.0).toFixed(1));
	}
	$("cfg_adv_int").value = String((cfg.advertising_interval * 62.5).toFixed(1));
	$("cfg_adv_int").onchange = function() {InfoIntervals();};
	$("cfg_meas_int").value = String(cfg.measure_interval);
	$("cfg_meas_int").onchange = function() {InfoIntervals();};
	$("cfg_rf_tx").value = String(cfg.rf_tx_power);
	$("cfg_con_lat").value = String((cfg.connect_latency + 1) * 20);
  } else {
	is +='Recording averaging measurements to flash memory <input size="5" title="0..255, =0 - off, default 60. Set time/date!" id="cfg_av_meas_mem" maxlength="3" value="60"> x(measure interval) <span id="cfg_av_meas_mem_val"></span><br>';
	is +='<button type="button" onclick="sendCustomSetting(&quot;361234&quot;);">!Delete all records!</button> '
	is +='<a href="GraphMemo.html" target="_blank">GraphMemo.html</a> <button type="button" onclick="setDevTime();">Set Time</button> <button type="button" onclick="sendGetMemo(50);">Get the last 50 records</button><br><br>';
	is +='<button type="button" onclick="SendCustomConfig()">Send Config</button>';
	is +=' <button type="button" onclick="sendCustomSetting(&quot;56&quot;);">Set default</button><br>';
	is +='<hr><button type="button" title="Get time clock delta" onclick="sendCustomSetting(&quot;24&quot;);">Get delta time</button>';
	is +=' Adjust time clock delta: <input size="5" title="-32767..32767, in 1/16 us for 1 sec, default 0" id="cfg_time_step" maxlength="6" value="0">';
	is +=' <button type="button" onclick="sendDeltaTime();">Set delta time</button>';
	is +=' <button type="button" title="The minimum period for calculation is 3 hours!" onclick="calkDeltaTime();">Calk delta time</button><br>';
	if(cfg.ver >= 0x47)
		is += '<hr><label id="lblSensor"><b>Sensor Settings:</b></label><br>Temperature Slope factor: <input size="8" type="text" id="inpTempK" maxlength="8" title="Tk: Slope factor (linear function) for temperature calculation (T=RegT*Tk/65536+Tz)"> , Zero offset: <input size="8" type="text" id="inpTempZ" maxlength="8" title="Tz: Zero offset with correction value for temperature calculation (T=RegT*Tk/65536+Tz)"><br>Humidity Slope factor: <input size="8" type="text" id="inpHumK" maxlength="8" title="Hk: Slope factor (linear function) for humidity calculation (H=RegH*Hk/65536+Hz)"> , Zero offset: <input size="8" type="text" id="inpHumZ" maxlength="8" title="Hz: Zero offset with correction value for humidity calculation (H=RegH*Hk/65536+Hz)"><br><button type="button"id="btnGetSens" onclick="getSensCfg()">Get Sensor Settings</button> <button type="button"id="btnSetSens" onclick="setSensCfg()">Send Sensor Settings</button> <button type="button"id="btnRstSens" onclick="resetSensCfg()" title="Restore default sensor settings">Set Default</button><br>';
   	if(cfg.ver >= 0x48) {
		is += '<hr><b>Management GPIO_TRG:</b>';
		is += '&nbsp;<button type="button" title="Get/read current setings" onclick="sendCustomSetting(&quot;44&quot;);">Get TRG</button><br>';
		is += 'Temperature hysteresis: <input size="8" title="Step 0.01°, default -0.55°, =0 off, if less than zero - activation on decrease, if more than zero - activation on excess" id="trg_tmp_hst" maxlength="7" value="-0.55"> °';
		is += ', Humidity hysteresis: <input size="8" title="Step 0.01%, default 0, =0 off, if less than zero - activation on decrease, if more than zero - activation on excess" id="trg_hm_hst" maxlength="7" value="0.0"> %<br>';
		is += 'Temperature threshold: <input size="8" title="-40.00..80.00°C, default 21.00°C" id="trg_tmp_thr" maxlength="6" value="21.00"> °';
		is += ', Humidity threshold: <input size="8" title="0..99.00%, default 50.00%" id="trg_hm_thr" maxlength="6" value="50.00"> %<br><br>';
		is += '<b>Management GPIO_RS (Reed Switch):</b><br><br>';
		is += 'RS mode: <select id="rds_type"><option value="0" selected>None</option><option value="1">Switch</option><option value="2">Counter</option>';
		//is += '<option value="3" selected>Connect</option>';
		is += '</select>, Invert RS event: <input type="checkbox" id="rds_invert">';
		is += '<br>RS report interval: <input size="8" title="0 - Off, 1..65535 sec, default 3600 sec" id="rds_rpint" maxlength="6" value="3600"> sec';
		is += '<br> <button type="button" title="Set/save current setings" onclick="sendTrg();">Set TRG</button>';
		is += ' <button type="button" title="GPIO_TRG PullUp 10 kOm. Work only TRG off!" onclick="sendCustomSetting(&quot;4501&quot;);">Set pin to "1"</button>';
		is += ' <button type="button" title="GPIO_TRG PullDown 100 kOm. Work only TRG off!" onclick="sendCustomSetting(&quot;4500&quot;);">Set pin to "0"</button><br><hr>';
		trg.enable = true;
   	}
	is +='<hr><b>Keys and Codes:</b><br><br>EEP BindKey:<br><input size="40" maxlength="32" title="Bind Key must be 16 hex digits" type="text" id="cbind_key" value="?">';
	is +=' <button type="button" title="Get EEP BindKey" onclick="getBKey();">Get EEP BindKey</button>';
	is +=' <button type="button" title="Set new EEP BindKey" onclick="setBKey();">Set EEP BindKey</button><br>';
	is += '<input size="6" maxlength="6" type="text" title="000000..999999, 6 decimal digits, 000000 - PinCode Disable. Warning: If the PinCode is forgotten - only a hardware flasher!" id="pincode" value="000000"> <button title="Warning: If the PinCode is forgotten - only a hardware flasher!" type="button" onclick="sendPinCode();">!Set PinCode!</button><br>';
	pincode.enable = true;
	is += '<br><button type="button" onclick="sendCustomSetting(&quot;01&quot;);">Get device Name</button> <input size="10" maxlength="10" type="text" title="Device Name: 1..10 chars" id="dev_name" value=""> <button type="button" title="Set New Name" onclick="sendDevName();">Set New Name</button> <button title="Clean Name: DEV_xxxx" type="button" onclick="CleanDevName();">Set default Name</button><br><br>';
	dnm.enable = true;
	is +='Device MAC [+ 2 Rand]:<br><button type="button" title="Get MAC" onclick="sendCustomSetting(&quot;10&quot;);">Get MAC</button> <input size="40" maxlength="16" type="text" id="mi_mac" title="Must be 6 hex MAC digits [+ 2 hex RandMAC digits]!" value="?">';
	is +=' <button type="button" title="Set Custom MAC. Warning: If the pin code is set, restart all Soft & Hard for the next connection!" onclick="sendMAC();">!Set MAC!</button> <button type="button" title="Clean MAC - Set Standart Random MAC: A4C138******. Warning: If the pin code is set, restart all Soft & Hard for the next connection!" onclick="CleanMAC();">!Clean MAC!</button><br>';
	$("custcfg").innerHTML = is;
	$("cfg_flg_adv_type").value = cfg.flg&3;
	$("adv_flags").checked = (cfg.flg2&0x10) != 0;
	$("bt5_flags").checked = (cfg.flg2&0x20) != 0;
	$("longrange_flags").checked = (cfg.flg2&0x40) != 0;
	$("cfg_flg_tx_meas").checked = (cfg.flg&64) != 0;
	if(cfg.ver >= 0x48)
		$("cfg_flg_lp_meas").checked = (cfg.flg&128) != 0;
	$("cfg_adv_crypto").checked = (cfg.flg2&0x08) != 0;
	$("cfg_av_meas_mem").value = String(cfg.av_meas_mem);
	$("cfg_av_meas_mem").onchange = function() {InfoIntervals();};
	if(cfg.ver < 0x47) {
		$("cfg_tmp_off").value = String((cfg.temp_offset / 10.0).toFixed(1));
		$("cfg_hm_off").value = String((cfg.humi_offset / 10.0).toFixed(1));
	}
	$("cfg_adv_int").value = String((cfg.advertising_interval * 62.5).toFixed(1));
	$("cfg_adv_int").onchange = function() {InfoIntervals();};
	$("cfg_meas_int").value = String(cfg.measure_interval);
	$("cfg_meas_int").onchange = function() {InfoIntervals();};
	$("cfg_rf_tx").value = String(cfg.rf_tx_power);
	$("cfg_con_lat").value = String((cfg.connect_latency + 1) * 20);
  }
	InfoIntervals();
	cfg.enable = true;
 } else
	$("custcfg").innerHTML = '<hr><br><br>Unsupported device software version! Custom ATC version >= 1.0!<br><br>';
}
function hex(number, len) {
	var str = (number.toString(16)).toUpperCase();
	while (str.length < len) str = '0' + str;
	return str;
}
function SendCustomConfig() {
  if(hwver_id < 15) {
	if(hwver_id != 9) {
		cfg.flg = ($("cfg_flg_adv_type").value & 3)+
		(($("cfg_flg_comfort").checked) ? 4 : 0) +
		(($("cfg_flg_blinking").checked) ? 8 : 0) +
		(($("cfg_flg_cf").value != 0) ? 16 : 0) +
		(($("cfg_flg_show_batt").checked) ? 32 : 0) +
		(($("cfg_flg_tx_meas").checked) ? 64 : 0) +
		(($("cfg_flg_lp_meas").checked) ? 128 : 0);
		cfg.flg2 = (parseInt($("cfg_smiley").value) & 7);
		if(cfg.ver == 0x19)
			cfg.flg2 += (($("cfg_flg2_memo").checked) ? 8 : 0);
		if(cfg.ver >= 0x22)
			cfg.flg2 += (($("cfg_adv_crypto").checked) ? 0x08 : 0);
		if(cfg.ver >= 0x30)
			cfg.flg2 += (($("adv_flags").checked )? 0x10 : 0);
		if(cfg.ver >= 0x36) {
			cfg.flg2 += (($("bt5_flags").checked) ? 0x20 : 0);
			if(cfg.ver >= 0x42) {
				cfg.flg2 += (($("longrange_flags").checked) ? 0x40 : 0);
				if(cfg.ver >= 0x43)
					cfg.flg2 += (($("cfg_scr_off").checked) ? 0x80 : 0);
			} else if(cfg.ver < 0x40)
				cfg.flg2 += (($("csa2_flags").checked) ? 0x40 : 0);
		}
		cfg.lcd_tint = Math.round(parseFloat($("cfg_lcd_tint").value) / 0.05);
		if(cfg.lcd_tint < 10) cfg.lcd_tint = 10;
		else if(cfg.lcd_tint > 255) cfg.lcd_tint = 255;
	} else {
		cfg.flg = ($("cfg_flg_adv_type").value & 3)+
		(($("cfg_flg_comfort").checked) ? 4 : 0) +
		(($("cfg_flg_x100").checked != 0) ? 8 : 0) +
		(($("cfg_flg_cf").value != 0) ? 16 : 0) +
		(($("cfg_flg_am_pm").checked) ? 32 : 0) +
		(($("cfg_flg_tx_meas").checked) ? 64 : 0) +
		(($("cfg_flg_lp_meas").checked) ? 128 : 0);
		cfg.flg2 = (parseInt($("cfg_scr_type").value) & 7);
		cfg.flg2 += (($("cfg_adv_crypto").checked) ? 0x08 : 0);
		cfg.flg2 += (($("adv_flags").checked )? 0x10 : 0);
		cfg.flg2 += (($("bt5_flags").checked) ? 0x20 : 0);
		cfg.flg2 += (($("longrange_flags").checked) ? 0x40 : 0);
		if(cfg.ver >= 0x43)
			cfg.flg2 += (($("cfg_scr_off").checked) ? 0x80 : 0);
	}
 } else {
		cfg.flg = (cfg.flg & 0xbc) + ($("cfg_flg_adv_type").value & 3)+
		(($("cfg_flg_tx_meas").checked) ? 64 : 0);
		if(cfg.ver >= 0x48)
			cfg.flg = (cfg.flg & 0x7f) + (($("cfg_flg_lp_meas").checked) ? 128 : 0)
		cfg.flg2 = cfg.flg2 & 0x87;
		cfg.flg2 += (($("cfg_adv_crypto").checked) ? 0x08 : 0);
		cfg.flg2 += (($("adv_flags").checked )? 0x10 : 0);
		cfg.flg2 += (($("bt5_flags").checked) ? 0x20 : 0);
		cfg.flg2 += (($("longrange_flags").checked) ? 0x40 : 0);
 }
	if(cfg.ver >= 0x20)	cfg.av_meas_mem = parseInt($("cfg_av_meas_mem").value);
	if(cfg.ver < 0x47) {
		cfg.temp_offset = Math.round(10.0 * parseFloat($("cfg_tmp_off").value));
		if(cfg.temp_offset < -127) cfg.temp_offset = -127;
		else if(cfg.temp_offset > 127) cfg.temp_offset = 127;
		cfg.humi_offset = Math.round(10.0 * parseFloat($("cfg_hm_off").value));
		if(cfg.humi_offset < -127) cfg.humi_offset = -127;
		else if(cfg.humi_offset > 127) cfg.humi_offset = 127;
	}
	cfg.advertising_interval = Math.round(parseFloat($("cfg_adv_int").value) / 62.5)
	if(cfg.advertising_interval < 1) cfg.advertising_interval = 1;
	else if(cfg.advertising_interval > 160) cfg.advertising_interval = 160;
	cfg.measure_interval = parseInt($("cfg_meas_int").value);
	if(cfg.measure_interval < 1) cfg.measure_interval = 1;
	else if(cfg.measure_interval > 25) cfg.measure_interval = 25;
	cfg.rf_tx_power = parseInt($("cfg_rf_tx").value);
	if(cfg.rf_tx_power&0x80) { /*VANT*/
		if(cfg.rf_tx_power > 191) cfg.rf_tx_power = 191;
		else if(cfg.rf_tx_power < 130) cfg.rf_tx_power = 130;
	} else { /*VBAT*/
		if(cfg.rf_tx_power < 23) cfg.rf_tx_power = 23;
		else if(cfg.rf_tx_power > 63) cfg.rf_tx_power = 63;
	}
	cfg.connect_latency = Math.round((parseFloat($("cfg_con_lat").value) / 20.0) - 1);
	if(cfg.connect_latency < 0) cfg.connect_latency = 0;
	else {
	  if(cfg.ver > 0x40)
		  if(cfg.connect_latency > 49) cfg.connect_latency = 49;
	  else
		  if(cfg.connect_latency > 200) cfg.connect_latency = 200;
	}
	if(cfg.ver < 0x20) {
		let s = 'New custom config: ['+cfg.flg+', '+cfg.flg2+', '+cfg.temp_offset+', '+cfg.humi_offset+', '+cfg.advertising_interval+', '+cfg.measure_interval+', '+cfg.rf_tx_power+', '+cfg.connect_latency+', '+cfg.lcd_tint+']';
		addAlog(s);
		sendCustomSetting('55'+hex(cfg.flg,2)+hex(cfg.flg2,2)+hex(cfg.temp_offset&0xff,2)+hex(cfg.humi_offset&0xff,2)+hex(cfg.advertising_interval,2)+hex(cfg.measure_interval,2)+hex(cfg.rf_tx_power,2)+hex(cfg.connect_latency,2)+hex(cfg.lcd_tint,2));
	} else {
		let s = 'New custom config: ['+cfg.flg+', '+cfg.flg2+', '+cfg.temp_offset+', '+cfg.humi_offset+', '+cfg.advertising_interval+', '+cfg.measure_interval+', '+cfg.rf_tx_power+', '+cfg.connect_latency+', '+cfg.lcd_tint+', '+cfg.hver+', '+cfg.av_meas_mem+']';
		addAlog(s);
		sendCustomSetting('55'+hex(cfg.flg,2)+hex(cfg.flg2,2)+hex(cfg.temp_offset&0xff,2)+hex(cfg.humi_offset&0xff,2)+hex(cfg.advertising_interval,2)+hex(cfg.measure_interval,2)+hex(cfg.rf_tx_power,2)+hex(cfg.connect_latency,2)+hex(cfg.lcd_tint,2)+hex(cfg.hver,2)+hex(cfg.av_meas_mem,2));
	}
	$("custcfg").innerHTML = '<hr><button type="button" onclick="sendCustomSetting(&quot;55&quot;);">Get Config</button><br>Send commands to custom firmware:<br><input type="text" id="cmdTXT" value=""><button type="button" onclick="sendCustomSetting($(&quot;cmdTXT&quot;).value,settingsCharacteristics);">Send</button><br>';
}
/** @fileOverview Javascript cryptography implementation.
 *
 * Crush to remove comments, shorten variable names and
 * generally reduce transmission size.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

"use strict";
/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */
/*global document, window, escape, unescape, module, require, Uint32Array */

/**
 * The Stanford Javascript Crypto Library, top-level namespace.
 * @namespace
 */
var sjcl = {
  /**
   * Symmetric ciphers.
   * @namespace
   */
  cipher: {},

  /**
   * Hash functions.  Right now only SHA256 is implemented.
   * @namespace
   */
  hash: {},

  /**
   * Key exchange functions.  Right now only SRP is implemented.
   * @namespace
   */
  keyexchange: {},
  
  /**
   * Cipher modes of operation.
   * @namespace
   */
  mode: {},

  /**
   * Miscellaneous.  HMAC and PBKDF2.
   * @namespace
   */
  misc: {},
  
  /**
   * Bit array encoders and decoders.
   * @namespace
   *
   * @description
   * The members of this namespace are functions which translate between
   * SJCL's bitArrays and other objects (usually strings).  Because it
   * isn't always clear which direction is encoding and which is decoding,
   * the method names are "fromBits" and "toBits".
   */
  codec: {},
  
  /**
   * Exceptions.
   * @namespace
   */
  exception: {
    /**
     * Ciphertext is corrupt.
     * @constructor
     */
    corrupt: function(message) {
      this.toString = function() { return "CORRUPT: "+this.message; };
      this.message = message;
    },
    
    /**
     * Invalid parameter.
     * @constructor
     */
    invalid: function(message) {
      this.toString = function() { return "INVALID: "+this.message; };
      this.message = message;
    },
    
    /**
     * Bug or missing feature in SJCL.
     * @constructor
     */
    bug: function(message) {
      this.toString = function() { return "BUG: "+this.message; };
      this.message = message;
    },

    /**
     * Something isn't ready.
     * @constructor
     */
    notReady: function(message) {
      this.toString = function() { return "NOT READY: "+this.message; };
      this.message = message;
    }
  }
};
/** @fileOverview Low-level AES implementation.
 *
 * This file contains a low-level implementation of AES, optimized for
 * size and for efficiency on several browsers.  It is based on
 * OpenSSL's aes_core.c, a public-domain implementation by Vincent
 * Rijmen, Antoon Bosselaers and Paulo Barreto.
 *
 * An older version of this implementation is available in the public
 * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,
 * Stanford University 2008-2010 and BSD-licensed for liability
 * reasons.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Schedule out an AES key for both encryption and decryption.  This
 * is a low-level class.  Use a cipher mode to do bulk encryption.
 *
 * @constructor
 * @param {Array} key The key as an array of 4, 6 or 8 words.
 */
sjcl.cipher.aes = function (key) {
  if (!this._tables[0][0][0]) {
    this._precompute();
  }
  
  var i, j, tmp,
    encKey, decKey,
    sbox = this._tables[0][4], decTable = this._tables[1],
    keyLen = key.length, rcon = 1;
  
  if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
    throw new sjcl.exception.invalid("invalid aes key size");
  }
  
  this._key = [encKey = key.slice(0), decKey = []];
  
  // schedule encryption keys
  for (i = keyLen; i < 4 * keyLen + 28; i++) {
    tmp = encKey[i-1];
    
    // apply sbox
    if (i%keyLen === 0 || (keyLen === 8 && i%keyLen === 4)) {
      tmp = sbox[tmp>>>24]<<24 ^ sbox[tmp>>16&255]<<16 ^ sbox[tmp>>8&255]<<8 ^ sbox[tmp&255];
      
      // shift rows and add rcon
      if (i%keyLen === 0) {
        tmp = tmp<<8 ^ tmp>>>24 ^ rcon<<24;
        rcon = rcon<<1 ^ (rcon>>7)*283;
      }
    }
    
    encKey[i] = encKey[i-keyLen] ^ tmp;
  }
  
  // schedule decryption keys
  for (j = 0; i; j++, i--) {
    tmp = encKey[j&3 ? i : i - 4];
    if (i<=4 || j<4) {
      decKey[j] = tmp;
    } else {
      decKey[j] = decTable[0][sbox[tmp>>>24      ]] ^
                  decTable[1][sbox[tmp>>16  & 255]] ^
                  decTable[2][sbox[tmp>>8   & 255]] ^
                  decTable[3][sbox[tmp      & 255]];
    }
  }
};

sjcl.cipher.aes.prototype = {
  // public
  /* Something like this might appear here eventually
  name: "AES",
  blockSize: 4,
  keySizes: [4,6,8],
  */
  
  /**
   * Encrypt an array of 4 big-endian words.
   * @param {Array} data The plaintext.
   * @return {Array} The ciphertext.
   */
  encrypt:function (data) { return this._crypt(data,0); },
  
  /**
   * Decrypt an array of 4 big-endian words.
   * @param {Array} data The ciphertext.
   * @return {Array} The plaintext.
   */
  decrypt:function (data) { return this._crypt(data,1); },
  
  /**
   * The expanded S-box and inverse S-box tables.  These will be computed
   * on the client so that we don't have to send them down the wire.
   *
   * There are two tables, _tables[0] is for encryption and
   * _tables[1] is for decryption.
   *
   * The first 4 sub-tables are the expanded S-box with MixColumns.  The
   * last (_tables[01][4]) is the S-box itself.
   *
   * @private
   */
  _tables: [[[],[],[],[],[]],[[],[],[],[],[]]],

  /**
   * Expand the S-box tables.
   *
   * @private
   */
  _precompute: function () {
   var encTable = this._tables[0], decTable = this._tables[1],
       sbox = encTable[4], sboxInv = decTable[4],
       i, x, xInv, d=[], th=[], x2, x4, x8, s, tEnc, tDec;

    // Compute double and third tables
   for (i = 0; i < 256; i++) {
     th[( d[i] = i<<1 ^ (i>>7)*283 )^i]=i;
   }
   
   for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
     // Compute sbox
     s = xInv ^ xInv<<1 ^ xInv<<2 ^ xInv<<3 ^ xInv<<4;
     s = s>>8 ^ s&255 ^ 99;
     sbox[x] = s;
     sboxInv[s] = x;
     
     // Compute MixColumns
     x8 = d[x4 = d[x2 = d[x]]];
     tDec = x8*0x1010101 ^ x4*0x10001 ^ x2*0x101 ^ x*0x1010100;
     tEnc = d[s]*0x101 ^ s*0x1010100;
     
     for (i = 0; i < 4; i++) {
       encTable[i][x] = tEnc = tEnc<<24 ^ tEnc>>>8;
       decTable[i][s] = tDec = tDec<<24 ^ tDec>>>8;
     }
   }
   
   // Compactify.  Considerable speedup on Firefox.
   for (i = 0; i < 5; i++) {
     encTable[i] = encTable[i].slice(0);
     decTable[i] = decTable[i].slice(0);
   }
  },
  
  /**
   * Encryption and decryption core.
   * @param {Array} input Four words to be encrypted or decrypted.
   * @param dir The direction, 0 for encrypt and 1 for decrypt.
   * @return {Array} The four encrypted or decrypted words.
   * @private
   */
  _crypt:function (input, dir) {
    if (input.length !== 4) {
      throw new sjcl.exception.invalid("invalid aes block size");
    }
    
    var key = this._key[dir],
        // state variables a,b,c,d are loaded with pre-whitened data
        a = input[0]           ^ key[0],
        b = input[dir ? 3 : 1] ^ key[1],
        c = input[2]           ^ key[2],
        d = input[dir ? 1 : 3] ^ key[3],
        a2, b2, c2,
        
        nInnerRounds = key.length/4 - 2,
        i,
        kIndex = 4,
        out = [0,0,0,0],
        table = this._tables[dir],
        
        // load up the tables
        t0    = table[0],
        t1    = table[1],
        t2    = table[2],
        t3    = table[3],
        sbox  = table[4];
 
    // Inner rounds.  Cribbed from OpenSSL.
    for (i = 0; i < nInnerRounds; i++) {
      a2 = t0[a>>>24] ^ t1[b>>16 & 255] ^ t2[c>>8 & 255] ^ t3[d & 255] ^ key[kIndex];
      b2 = t0[b>>>24] ^ t1[c>>16 & 255] ^ t2[d>>8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
      c2 = t0[c>>>24] ^ t1[d>>16 & 255] ^ t2[a>>8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
      d  = t0[d>>>24] ^ t1[a>>16 & 255] ^ t2[b>>8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
      kIndex += 4;
      a=a2; b=b2; c=c2;
    }
        
    // Last round.
    for (i = 0; i < 4; i++) {
      out[dir ? 3&-i : i] =
        sbox[a>>>24      ]<<24 ^ 
        sbox[b>>16  & 255]<<16 ^
        sbox[c>>8   & 255]<<8  ^
        sbox[d      & 255]     ^
        key[kIndex++];
      a2=a; a=b; b=c; c=d; d=a2;
    }
    
    return out;
  }
};

/** @fileOverview Arrays of bits, encoded as arrays of Numbers.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Arrays of bits, encoded as arrays of Numbers.
 * @namespace
 * @description
 * <p>
 * These objects are the currency accepted by SJCL's crypto functions.
 * </p>
 *
 * <p>
 * Most of our crypto primitives operate on arrays of 4-byte words internally,
 * but many of them can take arguments that are not a multiple of 4 bytes.
 * This library encodes arrays of bits (whose size need not be a multiple of 8
 * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an
 * array of words, 32 bits at a time.  Since the words are double-precision
 * floating point numbers, they fit some extra data.  We use this (in a private,
 * possibly-changing manner) to encode the number of bits actually  present
 * in the last word of the array.
 * </p>
 *
 * <p>
 * Because bitwise ops clear this out-of-band data, these arrays can be passed
 * to ciphers like AES which want arrays of words.
 * </p>
 */
sjcl.bitArray = {
  /**
   * Array slices in units of bits.
   * @param {bitArray} a The array to slice.
   * @param {Number} bstart The offset to the start of the slice, in bits.
   * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,
   * slice until the end of the array.
   * @return {bitArray} The requested slice.
   */
  bitSlice: function (a, bstart, bend) {
    a = sjcl.bitArray._shiftRight(a.slice(bstart/32), 32 - (bstart & 31)).slice(1);
    return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend-bstart);
  },

  /**
   * Extract a number packed into a bit array.
   * @param {bitArray} a The array to slice.
   * @param {Number} bstart The offset to the start of the slice, in bits.
   * @param {Number} blength The length of the number to extract.
   * @return {Number} The requested slice.
   */
  extract: function(a, bstart, blength) {
    // FIXME: this Math.floor is not necessary at all, but for some reason
    // seems to suppress a bug in the Chromium JIT.
    var x, sh = Math.floor((-bstart-blength) & 31);
    if ((bstart + blength - 1 ^ bstart) & -32) {
      // it crosses a boundary
      x = (a[bstart/32|0] << (32 - sh)) ^ (a[bstart/32+1|0] >>> sh);
    } else {
      // within a single word
      x = a[bstart/32|0] >>> sh;
    }
    return x & ((1<<blength) - 1);
  },

  /**
   * Concatenate two bit arrays.
   * @param {bitArray} a1 The first array.
   * @param {bitArray} a2 The second array.
   * @return {bitArray} The concatenation of a1 and a2.
   */
  concat: function (a1, a2) {
    if (a1.length === 0 || a2.length === 0) {
      return a1.concat(a2);
    }
    
    var last = a1[a1.length-1], shift = sjcl.bitArray.getPartial(last);
    if (shift === 32) {
      return a1.concat(a2);
    } else {
      return sjcl.bitArray._shiftRight(a2, shift, last|0, a1.slice(0,a1.length-1));
    }
  },

  /**
   * Find the length of an array of bits.
   * @param {bitArray} a The array.
   * @return {Number} The length of a, in bits.
   */
  bitLength: function (a) {
    var l = a.length, x;
    if (l === 0) { return 0; }
    x = a[l - 1];
    return (l-1) * 32 + sjcl.bitArray.getPartial(x);
  },

  /**
   * Truncate an array.
   * @param {bitArray} a The array.
   * @param {Number} len The length to truncate to, in bits.
   * @return {bitArray} A new array, truncated to len bits.
   */
  clamp: function (a, len) {
    if (a.length * 32 < len) { return a; }
    a = a.slice(0, Math.ceil(len / 32));
    var l = a.length;
    len = len & 31;
    if (l > 0 && len) {
      a[l-1] = sjcl.bitArray.partial(len, a[l-1] & 0x80000000 >> (len-1), 1);
    }
    return a;
  },

  /**
   * Make a partial word for a bit array.
   * @param {Number} len The number of bits in the word.
   * @param {Number} x The bits.
   * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.
   * @return {Number} The partial word.
   */
  partial: function (len, x, _end) {
    if (len === 32) { return x; }
    return (_end ? x|0 : x << (32-len)) + len * 0x10000000000;
  },

  /**
   * Get the number of bits used by a partial word.
   * @param {Number} x The partial word.
   * @return {Number} The number of bits used by the partial word.
   */
  getPartial: function (x) {
    return Math.round(x/0x10000000000) || 32;
  },

  /**
   * Compare two arrays for equality in a predictable amount of time.
   * @param {bitArray} a The first array.
   * @param {bitArray} b The second array.
   * @return {boolean} true if a == b; false otherwise.
   */
  equal: function (a, b) {
    if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {
      return false;
    }
    var x = 0, i;
    for (i=0; i<a.length; i++) {
      x |= a[i]^b[i];
    }
    return (x === 0);
  },

  /** Shift an array right.
   * @param {bitArray} a The array to shift.
   * @param {Number} shift The number of bits to shift.
   * @param {Number} [carry=0] A byte to carry in
   * @param {bitArray} [out=[]] An array to prepend to the output.
   * @private
   */
  _shiftRight: function (a, shift, carry, out) {
    var i, last2=0, shift2;
    if (out === undefined) { out = []; }
    
    for (; shift >= 32; shift -= 32) {
      out.push(carry);
      carry = 0;
    }
    if (shift === 0) {
      return out.concat(a);
    }
    
    for (i=0; i<a.length; i++) {
      out.push(carry | a[i]>>>shift);
      carry = a[i] << (32-shift);
    }
    last2 = a.length ? a[a.length-1] : 0;
    shift2 = sjcl.bitArray.getPartial(last2);
    out.push(sjcl.bitArray.partial(shift+shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(),1));
    return out;
  },
  
  /** xor a block of 4 words together.
   * @private
   */
  _xor4: function(x,y) {
    return [x[0]^y[0],x[1]^y[1],x[2]^y[2],x[3]^y[3]];
  },

  /** byteswap a word array inplace.
   * (does not handle partial words)
   * @param {sjcl.bitArray} a word array
   * @return {sjcl.bitArray} byteswapped array
   */
  byteswapM: function(a) {
    var i, v, m = 0xff00;
    for (i = 0; i < a.length; ++i) {
      v = a[i];
      a[i] = (v >>> 24) | ((v >>> 8) & m) | ((v & m) << 8) | (v << 24);
    }
    return a;
  }
};
/** @fileOverview Bit array codec implementations.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * UTF-8 strings
 * @namespace
 */
sjcl.codec.utf8String = {
  /** Convert from a bitArray to a UTF-8 string. */
  fromBits: function (arr) {
    var out = "", bl = sjcl.bitArray.bitLength(arr), i, tmp;
    for (i=0; i<bl/8; i++) {
      if ((i&3) === 0) {
        tmp = arr[i/4];
      }
      out += String.fromCharCode(tmp >>> 8 >>> 8 >>> 8);
      tmp <<= 8;
    }
    return decodeURIComponent(escape(out));
  },

  /** Convert from a UTF-8 string to a bitArray. */
  toBits: function (str) {
    str = unescape(encodeURIComponent(str));
    var out = [], i, tmp=0;
    for (i=0; i<str.length; i++) {
      tmp = tmp << 8 | str.charCodeAt(i);
      if ((i&3) === 3) {
        out.push(tmp);
        tmp = 0;
      }
    }
    if (i&3) {
      out.push(sjcl.bitArray.partial(8*(i&3), tmp));
    }
    return out;
  }
};
/** @fileOverview Bit array codec implementations.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Hexadecimal
 * @namespace
 */
sjcl.codec.hex = {
  /** Convert from a bitArray to a hex string. */
  fromBits: function (arr) {
    var out = "", i;
    for (i=0; i<arr.length; i++) {
      out += ((arr[i]|0)+0xF00000000000).toString(16).substr(4);
    }
    return out.substr(0, sjcl.bitArray.bitLength(arr)/4);//.replace(/(.{8})/g, "$1 ");
  },
  /** Convert from a hex string to a bitArray. */
  toBits: function (str) {
    var i, out=[], len;
    str = str.replace(/\s|0x/g, "");
    len = str.length;
    str = str + "00000000";
    for (i=0; i<str.length; i+=8) {
      out.push(parseInt(str.substr(i,8),16)^0);
    }
    return sjcl.bitArray.clamp(out, len*4);
  }
};

/** @fileOverview Bit array codec implementations.
 *
 * @author Nils Kenneweg
 */

/**
 * Base32 encoding/decoding
 * @namespace
 */
sjcl.codec.base32 = {
  /** The base32 alphabet.
   * @private
   */
  _chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  _hexChars: "0123456789ABCDEFGHIJKLMNOPQRSTUV",

  /* bits in an array */
  BITS: 32,
  /* base to encode at (2^x) */
  BASE: 5,
  /* bits - base */
  REMAINING: 27,

  /** Convert from a bitArray to a base32 string. */
  fromBits: function (arr, _noEquals, _hex) {
    var BITS = sjcl.codec.base32.BITS, BASE = sjcl.codec.base32.BASE, REMAINING = sjcl.codec.base32.REMAINING;
    var out = "", i, bits=0, c = sjcl.codec.base32._chars, ta=0, bl = sjcl.bitArray.bitLength(arr);

    if (_hex) {
      c = sjcl.codec.base32._hexChars;
    }

    for (i=0; out.length * BASE < bl; ) {
      out += c.charAt((ta ^ arr[i]>>>bits) >>> REMAINING);
      if (bits < BASE) {
        ta = arr[i] << (BASE-bits);
        bits += REMAINING;
        i++;
      } else {
        ta <<= BASE;
        bits -= BASE;
      }
    }
    while ((out.length & 7) && !_noEquals) { out += "="; }

    return out;
  },

  /** Convert from a base32 string to a bitArray */
  toBits: function(str, _hex) {
    str = str.replace(/\s|=/g,'').toUpperCase();
    var BITS = sjcl.codec.base32.BITS, BASE = sjcl.codec.base32.BASE, REMAINING = sjcl.codec.base32.REMAINING;
    var out = [], i, bits=0, c = sjcl.codec.base32._chars, ta=0, x, format="base32";

    if (_hex) {
      c = sjcl.codec.base32._hexChars;
      format = "base32hex";
    }

    for (i=0; i<str.length; i++) {
      x = c.indexOf(str.charAt(i));
      if (x < 0) {
        // Invalid character, try hex format
        if (!_hex) {
          try {
            return sjcl.codec.base32hex.toBits(str);
          }
          catch (e) {}
        }
        throw new sjcl.exception.invalid("this isn't " + format + "!");
      }
      if (bits > REMAINING) {
        bits -= REMAINING;
        out.push(ta ^ x>>>bits);
        ta  = x << (BITS-bits);
      } else {
        bits += BASE;
        ta ^= x << (BITS-bits);
      }
    }
    if (bits&56) {
      out.push(sjcl.bitArray.partial(bits&56, ta, 1));
    }
    return out;
  }
};

sjcl.codec.base32hex = {
  fromBits: function (arr, _noEquals) { return sjcl.codec.base32.fromBits(arr,_noEquals,1); },
  toBits: function (str) { return sjcl.codec.base32.toBits(str,1); }
};
/** @fileOverview Bit array codec implementations.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Base64 encoding/decoding 
 * @namespace
 */
sjcl.codec.base64 = {
  /** The base64 alphabet.
   * @private
   */
  _chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  
  /** Convert from a bitArray to a base64 string. */
  fromBits: function (arr, _noEquals, _url) {
    var out = "", i, bits=0, c = sjcl.codec.base64._chars, ta=0, bl = sjcl.bitArray.bitLength(arr);
    if (_url) {
      c = c.substr(0,62) + '-_';
    }
    for (i=0; out.length * 6 < bl; ) {
      out += c.charAt((ta ^ arr[i]>>>bits) >>> 26);
      if (bits < 6) {
        ta = arr[i] << (6-bits);
        bits += 26;
        i++;
      } else {
        ta <<= 6;
        bits -= 6;
      }
    }
    while ((out.length & 3) && !_noEquals) { out += "="; }
    return out;
  },
  
  /** Convert from a base64 string to a bitArray */
  toBits: function(str, _url) {
    str = str.replace(/\s|=/g,'');
    var out = [], i, bits=0, c = sjcl.codec.base64._chars, ta=0, x;
    if (_url) {
      c = c.substr(0,62) + '-_';
    }
    for (i=0; i<str.length; i++) {
      x = c.indexOf(str.charAt(i));
      if (x < 0) {
        throw new sjcl.exception.invalid("this isn't base64!");
      }
      if (bits > 26) {
        bits -= 26;
        out.push(ta ^ x>>>bits);
        ta  = x << (32-bits);
      } else {
        bits += 6;
        ta ^= x << (32-bits);
      }
    }
    if (bits&56) {
      out.push(sjcl.bitArray.partial(bits&56, ta, 1));
    }
    return out;
  }
};

sjcl.codec.base64url = {
  fromBits: function (arr) { return sjcl.codec.base64.fromBits(arr,1,1); },
  toBits: function (str) { return sjcl.codec.base64.toBits(str,1); }
};
/** @fileOverview Javascript SHA-256 implementation.
 *
 * An older version of this implementation is available in the public
 * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,
 * Stanford University 2008-2010 and BSD-licensed for liability
 * reasons.
 *
 * Special thanks to Aldo Cortesi for pointing out several bugs in
 * this code.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Context for a SHA-256 operation in progress.
 * @constructor
 */
sjcl.hash.sha256 = function (hash) {
  if (!this._key[0]) { this._precompute(); }
  if (hash) {
    this._h = hash._h.slice(0);
    this._buffer = hash._buffer.slice(0);
    this._length = hash._length;
  } else {
    this.reset();
  }
};

/**
 * Hash a string or an array of words.
 * @static
 * @param {bitArray|String} data the data to hash.
 * @return {bitArray} The hash value, an array of 16 big-endian words.
 */
sjcl.hash.sha256.hash = function (data) {
  return (new sjcl.hash.sha256()).update(data).finalize();
};

sjcl.hash.sha256.prototype = {
  /**
   * The hash's block size, in bits.
   * @constant
   */
  blockSize: 512,
   
  /**
   * Reset the hash state.
   * @return this
   */
  reset:function () {
    this._h = this._init.slice(0);
    this._buffer = [];
    this._length = 0;
    return this;
  },
  
  /**
   * Input several words to the hash.
   * @param {bitArray|String} data the data to hash.
   * @return this
   */
  update: function (data) {
    if (typeof data === "string") {
      data = sjcl.codec.utf8String.toBits(data);
    }
    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),
        ol = this._length,
        nl = this._length = ol + sjcl.bitArray.bitLength(data);
    if (nl > 9007199254740991){
      throw new sjcl.exception.invalid("Cannot hash more than 2^53 - 1 bits");
    }

    if (typeof Uint32Array !== 'undefined') {
	var c = new Uint32Array(b);
    	var j = 0;
    	for (i = 512+ol - ((512+ol) & 511); i <= nl; i+= 512) {
      	    this._block(c.subarray(16 * j, 16 * (j+1)));
      	    j += 1;
    	}
    	b.splice(0, 16 * j);
    } else {
	for (i = 512+ol - ((512+ol) & 511); i <= nl; i+= 512) {
      	    this._block(b.splice(0,16));
      	}
    }
    return this;
  },
  
  /**
   * Complete hashing and output the hash value.
   * @return {bitArray} The hash value, an array of 8 big-endian words.
   */
  finalize:function () {
    var i, b = this._buffer, h = this._h;

    // Round out and push the buffer
    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);
    
    // Round out the buffer to a multiple of 16 words, less the 2 length words.
    for (i = b.length + 2; i & 15; i++) {
      b.push(0);
    }
    
    // append the length
    b.push(Math.floor(this._length / 0x100000000));
    b.push(this._length | 0);

    while (b.length) {
      this._block(b.splice(0,16));
    }

    this.reset();
    return h;
  },

  /**
   * The SHA-256 initialization vector, to be precomputed.
   * @private
   */
  _init:[],
  /*
  _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],
  */
  
  /**
   * The SHA-256 hash key, to be precomputed.
   * @private
   */
  _key:[],
  /*
  _key:
    [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
     0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
     0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
     0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
     0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
     0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
     0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],
  */


  /**
   * Function to precompute _init and _key.
   * @private
   */
  _precompute: function () {
    var i = 0, prime = 2, factor, isPrime;

    function frac(x) { return (x-Math.floor(x)) * 0x100000000 | 0; }

    for (; i<64; prime++) {
      isPrime = true;
      for (factor=2; factor*factor <= prime; factor++) {
        if (prime % factor === 0) {
          isPrime = false;
          break;
        }
      }
      if (isPrime) {
        if (i<8) {
          this._init[i] = frac(Math.pow(prime, 1/2));
        }
        this._key[i] = frac(Math.pow(prime, 1/3));
        i++;
      }
    }
  },
  
  /**
   * Perform one cycle of SHA-256.
   * @param {Uint32Array|bitArray} w one block of words.
   * @private
   */
  _block:function (w) {  
    var i, tmp, a, b,
      h = this._h,
      k = this._key,
      h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3],
      h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];

    /* Rationale for placement of |0 :
     * If a value can overflow is original 32 bits by a factor of more than a few
     * million (2^23 ish), there is a possibility that it might overflow the
     * 53-bit mantissa and lose precision.
     *
     * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that
     * propagates around the loop, and on the hash state h[].  I don't believe
     * that the clamps on h4 and on h0 are strictly necessary, but it's close
     * (for h4 anyway), and better safe than sorry.
     *
     * The clamps on h[] are necessary for the output to be correct even in the
     * common case and for short inputs.
     */
    for (i=0; i<64; i++) {
      // load up the input word for this round
      if (i<16) {
        tmp = w[i];
      } else {
        a   = w[(i+1 ) & 15];
        b   = w[(i+14) & 15];
        tmp = w[i&15] = ((a>>>7  ^ a>>>18 ^ a>>>3  ^ a<<25 ^ a<<14) + 
                         (b>>>17 ^ b>>>19 ^ b>>>10 ^ b<<15 ^ b<<13) +
                         w[i&15] + w[(i+9) & 15]) | 0;
      }
      
      tmp = (tmp + h7 + (h4>>>6 ^ h4>>>11 ^ h4>>>25 ^ h4<<26 ^ h4<<21 ^ h4<<7) +  (h6 ^ h4&(h5^h6)) + k[i]); // | 0;
      
      // shift register
      h7 = h6; h6 = h5; h5 = h4;
      h4 = h3 + tmp | 0;
      h3 = h2; h2 = h1; h1 = h0;

      h0 = (tmp +  ((h1&h2) ^ (h3&(h1^h2))) + (h1>>>2 ^ h1>>>13 ^ h1>>>22 ^ h1<<30 ^ h1<<19 ^ h1<<10)) | 0;
    }

    h[0] = h[0]+h0 | 0;
    h[1] = h[1]+h1 | 0;
    h[2] = h[2]+h2 | 0;
    h[3] = h[3]+h3 | 0;
    h[4] = h[4]+h4 | 0;
    h[5] = h[5]+h5 | 0;
    h[6] = h[6]+h6 | 0;
    h[7] = h[7]+h7 | 0;
  }
};


/** @fileOverview CCM mode implementation.
 *
 * Special thanks to Roy Nicholson for pointing out a bug in our
 * implementation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * CTR mode with CBC MAC.
 * @namespace
 */
sjcl.mode.ccm = {
  /** The name of the mode.
   * @constant
   */
  name: "ccm",
  
  _progressListeners: [],

  listenProgress: function (cb) {
    sjcl.mode.ccm._progressListeners.push(cb);
  },

  unListenProgress: function (cb) {
    var index = sjcl.mode.ccm._progressListeners.indexOf(cb);
    if (index > -1) {
      sjcl.mode.ccm._progressListeners.splice(index, 1);
    }
  },

  _callProgressListener: function (val) {
    var p = sjcl.mode.ccm._progressListeners.slice(), i;

    for (i = 0; i < p.length; i += 1) {
      p[i](val);
    }
  },

  /** Encrypt in CCM mode.
   * @static
   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.
   * @param {bitArray} plaintext The plaintext data.
   * @param {bitArray} iv The initialization value.
   * @param {bitArray} [adata=[]] The authenticated data.
   * @param {Number} [tlen=64] the desired tag length, in bits.
   * @return {bitArray} The encrypted data, an array of bytes.
   */
  encrypt: function(prf, plaintext, iv, adata, tlen) {
    var L, out = plaintext.slice(0), tag, w=sjcl.bitArray, ivl = w.bitLength(iv) / 8, ol = w.bitLength(out) / 8;
    tlen = tlen || 32;
    adata = adata || [];
    
    if (ivl < 7) {
      throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
    }
    
    // compute the length of the length
    for (L=2; L<4 && ol >>> 8*L; L++) {}
    if (L < 15 - ivl) { L = 15-ivl; }
    iv = w.clamp(iv,8*(15-L));
    
    // compute the tag
    tag = sjcl.mode.ccm._computeTag(prf, plaintext, iv, adata, tlen, L);
    
    // encrypt
    out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);
    
    return w.concat(out.data, out.tag);
  },
  
  /** Decrypt in CCM mode.
   * @static
   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.
   * @param {bitArray} ciphertext The ciphertext data.
   * @param {bitArray} iv The initialization value.
   * @param {bitArray} [adata=[]] adata The authenticated data.
   * @param {Number} [tlen=64] tlen the desired tag length, in bits.
   * @return {bitArray} The decrypted data.
   */
  decrypt: function(prf, ciphertext, iv, adata, tlen) {
    tlen = tlen || 64;
    adata = adata || [];
    var L,
        w=sjcl.bitArray,
        ivl = w.bitLength(iv) / 8,
        ol = w.bitLength(ciphertext), 
        out = w.clamp(ciphertext, ol - tlen),
        tag = w.bitSlice(ciphertext, ol - tlen), tag2;
    

    ol = (ol - tlen) / 8;
        
    if (ivl < 7) {
      throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
    }
    
    // compute the length of the length
    for (L=2; L<4 && ol >>> 8*L; L++) {}
    if (L < 15 - ivl) { L = 15-ivl; }
    iv = w.clamp(iv,8*(15-L));
    
    // decrypt
    out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);
    
    // check the tag
    tag2 = sjcl.mode.ccm._computeTag(prf, out.data, iv, adata, tlen, L);
    if (!w.equal(out.tag, tag2)) {
      throw new sjcl.exception.corrupt("ccm: tag doesn't match");
    }
    
    return out.data;
  },

  _macAdditionalData: function (prf, adata, iv, tlen, ol, L) {
    var mac, tmp, i, macData = [], w=sjcl.bitArray, xor = w._xor4;

    // mac the flags
    mac = [w.partial(8, (adata.length ? 1<<6 : 0) | (tlen-2) << 2 | L-1)];

    // mac the iv and length
    mac = w.concat(mac, iv);
    mac[3] |= ol;
    mac = prf.encrypt(mac);
  
    if (adata.length) {
      // mac the associated data.  start with its length...
      tmp = w.bitLength(adata)/8;
      if (tmp <= 0xFEFF) {
        macData = [w.partial(16, tmp)];
      } else if (tmp <= 0xFFFFFFFF) {
        macData = w.concat([w.partial(16,0xFFFE)], [tmp]);
      } // else ...
    
      // mac the data itself
      macData = w.concat(macData, adata);
      for (i=0; i<macData.length; i += 4) {
        mac = prf.encrypt(xor(mac, macData.slice(i,i+4).concat([0,0,0])));
      }
    }

    return mac;
  },

  /* Compute the (unencrypted) authentication tag, according to the CCM specification
   * @param {Object} prf The pseudorandom function.
   * @param {bitArray} plaintext The plaintext data.
   * @param {bitArray} iv The initialization value.
   * @param {bitArray} adata The authenticated data.
   * @param {Number} tlen the desired tag length, in bits.
   * @return {bitArray} The tag, but not yet encrypted.
   * @private
   */
  _computeTag: function(prf, plaintext, iv, adata, tlen, L) {
    // compute B[0]
    var mac, i, w=sjcl.bitArray, xor = w._xor4;

    tlen /= 8;
  
    // check tag length and message length
    if (tlen % 2 || tlen < 4 || tlen > 16) {
      throw new sjcl.exception.invalid("ccm: invalid tag length");
    }
  
    if (adata.length > 0xFFFFFFFF || plaintext.length > 0xFFFFFFFF) {
      // I don't want to deal with extracting high words from doubles.
      throw new sjcl.exception.bug("ccm: can't deal with 4GiB or more data");
    }

    mac = sjcl.mode.ccm._macAdditionalData(prf, adata, iv, tlen, w.bitLength(plaintext)/8, L);

    // mac the plaintext
    for (i=0; i<plaintext.length; i+=4) {
      mac = prf.encrypt(xor(mac, plaintext.slice(i,i+4).concat([0,0,0])));
    }

    return w.clamp(mac, tlen * 8);
  },

  /** CCM CTR mode.
   * Encrypt or decrypt data and tag with the prf in CCM-style CTR mode.
   * May mutate its arguments.
   * @param {Object} prf The PRF.
   * @param {bitArray} data The data to be encrypted or decrypted.
   * @param {bitArray} iv The initialization vector.
   * @param {bitArray} tag The authentication tag.
   * @param {Number} tlen The length of th etag, in bits.
   * @param {Number} L The CCM L value.
   * @return {Object} An object with data and tag, the en/decryption of data and tag values.
   * @private
   */
  _ctrMode: function(prf, data, iv, tag, tlen, L) {
    var enc, i, w=sjcl.bitArray, xor = w._xor4, ctr, l = data.length, bl=w.bitLength(data), n = l/50, p = n;

    // start the ctr
    ctr = w.concat([w.partial(8,L-1)],iv).concat([0,0,0]).slice(0,4);
    
    // en/decrypt the tag
    tag = w.bitSlice(xor(tag,prf.encrypt(ctr)), 0, tlen);
  
    // en/decrypt the data
    if (!l) { return {tag:tag, data:[]}; }
    
    for (i=0; i<l; i+=4) {
      if (i > n) {
        sjcl.mode.ccm._callProgressListener(i/l);
        n += p;
      }
      ctr[3]++;
      enc = prf.encrypt(ctr);
      data[i]   ^= enc[0];
      data[i+1] ^= enc[1];
      data[i+2] ^= enc[2];
      data[i+3] ^= enc[3];
    }
    return { tag:tag, data:w.clamp(data,bl) };
  }
};
/** @fileOverview OCB 2.0 implementation
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** 
 * Phil Rogaway's Offset CodeBook mode, version 2.0.
 * May be covered by US and international patents.
 *
 * @namespace
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */
sjcl.mode.ocb2 = {
  /** The name of the mode.
   * @constant
   */
  name: "ocb2",
  
  /** Encrypt in OCB mode, version 2.0.
   * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.
   * @param {bitArray} plaintext The plaintext data.
   * @param {bitArray} iv The initialization value.
   * @param {bitArray} [adata=[]] The authenticated data.
   * @param {Number} [tlen=64] the desired tag length, in bits.
   * @param {boolean} [premac=false] true if the authentication data is pre-macced with PMAC.
   * @return The encrypted data, an array of bytes.
   * @throws {sjcl.exception.invalid} if the IV isn't exactly 128 bits.
   */
  encrypt: function(prp, plaintext, iv, adata, tlen, premac) {
    if (sjcl.bitArray.bitLength(iv) !== 128) {
      throw new sjcl.exception.invalid("ocb iv must be 128 bits");
    }
    var i,
        times2 = sjcl.mode.ocb2._times2,
        w = sjcl.bitArray,
        xor = w._xor4,
        checksum = [0,0,0,0],
        delta = times2(prp.encrypt(iv)),
        bi, bl,
        output = [],
        pad;
        
    adata = adata || [];
    tlen  = tlen || 64;
  
    for (i=0; i+4 < plaintext.length; i+=4) {
      /* Encrypt a non-final block */
      bi = plaintext.slice(i,i+4);
      checksum = xor(checksum, bi);
      output = output.concat(xor(delta,prp.encrypt(xor(delta, bi))));
      delta = times2(delta);
    }
    
    /* Chop out the final block */
    bi = plaintext.slice(i);
    bl = w.bitLength(bi);
    pad = prp.encrypt(xor(delta,[0,0,0,bl]));
    bi = w.clamp(xor(bi.concat([0,0,0]),pad), bl);
    
    /* Checksum the final block, and finalize the checksum */
    checksum = xor(checksum,xor(bi.concat([0,0,0]),pad));
    checksum = prp.encrypt(xor(checksum,xor(delta,times2(delta))));
    
    /* MAC the header */
    if (adata.length) {
      checksum = xor(checksum, premac ? adata : sjcl.mode.ocb2.pmac(prp, adata));
    }
    
    return output.concat(w.concat(bi, w.clamp(checksum, tlen)));
  },
  
  /** Decrypt in OCB mode.
   * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.
   * @param {bitArray} ciphertext The ciphertext data.
   * @param {bitArray} iv The initialization value.
   * @param {bitArray} [adata=[]] The authenticated data.
   * @param {Number} [tlen=64] the desired tag length, in bits.
   * @param {boolean} [premac=false] true if the authentication data is pre-macced with PMAC.
   * @return The decrypted data, an array of bytes.
   * @throws {sjcl.exception.invalid} if the IV isn't exactly 128 bits.
   * @throws {sjcl.exception.corrupt} if if the message is corrupt.
   */
  decrypt: function(prp, ciphertext, iv, adata, tlen, premac) {
    if (sjcl.bitArray.bitLength(iv) !== 128) {
      throw new sjcl.exception.invalid("ocb iv must be 128 bits");
    }
    tlen  = tlen || 64;
    var i,
        times2 = sjcl.mode.ocb2._times2,
        w = sjcl.bitArray,
        xor = w._xor4,
        checksum = [0,0,0,0],
        delta = times2(prp.encrypt(iv)),
        bi, bl,
        len = sjcl.bitArray.bitLength(ciphertext) - tlen,
        output = [],
        pad;
        
    adata = adata || [];
  
    for (i=0; i+4 < len/32; i+=4) {
      /* Decrypt a non-final block */
      bi = xor(delta, prp.decrypt(xor(delta, ciphertext.slice(i,i+4))));
      checksum = xor(checksum, bi);
      output = output.concat(bi);
      delta = times2(delta);
    }
    
    /* Chop out and decrypt the final block */
    bl = len-i*32;
    pad = prp.encrypt(xor(delta,[0,0,0,bl]));
    bi = xor(pad, w.clamp(ciphertext.slice(i),bl).concat([0,0,0]));
    
    /* Checksum the final block, and finalize the checksum */
    checksum = xor(checksum, bi);
    checksum = prp.encrypt(xor(checksum, xor(delta, times2(delta))));
    
    /* MAC the header */
    if (adata.length) {
      checksum = xor(checksum, premac ? adata : sjcl.mode.ocb2.pmac(prp, adata));
    }
    
    if (!w.equal(w.clamp(checksum, tlen), w.bitSlice(ciphertext, len))) {
      throw new sjcl.exception.corrupt("ocb: tag doesn't match");
    }
    
    return output.concat(w.clamp(bi,bl));
  },
  
  /** PMAC authentication for OCB associated data.
   * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.
   * @param {bitArray} adata The authenticated data.
   */
  pmac: function(prp, adata) {
    var i,
        times2 = sjcl.mode.ocb2._times2,
        w = sjcl.bitArray,
        xor = w._xor4,
        checksum = [0,0,0,0],
        delta = prp.encrypt([0,0,0,0]),
        bi;
        
    delta = xor(delta,times2(times2(delta)));
 
    for (i=0; i+4<adata.length; i+=4) {
      delta = times2(delta);
      checksum = xor(checksum, prp.encrypt(xor(delta, adata.slice(i,i+4))));
    }
    
    bi = adata.slice(i);
    if (w.bitLength(bi) < 128) {
      delta = xor(delta,times2(delta));
      bi = w.concat(bi,[0x80000000|0,0,0,0]);
    }
    checksum = xor(checksum, bi);
    return prp.encrypt(xor(times2(xor(delta,times2(delta))), checksum));
  },
  
  /** Double a block of words, OCB style.
   * @private
   */
  _times2: function(x) {
    return [x[0]<<1 ^ x[1]>>>31,
            x[1]<<1 ^ x[2]>>>31,
            x[2]<<1 ^ x[3]>>>31,
            x[3]<<1 ^ (x[0]>>>31)*0x87];
  }
};
/** @fileOverview GCM mode implementation.
 *
 * @author Juho VГ¤hГ¤-Herttua
 */

/**
 * Galois/Counter mode.
 * @namespace
 */ 
sjcl.mode.gcm = {
  /**
   * The name of the mode.
   * @constant
   */
  name: "gcm",
  
  /** Encrypt in GCM mode.
   * @static
   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.
   * @param {bitArray} plaintext The plaintext data.
   * @param {bitArray} iv The initialization value.
   * @param {bitArray} [adata=[]] The authenticated data.
   * @param {Number} [tlen=128] The desired tag length, in bits.
   * @return {bitArray} The encrypted data, an array of bytes.
   */
  encrypt: function (prf, plaintext, iv, adata, tlen) {
    var out, data = plaintext.slice(0), w=sjcl.bitArray;
    tlen = tlen || 128;
    adata = adata || [];

    // encrypt and tag
    out = sjcl.mode.gcm._ctrMode(true, prf, data, adata, iv, tlen);

    return w.concat(out.data, out.tag);
  },
  
  /** Decrypt in GCM mode.
   * @static
   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.
   * @param {bitArray} ciphertext The ciphertext data.
   * @param {bitArray} iv The initialization value.
   * @param {bitArray} [adata=[]] The authenticated data.
   * @param {Number} [tlen=128] The desired tag length, in bits.
   * @return {bitArray} The decrypted data.
   */
  decrypt: function (prf, ciphertext, iv, adata, tlen) {
    var out, data = ciphertext.slice(0), tag, w=sjcl.bitArray, l=w.bitLength(data);
    tlen = tlen || 128;
    adata = adata || [];

    // Slice tag out of data
    if (tlen <= l) {
      tag = w.bitSlice(data, l-tlen);
      data = w.bitSlice(data, 0, l-tlen);
    } else {
      tag = data;
      data = [];
    }

    // decrypt and tag
    out = sjcl.mode.gcm._ctrMode(false, prf, data, adata, iv, tlen);

    if (!w.equal(out.tag, tag)) {
      throw new sjcl.exception.corrupt("gcm: tag doesn't match");
    }
    return out.data;
  },

  /* Compute the galois multiplication of X and Y
   * @private
   */
  _galoisMultiply: function (x, y) {
    var i, j, xi, Zi, Vi, lsb_Vi, w=sjcl.bitArray, xor=w._xor4;

    Zi = [0,0,0,0];
    Vi = y.slice(0);

    // Block size is 128 bits, run 128 times to get Z_128
    for (i=0; i<128; i++) {
      xi = (x[Math.floor(i/32)] & (1 << (31-i%32))) !== 0;
      if (xi) {
        // Z_i+1 = Z_i ^ V_i
        Zi = xor(Zi, Vi);
      }

      // Store the value of LSB(V_i)
      lsb_Vi = (Vi[3] & 1) !== 0;

      // V_i+1 = V_i >> 1
      for (j=3; j>0; j--) {
        Vi[j] = (Vi[j] >>> 1) | ((Vi[j-1]&1) << 31);
      }
      Vi[0] = Vi[0] >>> 1;

      // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
      if (lsb_Vi) {
        Vi[0] = Vi[0] ^ (0xe1 << 24);
      }
    }
    return Zi;
  },

  _ghash: function(H, Y0, data) {
    var Yi, i, l = data.length;

    Yi = Y0.slice(0);
    for (i=0; i<l; i+=4) {
      Yi[0] ^= 0xffffffff&data[i];
      Yi[1] ^= 0xffffffff&data[i+1];
      Yi[2] ^= 0xffffffff&data[i+2];
      Yi[3] ^= 0xffffffff&data[i+3];
      Yi = sjcl.mode.gcm._galoisMultiply(Yi, H);
    }
    return Yi;
  },

  /** GCM CTR mode.
   * Encrypt or decrypt data and tag with the prf in GCM-style CTR mode.
   * @param {Boolean} encrypt True if encrypt, false if decrypt.
   * @param {Object} prf The PRF.
   * @param {bitArray} data The data to be encrypted or decrypted.
   * @param {bitArray} iv The initialization vector.
   * @param {bitArray} adata The associated data to be tagged.
   * @param {Number} tlen The length of the tag, in bits.
   */
  _ctrMode: function(encrypt, prf, data, adata, iv, tlen) {
    var H, J0, S0, enc, i, ctr, tag, last, l, bl, abl, ivbl, w=sjcl.bitArray;

    // Calculate data lengths
    l = data.length;
    bl = w.bitLength(data);
    abl = w.bitLength(adata);
    ivbl = w.bitLength(iv);

    // Calculate the parameters
    H = prf.encrypt([0,0,0,0]);
    if (ivbl === 96) {
      J0 = iv.slice(0);
      J0 = w.concat(J0, [1]);
    } else {
      J0 = sjcl.mode.gcm._ghash(H, [0,0,0,0], iv);
      J0 = sjcl.mode.gcm._ghash(H, J0, [0,0,Math.floor(ivbl/0x100000000),ivbl&0xffffffff]);
    }
    S0 = sjcl.mode.gcm._ghash(H, [0,0,0,0], adata);

    // Initialize ctr and tag
    ctr = J0.slice(0);
    tag = S0.slice(0);

    // If decrypting, calculate hash
    if (!encrypt) {
      tag = sjcl.mode.gcm._ghash(H, S0, data);
    }

    // Encrypt all the data
    for (i=0; i<l; i+=4) {
       ctr[3]++;
       enc = prf.encrypt(ctr);
       data[i]   ^= enc[0];
       data[i+1] ^= enc[1];
       data[i+2] ^= enc[2];
       data[i+3] ^= enc[3];
    }
    data = w.clamp(data, bl);

    // If encrypting, calculate hash
    if (encrypt) {
      tag = sjcl.mode.gcm._ghash(H, S0, data);
    }

    // Calculate last block from bit lengths, ugly because bitwise operations are 32-bit
    last = [
      Math.floor(abl/0x100000000), abl&0xffffffff,
      Math.floor(bl/0x100000000), bl&0xffffffff
    ];

    // Calculate the final tag block
    tag = sjcl.mode.gcm._ghash(H, tag, last);
    enc = prf.encrypt(J0);
    tag[0] ^= enc[0];
    tag[1] ^= enc[1];
    tag[2] ^= enc[2];
    tag[3] ^= enc[3];

    return { tag:w.bitSlice(tag, 0, tlen), data:data };
  }
};
/** @fileOverview HMAC implementation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** HMAC with the specified hash function.
 * @constructor
 * @param {bitArray} key the key for HMAC.
 * @param {Object} [Hash=sjcl.hash.sha256] The hash function to use.
 */
sjcl.misc.hmac = function (key, Hash) {
  this._hash = Hash = Hash || sjcl.hash.sha256;
  var exKey = [[],[]], i,
      bs = Hash.prototype.blockSize / 32;
  this._baseHash = [new Hash(), new Hash()];

  if (key.length > bs) {
    key = Hash.hash(key);
  }
  
  for (i=0; i<bs; i++) {
    exKey[0][i] = key[i]^0x36363636;
    exKey[1][i] = key[i]^0x5C5C5C5C;
  }
  
  this._baseHash[0].update(exKey[0]);
  this._baseHash[1].update(exKey[1]);
  this._resultHash = new Hash(this._baseHash[0]);
};

/** HMAC with the specified hash function.  Also called encrypt since it's a prf.
 * @param {bitArray|String} data The data to mac.
 */
sjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (data) {
  if (!this._updated) {
    this.update(data);
    return this.digest(data);
  } else {
    throw new sjcl.exception.invalid("encrypt on already updated hmac called!");
  }
};

sjcl.misc.hmac.prototype.reset = function () {
  this._resultHash = new this._hash(this._baseHash[0]);
  this._updated = false;
};

sjcl.misc.hmac.prototype.update = function (data) {
  this._updated = true;
  this._resultHash.update(data);
};

sjcl.misc.hmac.prototype.digest = function () {
  var w = this._resultHash.finalize(), result = new (this._hash)(this._baseHash[1]).update(w).finalize();

  this.reset();

  return result;
};
/** @fileOverview Password-based key-derivation function, version 2.0.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** Password-Based Key-Derivation Function, version 2.0.
 *
 * Generate keys from passwords using PBKDF2-HMAC-SHA256.
 *
 * This is the method specified by RSA's PKCS #5 standard.
 *
 * @param {bitArray|String} password  The password.
 * @param {bitArray|String} salt The salt.  Should have lots of entropy.
 * @param {Number} [count=1000] The number of iterations.  Higher numbers make the function slower but more secure.
 * @param {Number} [length] The length of the derived key.  Defaults to the
                            output size of the hash function.
 * @param {Object} [Prff=sjcl.misc.hmac] The pseudorandom function family.
 * @return {bitArray} the derived key.
 */
sjcl.misc.pbkdf2 = function (password, salt, count, length, Prff) {
  count = count || 10000;
  
  if (length < 0 || count < 0) {
    throw new sjcl.exception.invalid("invalid params to pbkdf2");
  }
  
  if (typeof password === "string") {
    password = sjcl.codec.utf8String.toBits(password);
  }
  
  if (typeof salt === "string") {
    salt = sjcl.codec.utf8String.toBits(salt);
  }
  
  Prff = Prff || sjcl.misc.hmac;
  
  var prf = new Prff(password),
      u, ui, i, j, k, out = [], b = sjcl.bitArray;

  for (k = 1; 32 * out.length < (length || 1); k++) {
    u = ui = prf.encrypt(b.concat(salt,[k]));
    
    for (i=1; i<count; i++) {
      ui = prf.encrypt(ui);
      for (j=0; j<ui.length; j++) {
        u[j] ^= ui[j];
      }
    }
    
    out = out.concat(u);
  }

  if (length) { out = b.clamp(out, length); }

  return out;
};
/** @fileOverview HKDF implementation.
 *
 * @author Steve Thomas
 */

/** HKDF with the specified hash function.
 * @param {bitArray} ikm The input keying material.
 * @param {Number} keyBitLength The output key length, in bits.
 * @param {String|bitArray} salt The salt for HKDF.
 * @param {String|bitArray} info The info for HKDF.
 * @param {Object} [Hash=sjcl.hash.sha256] The hash function to use.
 * @return {bitArray} derived key.
 */
sjcl.misc.hkdf = function (ikm, keyBitLength, salt, info, Hash) {
  var hmac, key, i, hashLen, loops, curOut, ret = [];

  Hash = Hash || sjcl.hash.sha256;
  if (typeof info === "string") {
    info = sjcl.codec.utf8String.toBits(info);
  }
  if (typeof salt === "string") {
    salt = sjcl.codec.utf8String.toBits(salt);
  } else if (!salt) {
    salt = [];
  }

  hmac = new sjcl.misc.hmac(salt, Hash);
  key = hmac.mac(ikm);
  hashLen = sjcl.bitArray.bitLength(key);

  loops = Math.ceil(keyBitLength / hashLen);
  if (loops > 255) {
    throw new sjcl.exception.invalid("key bit length is too large for hkdf");
  }

  hmac = new sjcl.misc.hmac(key, Hash);
  curOut = [];
  for (i = 1; i <= loops; i++) {
    hmac.update(curOut);
    hmac.update(info);
    hmac.update([sjcl.bitArray.partial(8, i)]);
    curOut = hmac.digest();
    ret = sjcl.bitArray.concat(ret, curOut);
  }
  return sjcl.bitArray.clamp(ret, keyBitLength);
};
/** @fileOverview Random number generator.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 * @author Michael Brooks
 * @author Steve Thomas
 */

/** 
 * @class Random number generator
 * @description
 * <b>Use sjcl.random as a singleton for this class!</b>
 * <p>
 * This random number generator is a derivative of Ferguson and Schneier's
 * generator Fortuna.  It collects entropy from various events into several
 * pools, implemented by streaming SHA-256 instances.  It differs from
 * ordinary Fortuna in a few ways, though.
 * </p>
 *
 * <p>
 * Most importantly, it has an entropy estimator.  This is present because
 * there is a strong conflict here between making the generator available
 * as soon as possible, and making sure that it doesn't "run on empty".
 * In Fortuna, there is a saved state file, and the system is likely to have
 * time to warm up.
 * </p>
 *
 * <p>
 * Second, because users are unlikely to stay on the page for very long,
 * and to speed startup time, the number of pools increases logarithmically:
 * a new pool is created when the previous one is actually used for a reseed.
 * This gives the same asymptotic guarantees as Fortuna, but gives more
 * entropy to early reseeds.
 * </p>
 *
 * <p>
 * The entire mechanism here feels pretty klunky.  Furthermore, there are
 * several improvements that should be made, including support for
 * dedicated cryptographic functions that may be present in some browsers;
 * state files in local storage; cookies containing randomness; etc.  So
 * look for improvements in future versions.
 * </p>
 * @constructor
 */
sjcl.prng = function(defaultParanoia) {
  
  /* private */
  this._pools                   = [new sjcl.hash.sha256()];
  this._poolEntropy             = [0];
  this._reseedCount             = 0;
  this._robins                  = {};
  this._eventId                 = 0;
  
  this._collectorIds            = {};
  this._collectorIdNext         = 0;
  
  this._strength                = 0;
  this._poolStrength            = 0;
  this._nextReseed              = 0;
  this._key                     = [0,0,0,0,0,0,0,0];
  this._counter                 = [0,0,0,0];
  this._cipher                  = undefined;
  this._defaultParanoia         = defaultParanoia;
  
  /* event listener stuff */
  this._collectorsStarted       = false;
  this._callbacks               = {progress: {}, seeded: {}};
  this._callbackI               = 0;
  
  /* constants */
  this._NOT_READY               = 0;
  this._READY                   = 1;
  this._REQUIRES_RESEED         = 2;

  this._MAX_WORDS_PER_BURST     = 65536;
  this._PARANOIA_LEVELS         = [0,48,64,96,128,192,256,384,512,768,1024];
  this._MILLISECONDS_PER_RESEED = 30000;
  this._BITS_PER_RESEED         = 80;
};
 
sjcl.prng.prototype = {
  /** Generate several random words, and return them in an array.
   * A word consists of 32 bits (4 bytes)
   * @param {Number} nwords The number of words to generate.
   */
  randomWords: function (nwords, paranoia) {
    var out = [], i, readiness = this.isReady(paranoia), g;
  
    if (readiness === this._NOT_READY) {
      throw new sjcl.exception.notReady("generator isn't seeded");
    } else if (readiness & this._REQUIRES_RESEED) {
      this._reseedFromPools(!(readiness & this._READY));
    }
  
    for (i=0; i<nwords; i+= 4) {
      if ((i+1) % this._MAX_WORDS_PER_BURST === 0) {
        this._gate();
      }
   
      g = this._gen4words();
      out.push(g[0],g[1],g[2],g[3]);
    }
    this._gate();
  
    return out.slice(0,nwords);
  },
  
  setDefaultParanoia: function (paranoia, allowZeroParanoia) {
    if (paranoia === 0 && allowZeroParanoia !== "Setting paranoia=0 will ruin your security; use it only for testing") {
      throw new sjcl.exception.invalid("Setting paranoia=0 will ruin your security; use it only for testing");
    }

    this._defaultParanoia = paranoia;
  },
  
  /**
   * Add entropy to the pools.
   * @param data The entropic value.  Should be a 32-bit integer, array of 32-bit integers, or string
   * @param {Number} estimatedEntropy The estimated entropy of data, in bits
   * @param {String} source The source of the entropy, eg "mouse"
   */
  addEntropy: function (data, estimatedEntropy, source) {
    source = source || "user";
  
    var id,
      i, tmp,
      t = (new Date()).valueOf(),
      robin = this._robins[source],
      oldReady = this.isReady(), err = 0, objName;
      
    id = this._collectorIds[source];
    if (id === undefined) { id = this._collectorIds[source] = this._collectorIdNext ++; }
      
    if (robin === undefined) { robin = this._robins[source] = 0; }
    this._robins[source] = ( this._robins[source] + 1 ) % this._pools.length;
  
    switch(typeof(data)) {
      
    case "number":
      if (estimatedEntropy === undefined) {
        estimatedEntropy = 1;
      }
      this._pools[robin].update([id,this._eventId++,1,estimatedEntropy,t,1,data|0]);
      break;
      
    case "object":
      objName = Object.prototype.toString.call(data);
      if (objName === "[object Uint32Array]") {
        tmp = [];
        for (i = 0; i < data.length; i++) {
          tmp.push(data[i]);
        }
        data = tmp;
      } else {
        if (objName !== "[object Array]") {
          err = 1;
        }
        for (i=0; i<data.length && !err; i++) {
          if (typeof(data[i]) !== "number") {
            err = 1;
          }
        }
      }
      if (!err) {
        if (estimatedEntropy === undefined) {
          /* horrible entropy estimator */
          estimatedEntropy = 0;
          for (i=0; i<data.length; i++) {
            tmp= data[i];
            while (tmp>0) {
              estimatedEntropy++;
              tmp = tmp >>> 1;
            }
          }
        }
        this._pools[robin].update([id,this._eventId++,2,estimatedEntropy,t,data.length].concat(data));
      }
      break;
      
    case "string":
      if (estimatedEntropy === undefined) {
       /* English text has just over 1 bit per character of entropy.
        * But this might be HTML or something, and have far less
        * entropy than English...  Oh well, let's just say one bit.
        */
       estimatedEntropy = data.length;
      }
      this._pools[robin].update([id,this._eventId++,3,estimatedEntropy,t,data.length]);
      this._pools[robin].update(data);
      break;
      
    default:
      err=1;
    }
    if (err) {
      throw new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string");
    }
  
    /* record the new strength */
    this._poolEntropy[robin] += estimatedEntropy;
    this._poolStrength += estimatedEntropy;
  
    /* fire off events */
    if (oldReady === this._NOT_READY) {
      if (this.isReady() !== this._NOT_READY) {
        this._fireEvent("seeded", Math.max(this._strength, this._poolStrength));
      }
      this._fireEvent("progress", this.getProgress());
    }
  },
  
  /** Is the generator ready? */
  isReady: function (paranoia) {
    var entropyRequired = this._PARANOIA_LEVELS[ (paranoia !== undefined) ? paranoia : this._defaultParanoia ];
  
    if (this._strength && this._strength >= entropyRequired) {
      return (this._poolEntropy[0] > this._BITS_PER_RESEED && (new Date()).valueOf() > this._nextReseed) ?
        this._REQUIRES_RESEED | this._READY :
        this._READY;
    } else {
      return (this._poolStrength >= entropyRequired) ?
        this._REQUIRES_RESEED | this._NOT_READY :
        this._NOT_READY;
    }
  },
  
  /** Get the generator's progress toward readiness, as a fraction */
  getProgress: function (paranoia) {
    var entropyRequired = this._PARANOIA_LEVELS[ paranoia ? paranoia : this._defaultParanoia ];
  
    if (this._strength >= entropyRequired) {
      return 1.0;
    } else {
      return (this._poolStrength > entropyRequired) ?
        1.0 :
        this._poolStrength / entropyRequired;
    }
  },
  
  /** start the built-in entropy collectors */
  startCollectors: function () {
    if (this._collectorsStarted) { return; }
  
    this._eventListener = {
      loadTimeCollector: this._bind(this._loadTimeCollector),
      mouseCollector: this._bind(this._mouseCollector),
      keyboardCollector: this._bind(this._keyboardCollector),
      accelerometerCollector: this._bind(this._accelerometerCollector),
      touchCollector: this._bind(this._touchCollector)
    };

    if (window.addEventListener) {
      window.addEventListener("load", this._eventListener.loadTimeCollector, false);
      window.addEventListener("mousemove", this._eventListener.mouseCollector, false);
      window.addEventListener("keypress", this._eventListener.keyboardCollector, false);
      window.addEventListener("devicemotion", this._eventListener.accelerometerCollector, false);
      window.addEventListener("touchmove", this._eventListener.touchCollector, false);
    } else if (document.attachEvent) {
      document.attachEvent("onload", this._eventListener.loadTimeCollector);
      document.attachEvent("onmousemove", this._eventListener.mouseCollector);
      document.attachEvent("keypress", this._eventListener.keyboardCollector);
    } else {
      throw new sjcl.exception.bug("can't attach event");
    }
  
    this._collectorsStarted = true;
  },
  
  /** stop the built-in entropy collectors */
  stopCollectors: function () {
    if (!this._collectorsStarted) { return; }
  
    if (window.removeEventListener) {
      window.removeEventListener("load", this._eventListener.loadTimeCollector, false);
      window.removeEventListener("mousemove", this._eventListener.mouseCollector, false);
      window.removeEventListener("keypress", this._eventListener.keyboardCollector, false);
      window.removeEventListener("devicemotion", this._eventListener.accelerometerCollector, false);
      window.removeEventListener("touchmove", this._eventListener.touchCollector, false);
    } else if (document.detachEvent) {
      document.detachEvent("onload", this._eventListener.loadTimeCollector);
      document.detachEvent("onmousemove", this._eventListener.mouseCollector);
      document.detachEvent("keypress", this._eventListener.keyboardCollector);
    }

    this._collectorsStarted = false;
  },
  
  /* use a cookie to store entropy.
  useCookie: function (all_cookies) {
      throw new sjcl.exception.bug("random: useCookie is unimplemented");
  },*/
  
  /** add an event listener for progress or seeded-ness. */
  addEventListener: function (name, callback) {
    this._callbacks[name][this._callbackI++] = callback;
  },
  
  /** remove an event listener for progress or seeded-ness */
  removeEventListener: function (name, cb) {
    var i, j, cbs=this._callbacks[name], jsTemp=[];

    /* I'm not sure if this is necessary; in C++, iterating over a
     * collection and modifying it at the same time is a no-no.
     */

    for (j in cbs) {
      if (cbs.hasOwnProperty(j) && cbs[j] === cb) {
        jsTemp.push(j);
      }
    }

    for (i=0; i<jsTemp.length; i++) {
      j = jsTemp[i];
      delete cbs[j];
    }
  },
  
  _bind: function (func) {
    var that = this;
    return function () {
      func.apply(that, arguments);
    };
  },

  /** Generate 4 random words, no reseed, no gate.
   * @private
   */
  _gen4words: function () {
    for (var i=0; i<4; i++) {
      this._counter[i] = this._counter[i]+1 | 0;
      if (this._counter[i]) { break; }
    }
    return this._cipher.encrypt(this._counter);
  },
  
  /* Rekey the AES instance with itself after a request, or every _MAX_WORDS_PER_BURST words.
   * @private
   */
  _gate: function () {
    this._key = this._gen4words().concat(this._gen4words());
    this._cipher = new sjcl.cipher.aes(this._key);
  },
  
  /** Reseed the generator with the given words
   * @private
   */
  _reseed: function (seedWords) {
    this._key = sjcl.hash.sha256.hash(this._key.concat(seedWords));
    this._cipher = new sjcl.cipher.aes(this._key);
    for (var i=0; i<4; i++) {
      this._counter[i] = this._counter[i]+1 | 0;
      if (this._counter[i]) { break; }
    }
  },
  
  /** reseed the data from the entropy pools
   * @param full If set, use all the entropy pools in the reseed.
   */
  _reseedFromPools: function (full) {
    var reseedData = [], strength = 0, i;
  
    this._nextReseed = reseedData[0] =
      (new Date()).valueOf() + this._MILLISECONDS_PER_RESEED;
    
    for (i=0; i<16; i++) {
      /* On some browsers, this is cryptographically random.  So we might
       * as well toss it in the pot and stir...
       */
      reseedData.push(Math.random()*0x100000000|0);
    }
    
    for (i=0; i<this._pools.length; i++) {
     reseedData = reseedData.concat(this._pools[i].finalize());
     strength += this._poolEntropy[i];
     this._poolEntropy[i] = 0;
   
     if (!full && (this._reseedCount & (1<<i))) { break; }
    }
  
    /* if we used the last pool, push a new one onto the stack */
    if (this._reseedCount >= 1 << this._pools.length) {
     this._pools.push(new sjcl.hash.sha256());
     this._poolEntropy.push(0);
    }
  
    /* how strong was this reseed? */
    this._poolStrength -= strength;
    if (strength > this._strength) {
      this._strength = strength;
    }
  
    this._reseedCount ++;
    this._reseed(reseedData);
  },
  
  _keyboardCollector: function () {
    this._addCurrentTimeToEntropy(1);
  },
  
  _mouseCollector: function (ev) {
    var x, y;

    try {
      x = ev.x || ev.clientX || ev.offsetX || 0;
      y = ev.y || ev.clientY || ev.offsetY || 0;
    } catch (err) {
      // Event originated from a secure element. No mouse position available.
      x = 0;
      y = 0;
    }

    if (x != 0 && y!= 0) {
      this.addEntropy([x,y], 2, "mouse");
    }

    this._addCurrentTimeToEntropy(0);
  },

  _touchCollector: function(ev) {
    var touch = ev.touches[0] || ev.changedTouches[0];
    var x = touch.pageX || touch.clientX,
        y = touch.pageY || touch.clientY;

    this.addEntropy([x,y],1,"touch");

    this._addCurrentTimeToEntropy(0);
  },
  
  _loadTimeCollector: function () {
    this._addCurrentTimeToEntropy(2);
  },

  _addCurrentTimeToEntropy: function (estimatedEntropy) {
    if (typeof window !== 'undefined' && window.performance && typeof window.performance.now === "function") {
      //how much entropy do we want to add here?
      this.addEntropy(window.performance.now(), estimatedEntropy, "loadtime");
    } else {
      this.addEntropy((new Date()).valueOf(), estimatedEntropy, "loadtime");
    }
  },
  _accelerometerCollector: function (ev) {
    var ac = ev.accelerationIncludingGravity.x||ev.accelerationIncludingGravity.y||ev.accelerationIncludingGravity.z;
    if(window.orientation){
      var or = window.orientation;
      if (typeof or === "number") {
        this.addEntropy(or, 1, "accelerometer");
      }
    }
    if (ac) {
      this.addEntropy(ac, 2, "accelerometer");
    }
    this._addCurrentTimeToEntropy(0);
  },

  _fireEvent: function (name, arg) {
    var j, cbs=sjcl.random._callbacks[name], cbsTemp=[];
    /* TODO: there is a race condition between removing collectors and firing them */

    /* I'm not sure if this is necessary; in C++, iterating over a
     * collection and modifying it at the same time is a no-no.
     */

    for (j in cbs) {
      if (cbs.hasOwnProperty(j)) {
        cbsTemp.push(cbs[j]);
      }
    }

    for (j=0; j<cbsTemp.length; j++) {
      cbsTemp[j](arg);
    }
  }
};

/** an instance for the prng.
* @see sjcl.prng
*/
sjcl.random = new sjcl.prng(6);

(function(){
  // function for getting nodejs crypto module. catches and ignores errors.
  function getCryptoModule() {
    try {
      return require('crypto');
    }
    catch (e) {
      return null;
    }
  }

  try {
    var buf, crypt, ab;

    // get cryptographically strong entropy depending on runtime environment
    if (typeof module !== 'undefined' && module.exports && (crypt = getCryptoModule()) && crypt.randomBytes) {
      buf = crypt.randomBytes(1024/8);
      buf = new Uint32Array(new Uint8Array(buf).buffer);
      sjcl.random.addEntropy(buf, 1024, "crypto.randomBytes");

    } else if (typeof window !== 'undefined' && typeof Uint32Array !== 'undefined') {
      ab = new Uint32Array(32);
      if (window.crypto && window.crypto.getRandomValues) {
        window.crypto.getRandomValues(ab);
      } else if (window.msCrypto && window.msCrypto.getRandomValues) {
        window.msCrypto.getRandomValues(ab);
      } else {
        return;
      }

      // get cryptographically strong entropy in Webkit
      sjcl.random.addEntropy(ab, 1024, "crypto.getRandomValues");

    } else {
      // no getRandomValues :-(
    }
  } catch (e) {
    if (typeof window !== 'undefined' && window.console) {
      console.log("There was an error collecting entropy from the browser:");
      console.log(e);
      //we do not want the library to fail due to randomness not being maintained.
    }
  }
}());
/** @fileOverview Convenience functions centered around JSON encapsulation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

 /**
  * JSON encapsulation
  * @namespace
  */
 sjcl.json = {
  /** Default values for encryption */
  defaults: { v:1, iter:10000, ks:128, ts:64, mode:"ccm", adata:"", cipher:"aes" },

  /** Simple encryption function.
   * @param {String|bitArray} password The password or key.
   * @param {String} plaintext The data to encrypt.
   * @param {Object} [params] The parameters including tag, iv and salt.
   * @param {Object} [rp] A returned version with filled-in parameters.
   * @return {Object} The cipher raw data.
   * @throws {sjcl.exception.invalid} if a parameter is invalid.
   */
  _encrypt: function (password, plaintext, params, rp) {
    params = params || {};
    rp = rp || {};

    var j = sjcl.json, p = j._add({ iv: sjcl.random.randomWords(4,0) },
                                  j.defaults), tmp, prp, adata;
    j._add(p, params);
    adata = p.adata;
    if (typeof p.salt === "string") {
      p.salt = sjcl.codec.base64.toBits(p.salt);
    }
    if (typeof p.iv === "string") {
      p.iv = sjcl.codec.base64.toBits(p.iv);
    }

    if (!sjcl.mode[p.mode] ||
        !sjcl.cipher[p.cipher] ||
        (typeof password === "string" && p.iter <= 100) ||
        (p.ts !== 64 && p.ts !== 96 && p.ts !== 128) ||
        (p.ks !== 128 && p.ks !== 192 && p.ks !== 256) ||
        (p.iv.length < 2 || p.iv.length > 4)) {
      throw new sjcl.exception.invalid("json encrypt: invalid parameters");
    }

    if (typeof password === "string") {
      tmp = sjcl.misc.cachedPbkdf2(password, p);
      password = tmp.key.slice(0,p.ks/32);
      p.salt = tmp.salt;
    } else if (sjcl.ecc && password instanceof sjcl.ecc.elGamal.publicKey) {
      tmp = password.kem();
      p.kemtag = tmp.tag;
      password = tmp.key.slice(0,p.ks/32);
    }
    if (typeof plaintext === "string") {
      plaintext = sjcl.codec.utf8String.toBits(plaintext);
    }
    if (typeof adata === "string") {
      p.adata = adata = sjcl.codec.utf8String.toBits(adata);
    }
    prp = new sjcl.cipher[p.cipher](password);

    /* return the json data */
    j._add(rp, p);
    rp.key = password;

    /* do the encryption */
    if (p.mode === "ccm" && sjcl.arrayBuffer && sjcl.arrayBuffer.ccm && plaintext instanceof ArrayBuffer) {
      p.ct = sjcl.arrayBuffer.ccm.encrypt(prp, plaintext, p.iv, adata, p.ts);
    } else {
      p.ct = sjcl.mode[p.mode].encrypt(prp, plaintext, p.iv, adata, p.ts);
    }

    //return j.encode(j._subtract(p, j.defaults));
    return p;
  },

  /** Simple encryption function.
   * @param {String|bitArray} password The password or key.
   * @param {String} plaintext The data to encrypt.
   * @param {Object} [params] The parameters including tag, iv and salt.
   * @param {Object} [rp] A returned version with filled-in parameters.
   * @return {String} The ciphertext serialized data.
   * @throws {sjcl.exception.invalid} if a parameter is invalid.
   */
  encrypt: function (password, plaintext, params, rp) {
    var j = sjcl.json, p = j._encrypt.apply(j, arguments);
    return j.encode(p);
  },

  /** Simple decryption function.
   * @param {String|bitArray} password The password or key.
   * @param {Object} ciphertext The cipher raw data to decrypt.
   * @param {Object} [params] Additional non-default parameters.
   * @param {Object} [rp] A returned object with filled parameters.
   * @return {String} The plaintext.
   * @throws {sjcl.exception.invalid} if a parameter is invalid.
   * @throws {sjcl.exception.corrupt} if the ciphertext is corrupt.
   */
  _decrypt: function (password, ciphertext, params, rp) {
    params = params || {};
    rp = rp || {};

    var j = sjcl.json, p = j._add(j._add(j._add({},j.defaults),ciphertext), params, true), ct, tmp, prp, adata=p.adata;
    if (typeof p.salt === "string") {
      p.salt = sjcl.codec.base64.toBits(p.salt);
    }
    if (typeof p.iv === "string") {
      p.iv = sjcl.codec.base64.toBits(p.iv);
    }

    if (!sjcl.mode[p.mode] ||
        !sjcl.cipher[p.cipher] ||
        (typeof password === "string" && p.iter <= 100) ||
        (p.ts !== 64 && p.ts !== 96 && p.ts !== 128) ||
        (p.ks !== 128 && p.ks !== 192 && p.ks !== 256) ||
        (!p.iv) ||
        (p.iv.length < 2 || p.iv.length > 4)) {
      throw new sjcl.exception.invalid("json decrypt: invalid parameters");
    }

    if (typeof password === "string") {
      tmp = sjcl.misc.cachedPbkdf2(password, p);
      password = tmp.key.slice(0,p.ks/32);
      p.salt  = tmp.salt;
    } else if (sjcl.ecc && password instanceof sjcl.ecc.elGamal.secretKey) {
      password = password.unkem(sjcl.codec.base64.toBits(p.kemtag)).slice(0,p.ks/32);
    }
    if (typeof adata === "string") {
      adata = sjcl.codec.utf8String.toBits(adata);
    }
    prp = new sjcl.cipher[p.cipher](password);

    /* do the decryption */
    if (p.mode === "ccm" && sjcl.arrayBuffer && sjcl.arrayBuffer.ccm && p.ct instanceof ArrayBuffer) {
      ct = sjcl.arrayBuffer.ccm.decrypt(prp, p.ct, p.iv, p.tag, adata, p.ts);
    } else {
      ct = sjcl.mode[p.mode].decrypt(prp, p.ct, p.iv, adata, p.ts);
    }

    /* return the json data */
    j._add(rp, p);
    rp.key = password;

    if (params.raw === 1) {
      return ct;
    } else {
      return sjcl.codec.utf8String.fromBits(ct);
    }
  },

  /** Simple decryption function.
   * @param {String|bitArray} password The password or key.
   * @param {String} ciphertext The ciphertext to decrypt.
   * @param {Object} [params] Additional non-default parameters.
   * @param {Object} [rp] A returned object with filled parameters.
   * @return {String} The plaintext.
   * @throws {sjcl.exception.invalid} if a parameter is invalid.
   * @throws {sjcl.exception.corrupt} if the ciphertext is corrupt.
   */
  decrypt: function (password, ciphertext, params, rp) {
    var j = sjcl.json;
    return j._decrypt(password, j.decode(ciphertext), params, rp);
  },

  /** Encode a flat structure into a JSON string.
   * @param {Object} obj The structure to encode.
   * @return {String} A JSON string.
   * @throws {sjcl.exception.invalid} if obj has a non-alphanumeric property.
   * @throws {sjcl.exception.bug} if a parameter has an unsupported type.
   */
  encode: function (obj) {
    var i, out='{', comma='';
    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        if (!i.match(/^[a-z0-9]+$/i)) {
          throw new sjcl.exception.invalid("json encode: invalid property name");
        }
        out += comma + '"' + i + '":';
        comma = ',';

        switch (typeof obj[i]) {
          case 'number':
          case 'boolean':
            out += obj[i];
            break;

          case 'string':
            out += '"' + escape(obj[i]) + '"';
            break;

          case 'object':
            out += '"' + sjcl.codec.base64.fromBits(obj[i],0) + '"';
            break;

          default:
            throw new sjcl.exception.bug("json encode: unsupported type");
        }
      }
    }
    return out+'}';
  },

  /** Decode a simple (flat) JSON string into a structure.  The ciphertext,
   * adata, salt and iv will be base64-decoded.
   * @param {String} str The string.
   * @return {Object} The decoded structure.
   * @throws {sjcl.exception.invalid} if str isn't (simple) JSON.
   */
  decode: function (str) {
    str = str.replace(/\s/g,'');
    if (!str.match(/^\{.*\}$/)) {
      throw new sjcl.exception.invalid("json decode: this isn't json!");
    }
    var a = str.replace(/^\{|\}$/g, '').split(/,/), out={}, i, m;
    for (i=0; i<a.length; i++) {
      if (!(m=a[i].match(/^\s*(?:(["']?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|"([a-z0-9+\/%*_.@=\-]*)"|(true|false))$/i))) {
        throw new sjcl.exception.invalid("json decode: this isn't json!");
      }
      if (m[3] != null) {
        out[m[2]] = parseInt(m[3],10);
      } else if (m[4] != null) {
        out[m[2]] = m[2].match(/^(ct|adata|salt|iv)$/) ? sjcl.codec.base64.toBits(m[4]) : unescape(m[4]);
      } else if (m[5] != null) {
        out[m[2]] = m[5] === 'true';
      }
    }
    return out;
  },

  /** Insert all elements of src into target, modifying and returning target.
   * @param {Object} target The object to be modified.
   * @param {Object} src The object to pull data from.
   * @param {boolean} [requireSame=false] If true, throw an exception if any field of target differs from corresponding field of src.
   * @return {Object} target.
   * @private
   */
  _add: function (target, src, requireSame) {
    if (target === undefined) { target = {}; }
    if (src === undefined) { return target; }
    var i;
    for (i in src) {
      if (src.hasOwnProperty(i)) {
        if (requireSame && target[i] !== undefined && target[i] !== src[i]) {
          throw new sjcl.exception.invalid("required parameter overridden");
        }
        target[i] = src[i];
      }
    }
    return target;
  },

  /** Remove all elements of minus from plus.  Does not modify plus.
   * @private
   */
  _subtract: function (plus, minus) {
    var out = {}, i;

    for (i in plus) {
      if (plus.hasOwnProperty(i) && plus[i] !== minus[i]) {
        out[i] = plus[i];
      }
    }

    return out;
  },

  /** Return only the specified elements of src.
   * @private
   */
  _filter: function (src, filter) {
    var out = {}, i;
    for (i=0; i<filter.length; i++) {
      if (src[filter[i]] !== undefined) {
        out[filter[i]] = src[filter[i]];
      }
    }
    return out;
  }
};

/** Simple encryption function; convenient shorthand for sjcl.json.encrypt.
 * @param {String|bitArray} password The password or key.
 * @param {String} plaintext The data to encrypt.
 * @param {Object} [params] The parameters including tag, iv and salt.
 * @param {Object} [rp] A returned version with filled-in parameters.
 * @return {String} The ciphertext.
 */
sjcl.encrypt = sjcl.json.encrypt;

/** Simple decryption function; convenient shorthand for sjcl.json.decrypt.
 * @param {String|bitArray} password The password or key.
 * @param {String} ciphertext The ciphertext to decrypt.
 * @param {Object} [params] Additional non-default parameters.
 * @param {Object} [rp] A returned object with filled parameters.
 * @return {String} The plaintext.
 */
sjcl.decrypt = sjcl.json.decrypt;

/** The cache for cachedPbkdf2.
 * @private
 */
sjcl.misc._pbkdf2Cache = {};

/** Cached PBKDF2 key derivation.
 * @param {String} password The password.
 * @param {Object} [obj] The derivation params (iteration count and optional salt).
 * @return {Object} The derived data in key, the salt in salt.
 */
sjcl.misc.cachedPbkdf2 = function (password, obj) {
  var cache = sjcl.misc._pbkdf2Cache, c, cp, str, salt, iter;

  obj = obj || {};
  iter = obj.iter || 1000;

  /* open the cache for this password and iteration count */
  cp = cache[password] = cache[password] || {};
  c = cp[iter] = cp[iter] || { firstSalt: (obj.salt && obj.salt.length) ?
                     obj.salt.slice(0) : sjcl.random.randomWords(2,0) };

  salt = (obj.salt === undefined) ? c.firstSalt : obj.salt;

  c[salt] = c[salt] || sjcl.misc.pbkdf2(password, salt, obj.iter);
  return { key: c[salt].slice(0), salt:salt.slice(0) };
};
if(typeof module !== 'undefined' && module.exports){
  module.exports = sjcl;
}
if (typeof define === "function") {
    define([], function () {
        return sjcl;
    });
}
// Thanks to Colin McRae and Jonathan Burns of ionic security
// for reporting and fixing two bugs in this file!

/**
 * Constructs a new bignum from another bignum, a number or a hex string.
 * @constructor
 */
sjcl.bn = function(it) {
  this.initWith(it);
};

sjcl.bn.prototype = {
  radix: 24,
  maxMul: 8,
  _class: sjcl.bn,

  copy: function() {
    return new this._class(this);
  },

  /**
   * Initializes this with it, either as a bn, a number, or a hex string.
   */
  initWith: function(it) {
    var i=0, k;
    switch(typeof it) {
    case "object":
      this.limbs = it.limbs.slice(0);
      break;

    case "number":
      this.limbs = [it];
      this.normalize();
      break;

    case "string":
      it = it.replace(/^0x/, '');
      this.limbs = [];
      // hack
      k = this.radix / 4;
      for (i=0; i < it.length; i+=k) {
        this.limbs.push(parseInt(it.substring(Math.max(it.length - i - k, 0), it.length - i),16));
      }
      break;

    default:
      this.limbs = [0];
    }
    return this;
  },

  /**
   * Returns true if "this" and "that" are equal.  Calls fullReduce().
   * Equality test is in constant time.
   */
  equals: function(that) {
    if (typeof that === "number") { that = new this._class(that); }
    var difference = 0, i;
    this.fullReduce();
    that.fullReduce();
    for (i = 0; i < this.limbs.length || i < that.limbs.length; i++) {
      difference |= this.getLimb(i) ^ that.getLimb(i);
    }
    return (difference === 0);
  },

  /**
   * Get the i'th limb of this, zero if i is too large.
   */
  getLimb: function(i) {
    return (i >= this.limbs.length) ? 0 : this.limbs[i];
  },

  /**
   * Constant time comparison function.
   * Returns 1 if this >= that, or zero otherwise.
   */
  greaterEquals: function(that) {
    if (typeof that === "number") { that = new this._class(that); }
    var less = 0, greater = 0, i, a, b;
    i = Math.max(this.limbs.length, that.limbs.length) - 1;
    for (; i>= 0; i--) {
      a = this.getLimb(i);
      b = that.getLimb(i);
      greater |= (b - a) & ~less;
      less |= (a - b) & ~greater;
    }
    return (greater | ~less) >>> 31;
  },

  /**
   * Convert to a hex string.
   */
  toString: function() {
    this.fullReduce();
    var out="", i, s, l = this.limbs;
    for (i=0; i < this.limbs.length; i++) {
      s = l[i].toString(16);
      while (i < this.limbs.length - 1 && s.length < 6) {
        s = "0" + s;
      }
      out = s + out;
    }
    return "0x"+out;
  },

  /** this += that.  Does not normalize. */
  addM: function(that) {
    if (typeof(that) !== "object") { that = new this._class(that); }
    var i, l=this.limbs, ll=that.limbs;
    for (i=l.length; i<ll.length; i++) {
      l[i] = 0;
    }
    for (i=0; i<ll.length; i++) {
      l[i] += ll[i];
    }
    return this;
  },

  /** this *= 2.  Requires normalized; ends up normalized. */
  doubleM: function() {
    var i, carry=0, tmp, r=this.radix, m=this.radixMask, l=this.limbs;
    for (i=0; i<l.length; i++) {
      tmp = l[i];
      tmp = tmp+tmp+carry;
      l[i] = tmp & m;
      carry = tmp >> r;
    }
    if (carry) {
      l.push(carry);
    }
    return this;
  },

  /** this /= 2, rounded down.  Requires normalized; ends up normalized. */
  halveM: function() {
    var i, carry=0, tmp, r=this.radix, l=this.limbs;
    for (i=l.length-1; i>=0; i--) {
      tmp = l[i];
      l[i] = (tmp+carry)>>1;
      carry = (tmp&1) << r;
    }
    if (!l[l.length-1]) {
      l.pop();
    }
    return this;
  },

  /** this -= that.  Does not normalize. */
  subM: function(that) {
    if (typeof(that) !== "object") { that = new this._class(that); }
    var i, l=this.limbs, ll=that.limbs;
    for (i=l.length; i<ll.length; i++) {
      l[i] = 0;
    }
    for (i=0; i<ll.length; i++) {
      l[i] -= ll[i];
    }
    return this;
  },

  mod: function(that) {
    var neg = !this.greaterEquals(new sjcl.bn(0));

    that = new sjcl.bn(that).normalize(); // copy before we begin
    var out = new sjcl.bn(this).normalize(), ci=0;

    if (neg) out = (new sjcl.bn(0)).subM(out).normalize();

    for (; out.greaterEquals(that); ci++) {
      that.doubleM();
    }

    if (neg) out = that.sub(out).normalize();

    for (; ci > 0; ci--) {
      that.halveM();
      if (out.greaterEquals(that)) {
        out.subM(that).normalize();
      }
    }
    return out.trim();
  },

  /** return inverse mod prime p.  p must be odd. Binary extended Euclidean algorithm mod p. */
  inverseMod: function(p) {
    var a = new sjcl.bn(1), b = new sjcl.bn(0), x = new sjcl.bn(this), y = new sjcl.bn(p), tmp, i, nz=1;

    if (!(p.limbs[0] & 1)) {
      throw (new sjcl.exception.invalid("inverseMod: p must be odd"));
    }

    // invariant: y is odd
    do {
      if (x.limbs[0] & 1) {
        if (!x.greaterEquals(y)) {
          // x < y; swap everything
          tmp = x; x = y; y = tmp;
          tmp = a; a = b; b = tmp;
        }
        x.subM(y);
        x.normalize();

        if (!a.greaterEquals(b)) {
          a.addM(p);
        }
        a.subM(b);
      }

      // cut everything in half
      x.halveM();
      if (a.limbs[0] & 1) {
        a.addM(p);
      }
      a.normalize();
      a.halveM();

      // check for termination: x ?= 0
      for (i=nz=0; i<x.limbs.length; i++) {
        nz |= x.limbs[i];
      }
    } while(nz);

    if (!y.equals(1)) {
      throw (new sjcl.exception.invalid("inverseMod: p and x must be relatively prime"));
    }

    return b;
  },

  /** this + that.  Does not normalize. */
  add: function(that) {
    return this.copy().addM(that);
  },

  /** this - that.  Does not normalize. */
  sub: function(that) {
    return this.copy().subM(that);
  },

  /** this * that.  Normalizes and reduces. */
  mul: function(that) {
    if (typeof(that) === "number") { that = new this._class(that); } else { that.normalize(); }
    this.normalize();
    var i, j, a = this.limbs, b = that.limbs, al = a.length, bl = b.length, out = new this._class(), c = out.limbs, ai, ii=this.maxMul;

    for (i=0; i < this.limbs.length + that.limbs.length + 1; i++) {
      c[i] = 0;
    }
    for (i=0; i<al; i++) {
      ai = a[i];
      for (j=0; j<bl; j++) {
        c[i+j] += ai * b[j];
      }

      if (!--ii) {
        ii = this.maxMul;
        out.cnormalize();
      }
    }
    return out.cnormalize().reduce();
  },

  /** this ^ 2.  Normalizes and reduces. */
  square: function() {
    return this.mul(this);
  },

  /** this ^ n.  Uses square-and-multiply.  Normalizes and reduces. */
  power: function(l) {
    l = new sjcl.bn(l).normalize().trim().limbs;
    var i, j, out = new this._class(1), pow = this;

    for (i=0; i<l.length; i++) {
      for (j=0; j<this.radix; j++) {
        if (l[i] & (1<<j)) { out = out.mul(pow); }
        if (i == (l.length - 1) && l[i]>>(j + 1) == 0) { break; }

        pow = pow.square();
      }
    }

    return out;
  },

  /** this * that mod N */
  mulmod: function(that, N) {
    return this.mod(N).mul(that.mod(N)).mod(N);
  },

  /** this ^ x mod N */
  powermod: function(x, N) {
    x = new sjcl.bn(x);
    N = new sjcl.bn(N);

    // Jump to montpowermod if possible.
    if ((N.limbs[0] & 1) == 1) {
      var montOut = this.montpowermod(x, N);

      if (montOut != false) { return montOut; } // else go to slow powermod
    }

    var i, j, l = x.normalize().trim().limbs, out = new this._class(1), pow = this;

    for (i=0; i<l.length; i++) {
      for (j=0; j<this.radix; j++) {
        if (l[i] & (1<<j)) { out = out.mulmod(pow, N); }
        if (i == (l.length - 1) && l[i]>>(j + 1) == 0) { break; }

        pow = pow.mulmod(pow, N);
      }
    }

    return out;
  },

  /** this ^ x mod N with Montomery reduction */
  montpowermod: function(x, N) {
    x = new sjcl.bn(x).normalize().trim();
    N = new sjcl.bn(N);

    var i, j,
      radix = this.radix,
      out = new this._class(1),
      pow = this.copy();

    // Generate R as a cap of N.
    var R, s, wind, bitsize = x.bitLength();

    R = new sjcl.bn({
      limbs: N.copy().normalize().trim().limbs.map(function() { return 0; })
    });

    for (s = this.radix; s > 0; s--) {
      if (((N.limbs[N.limbs.length - 1] >> s) & 1) == 1) {
        R.limbs[R.limbs.length - 1] = 1 << s;
        break;
      }
    }

    // Calculate window size as a function of the exponent's size.
    if (bitsize == 0) {
      return this;
    } else if (bitsize < 18)  {
      wind = 1;
    } else if (bitsize < 48)  {
      wind = 3;
    } else if (bitsize < 144) {
      wind = 4;
    } else if (bitsize < 768) {
      wind = 5;
    } else {
      wind = 6;
    }

    // Find R' and N' such that R * R' - N * N' = 1.
    var RR = R.copy(), NN = N.copy(), RP = new sjcl.bn(1), NP = new sjcl.bn(0), RT = R.copy();

    while (RT.greaterEquals(1)) {
      RT.halveM();

      if ((RP.limbs[0] & 1) == 0) {
        RP.halveM();
        NP.halveM();
      } else {
        RP.addM(NN);
        RP.halveM();

        NP.halveM();
        NP.addM(RR);
      }
    }

    RP = RP.normalize();
    NP = NP.normalize();

    RR.doubleM();
    var R2 = RR.mulmod(RR, N);

    // Check whether the invariant holds.
    // If it doesn't, we can't use Montgomery reduction on this modulus.
    if (!RR.mul(RP).sub(N.mul(NP)).equals(1)) {
      return false;
    }

    var montIn = function(c) { return montMul(c, R2); },
    montMul = function(a, b) {
      // Standard Montgomery reduction
      var k, ab, right, abBar, mask = (1 << (s + 1)) - 1;

      ab = a.mul(b);

      right = ab.mul(NP);
      right.limbs = right.limbs.slice(0, R.limbs.length);

      if (right.limbs.length == R.limbs.length) {
        right.limbs[R.limbs.length - 1] &= mask;
      }

      right = right.mul(N);

      abBar = ab.add(right).normalize().trim();
      abBar.limbs = abBar.limbs.slice(R.limbs.length - 1);

      // Division.  Equivelent to calling *.halveM() s times.
      for (k=0; k < abBar.limbs.length; k++) {
        if (k > 0) {
          abBar.limbs[k - 1] |= (abBar.limbs[k] & mask) << (radix - s - 1);
        }

        abBar.limbs[k] = abBar.limbs[k] >> (s + 1);
      }

      if (abBar.greaterEquals(N)) {
        abBar.subM(N);
      }

      return abBar;
    },
    montOut = function(c) { return montMul(c, 1); };

    pow = montIn(pow);
    out = montIn(out);

    // Sliding-Window Exponentiation (HAC 14.85)
    var h, precomp = {}, cap = (1 << (wind - 1)) - 1;

    precomp[1] = pow.copy();
    precomp[2] = montMul(pow, pow);

    for (h=1; h<=cap; h++) {
      precomp[(2 * h) + 1] = montMul(precomp[(2 * h) - 1], precomp[2]);
    }

    var getBit = function(exp, i) { // Gets ith bit of exp.
      var off = i % exp.radix;

      return (exp.limbs[Math.floor(i / exp.radix)] & (1 << off)) >> off;
    };

    for (i = x.bitLength() - 1; i >= 0; ) {
      if (getBit(x, i) == 0) {
        // If the next bit is zero:
        //   Square, move forward one bit.
        out = montMul(out, out);
        i = i - 1;
      } else {
        // If the next bit is one:
        //   Find the longest sequence of bits after this one, less than `wind`
        //   bits long, that ends with a 1.  Convert the sequence into an
        //   integer and look up the pre-computed value to add.
        var l = i - wind + 1;

        while (getBit(x, l) == 0) {
          l++;
        }

        var indx = 0;
        for (j = l; j <= i; j++) {
          indx += getBit(x, j) << (j - l);
          out = montMul(out, out);
        }

        out = montMul(out, precomp[indx]);

        i = l - 1;
      }
    }

    return montOut(out);
  },

  trim: function() {
    var l = this.limbs, p;
    do {
      p = l.pop();
    } while (l.length && p === 0);
    l.push(p);
    return this;
  },

  /** Reduce mod a modulus.  Stubbed for subclassing. */
  reduce: function() {
    return this;
  },

  /** Reduce and normalize. */
  fullReduce: function() {
    return this.normalize();
  },

  /** Propagate carries. */
  normalize: function() {
    var carry=0, i, pv = this.placeVal, ipv = this.ipv, l, m, limbs = this.limbs, ll = limbs.length, mask = this.radixMask;
    for (i=0; i < ll || (carry !== 0 && carry !== -1); i++) {
      l = (limbs[i]||0) + carry;
      m = limbs[i] = l & mask;
      carry = (l-m)*ipv;
    }
    if (carry === -1) {
      limbs[i-1] -= pv;
    }
    this.trim();
    return this;
  },

  /** Constant-time normalize. Does not allocate additional space. */
  cnormalize: function() {
    var carry=0, i, ipv = this.ipv, l, m, limbs = this.limbs, ll = limbs.length, mask = this.radixMask;
    for (i=0; i < ll-1; i++) {
      l = limbs[i] + carry;
      m = limbs[i] = l & mask;
      carry = (l-m)*ipv;
    }
    limbs[i] += carry;
    return this;
  },

  /** Serialize to a bit array */
  toBits: function(len) {
    this.fullReduce();
    len = len || this.exponent || this.bitLength();
    var i = Math.floor((len-1)/24), w=sjcl.bitArray, e = (len + 7 & -8) % this.radix || this.radix,
        out = [w.partial(e, this.getLimb(i))];
    for (i--; i >= 0; i--) {
      out = w.concat(out, [w.partial(Math.min(this.radix,len), this.getLimb(i))]);
      len -= this.radix;
    }
    return out;
  },

  /** Return the length in bits, rounded up to the nearest byte. */
  bitLength: function() {
    this.fullReduce();
    var out = this.radix * (this.limbs.length - 1),
        b = this.limbs[this.limbs.length - 1];
    for (; b; b >>>= 1) {
      out ++;
    }
    return out+7 & -8;
  }
};

/** @memberOf sjcl.bn
* @this { sjcl.bn }
*/
sjcl.bn.fromBits = function(bits) {
  var Class = this, out = new Class(), words=[], w=sjcl.bitArray, t = this.prototype,
      l = Math.min(this.bitLength || 0x100000000, w.bitLength(bits)), e = l % t.radix || t.radix;

  words[0] = w.extract(bits, 0, e);
  for (; e < l; e += t.radix) {
    words.unshift(w.extract(bits, e, t.radix));
  }

  out.limbs = words;
  return out;
};



sjcl.bn.prototype.ipv = 1 / (sjcl.bn.prototype.placeVal = Math.pow(2,sjcl.bn.prototype.radix));
sjcl.bn.prototype.radixMask = (1 << sjcl.bn.prototype.radix) - 1;

/**
 * Creates a new subclass of bn, based on reduction modulo a pseudo-Mersenne prime,
 * i.e. a prime of the form 2^e + sum(a * 2^b),where the sum is negative and sparse.
 */
sjcl.bn.pseudoMersennePrime = function(exponent, coeff) {
  /** @constructor
  * @private
  */
  function p(it) {
    this.initWith(it);
    /*if (this.limbs[this.modOffset]) {
      this.reduce();
    }*/
  }

  var ppr = p.prototype = new sjcl.bn(), i, tmp, mo;
  mo = ppr.modOffset = Math.ceil(tmp = exponent / ppr.radix);
  ppr.exponent = exponent;
  ppr.offset = [];
  ppr.factor = [];
  ppr.minOffset = mo;
  ppr.fullMask = 0;
  ppr.fullOffset = [];
  ppr.fullFactor = [];
  ppr.modulus = p.modulus = new sjcl.bn(Math.pow(2,exponent));

  ppr.fullMask = 0|-Math.pow(2, exponent % ppr.radix);

  for (i=0; i<coeff.length; i++) {
    ppr.offset[i] = Math.floor(coeff[i][0] / ppr.radix - tmp);
    ppr.fullOffset[i] = Math.floor(coeff[i][0] / ppr.radix ) - mo + 1;
    ppr.factor[i] = coeff[i][1] * Math.pow(1/2, exponent - coeff[i][0] + ppr.offset[i] * ppr.radix);
    ppr.fullFactor[i] = coeff[i][1] * Math.pow(1/2, exponent - coeff[i][0] + ppr.fullOffset[i] * ppr.radix);
    ppr.modulus.addM(new sjcl.bn(Math.pow(2,coeff[i][0])*coeff[i][1]));
    ppr.minOffset = Math.min(ppr.minOffset, -ppr.offset[i]); // conservative
  }
  ppr._class = p;
  ppr.modulus.cnormalize();

  /** Approximate reduction mod p.  May leave a number which is negative or slightly larger than p.
   * @memberof sjcl.bn
   * @this { sjcl.bn }
   */
  ppr.reduce = function() {
    var i, k, l, mo = this.modOffset, limbs = this.limbs, off = this.offset, ol = this.offset.length, fac = this.factor, ll;

    i = this.minOffset;
    while (limbs.length > mo) {
      l = limbs.pop();
      ll = limbs.length;
      for (k=0; k<ol; k++) {
        limbs[ll+off[k]] -= fac[k] * l;
      }

      i--;
      if (!i) {
        limbs.push(0);
        this.cnormalize();
        i = this.minOffset;
      }
    }
    this.cnormalize();

    return this;
  };

  /** @memberof sjcl.bn
  * @this { sjcl.bn }
  */
  ppr._strongReduce = (ppr.fullMask === -1) ? ppr.reduce : function() {
    var limbs = this.limbs, i = limbs.length - 1, k, l;
    this.reduce();
    if (i === this.modOffset - 1) {
      l = limbs[i] & this.fullMask;
      limbs[i] -= l;
      for (k=0; k<this.fullOffset.length; k++) {
        limbs[i+this.fullOffset[k]] -= this.fullFactor[k] * l;
      }
      this.normalize();
    }
  };

  /** mostly constant-time, very expensive full reduction.
   * @memberof sjcl.bn
   * @this { sjcl.bn }
   */
  ppr.fullReduce = function() {
    var greater, i;
    // massively above the modulus, may be negative

    this._strongReduce();
    // less than twice the modulus, may be negative

    this.addM(this.modulus);
    this.addM(this.modulus);
    this.normalize();
    // probably 2-3x the modulus

    this._strongReduce();
    // less than the power of 2.  still may be more than
    // the modulus

    // HACK: pad out to this length
    for (i=this.limbs.length; i<this.modOffset; i++) {
      this.limbs[i] = 0;
    }

    // constant-time subtract modulus
    greater = this.greaterEquals(this.modulus);
    for (i=0; i<this.limbs.length; i++) {
      this.limbs[i] -= this.modulus.limbs[i] * greater;
    }
    this.cnormalize();

    return this;
  };


  /** @memberof sjcl.bn
  * @this { sjcl.bn }
  */
  ppr.inverse = function() {
    return (this.power(this.modulus.sub(2)));
  };

  p.fromBits = sjcl.bn.fromBits;

  return p;
};

// a small Mersenne prime
var sbp = sjcl.bn.pseudoMersennePrime;
sjcl.bn.prime = {
  p127: sbp(127, [[0,-1]]),

  // Bernstein's prime for Curve25519
  p25519: sbp(255, [[0,-19]]),

  // Koblitz primes
  p192k: sbp(192, [[32,-1],[12,-1],[8,-1],[7,-1],[6,-1],[3,-1],[0,-1]]),
  p224k: sbp(224, [[32,-1],[12,-1],[11,-1],[9,-1],[7,-1],[4,-1],[1,-1],[0,-1]]),
  p256k: sbp(256, [[32,-1],[9,-1],[8,-1],[7,-1],[6,-1],[4,-1],[0,-1]]),

  // NIST primes
  p192: sbp(192, [[0,-1],[64,-1]]),
  p224: sbp(224, [[0,1],[96,-1]]),
  p256: sbp(256, [[0,-1],[96,1],[192,1],[224,-1]]),
  p384: sbp(384, [[0,-1],[32,1],[96,-1],[128,-1]]),
  p521: sbp(521, [[0,-1]])
};

sjcl.bn.random = function(modulus, paranoia) {
  if (typeof modulus !== "object") { modulus = new sjcl.bn(modulus); }
  var words, i, l = modulus.limbs.length, m = modulus.limbs[l-1]+1, out = new sjcl.bn();
  while (true) {
    // get a sequence whose first digits make sense
    do {
      words = sjcl.random.randomWords(l, paranoia);
      if (words[l-1] < 0) { words[l-1] += 0x100000000; }
    } while (Math.floor(words[l-1] / m) === Math.floor(0x100000000 / m));
    words[l-1] %= m;

    // mask off all the limbs
    for (i=0; i<l-1; i++) {
      words[i] &= modulus.radixMask;
    }

    // check the rest of the digitssj
    out.limbs = words;
    if (!out.greaterEquals(modulus)) {
      return out;
    }
  }
};
/**
 * base class for all ecc operations.
 * @namespace
 */
sjcl.ecc = {};

/**
 * Represents a point on a curve in affine coordinates.
 * @constructor
 * @param {sjcl.ecc.curve} curve The curve that this point lies on.
 * @param {bigInt} x The x coordinate.
 * @param {bigInt} y The y coordinate.
 */
sjcl.ecc.point = function(curve,x,y) {
  if (x === undefined) {
    this.isIdentity = true;
  } else {
    if (x instanceof sjcl.bn) {
      x = new curve.field(x);
    }
    if (y instanceof sjcl.bn) {
      y = new curve.field(y);
    }

    this.x = x;
    this.y = y;

    this.isIdentity = false;
  }
  this.curve = curve;
};



sjcl.ecc.point.prototype = {
  toJac: function() {
    return new sjcl.ecc.pointJac(this.curve, this.x, this.y, new this.curve.field(1));
  },

  mult: function(k) {
    return this.toJac().mult(k, this).toAffine();
  },

  /**
   * Multiply this point by k, added to affine2*k2, and return the answer in Jacobian coordinates.
   * @param {bigInt} k The coefficient to multiply this by.
   * @param {bigInt} k2 The coefficient to multiply affine2 this by.
   * @param {sjcl.ecc.point} affine The other point in affine coordinates.
   * @return {sjcl.ecc.pointJac} The result of the multiplication and addition, in Jacobian coordinates.
   */
  mult2: function(k, k2, affine2) {
    return this.toJac().mult2(k, this, k2, affine2).toAffine();
  },

  multiples: function() {
    var m, i, j;
    if (this._multiples === undefined) {
      j = this.toJac().doubl();
      m = [j];
      for (i=3; i<16; i++) {
        j = j.add(this);
        m.push(j);
      }
      this._multiples = [new sjcl.ecc.point(this.curve), this].concat(sjcl.ecc.pointJac.toAffineMultiple(m));
    }
    return this._multiples;
  },

  negate: function() {
    var newY = new this.curve.field(0).sub(this.y).normalize().reduce();
    return new sjcl.ecc.point(this.curve, this.x, newY);
  },

  isValid: function() {
    return this.y.square().equals(this.curve.b.add(this.x.mul(this.curve.a.add(this.x.square()))));
  },

  toBits: function() {
    return sjcl.bitArray.concat(this.x.toBits(), this.y.toBits());
  }
};

/**
 * Represents a point on a curve in Jacobian coordinates. Coordinates can be specified as bigInts or strings (which
 * will be converted to bigInts).
 *
 * @constructor
 * @param {bigInt/string} x The x coordinate.
 * @param {bigInt/string} y The y coordinate.
 * @param {bigInt/string} z The z coordinate.
 * @param {sjcl.ecc.curve} curve The curve that this point lies on.
 */
sjcl.ecc.pointJac = function(curve, x, y, z) {
  if (x === undefined) {
    this.isIdentity = true;
  } else {
    this.x = x;
    this.y = y;
    this.z = z;
    this.isIdentity = false;
  }
  this.curve = curve;
};

/**
 * Returns points converted to affine coordinates.
 * @param {Array} points An array of {sjcl.ecc.pointJac} to convert.
 * @return {Array} An array of {sjcl.ecc.point} that were converted.
 */
sjcl.ecc.pointJac.toAffineMultiple = function (points) {
  var i=0, j, ret = new Array(points.length), p, tmp, z, zi, zi2, curve;
  for (; i<points.length; i++) {
    p = points[i];
    if (curve != p.curve) {
      // if not first time
      if (curve) {
        // curve mismatch so just convert points individually
        for (i=0; i<points.length; i++) {
          ret[i] = points[i].toAffine();
        }
        return ret;
      } else {
        curve = p.curve;
      }
    }
    // multiply all z coordinates
    if (!p.isIdentity && !p.z.equals(0)) {
      if (tmp) {
        tmp.push(z);
        z = z.mul(p.z);
      } else {
        z = p.z;
        tmp = [];
      }
    }
  }
  // if any z coordinates invert
  if (tmp) {
    // z is now the product of all z coordinates inverted
    z = z.inverse();
    j = tmp.length-1;
  }
  for (i--; i>=0; i--) {
    p = points[i];
    if (p.isIdentity || p.z.equals(0)) {
      ret[i] = new sjcl.ecc.point(p.curve);
    } else {
      // if not last
      if (j >= 0) {
        // remove all other inverted z coordinates from product of inverses
        // zi is now inverse of p.z
        zi = z.mul(tmp[j]);
        // remove the inverse of p.z from product of inverses
        z = z.mul(p.z);
        j--;
      } else {
        zi = z;
      }
      zi2 = zi.square();
      ret[i] = new sjcl.ecc.point(p.curve, p.x.mul(zi2).fullReduce(), p.y.mul(zi2.mul(zi)).fullReduce());
    }
  }
  return ret;
};

sjcl.ecc.pointJac.prototype = {
  /**
   * Adds S and T and returns the result in Jacobian coordinates. Note that S must be in Jacobian coordinates and T must be in affine coordinates.
   * @param {sjcl.ecc.pointJac} S One of the points to add, in Jacobian coordinates.
   * @param {sjcl.ecc.point} T The other point to add, in affine coordinates.
   * @return {sjcl.ecc.pointJac} The sum of the two points, in Jacobian coordinates.
   */
  add: function(T) {
    var S = this, sz2, c, d, c2, x1, x2, x, y1, y2, y, z;
    if (S.curve !== T.curve) {
      throw new sjcl.exception.invalid("sjcl.ecc.add(): Points must be on the same curve to add them!");
    }

    if (S.isIdentity) {
      return T.toJac();
    } else if (T.isIdentity) {
      return S;
    }

    sz2 = S.z.square();
    c = T.x.mul(sz2).subM(S.x);

    if (c.equals(0)) {
      if (S.y.equals(T.y.mul(sz2.mul(S.z)))) {
        // same point
        return S.doubl();
      } else {
        // inverses
        return new sjcl.ecc.pointJac(S.curve);
      }
    }

    d = T.y.mul(sz2.mul(S.z)).subM(S.y);
    c2 = c.square();

    x1 = d.square();
    x2 = c.square().mul(c).addM( S.x.add(S.x).mul(c2) );
    x  = x1.subM(x2);

    y1 = S.x.mul(c2).subM(x).mul(d);
    y2 = S.y.mul(c.square().mul(c));
    y  = y1.subM(y2);

    z  = S.z.mul(c);

    return new sjcl.ecc.pointJac(this.curve,x,y,z);
  },

  /**
   * doubles this point.
   * @return {sjcl.ecc.pointJac} The doubled point.
   */
  doubl: function() {
    if (this.isIdentity) { return this; }

    var
      y2 = this.y.square(),
      a  = y2.mul(this.x.mul(4)),
      b  = y2.square().mul(8),
      z2 = this.z.square(),
      c  = this.curve.a.toString() == (new sjcl.bn(-3)).toString() ?
                this.x.sub(z2).mul(3).mul(this.x.add(z2)) :
                this.x.square().mul(3).add(z2.square().mul(this.curve.a)),
      x  = c.square().subM(a).subM(a),
      y  = a.sub(x).mul(c).subM(b),
      z  = this.y.add(this.y).mul(this.z);
    return new sjcl.ecc.pointJac(this.curve, x, y, z);
  },

  /**
   * Returns a copy of this point converted to affine coordinates.
   * @return {sjcl.ecc.point} The converted point.
   */
  toAffine: function() {
    if (this.isIdentity || this.z.equals(0)) {
      return new sjcl.ecc.point(this.curve);
    }
    var zi = this.z.inverse(), zi2 = zi.square();
    return new sjcl.ecc.point(this.curve, this.x.mul(zi2).fullReduce(), this.y.mul(zi2.mul(zi)).fullReduce());
  },

  /**
   * Multiply this point by k and return the answer in Jacobian coordinates.
   * @param {bigInt} k The coefficient to multiply by.
   * @param {sjcl.ecc.point} affine This point in affine coordinates.
   * @return {sjcl.ecc.pointJac} The result of the multiplication, in Jacobian coordinates.
   */
  mult: function(k, affine) {
    if (typeof(k) === "number") {
      k = [k];
    } else if (k.limbs !== undefined) {
      k = k.normalize().limbs;
    }

    var i, j, out = new sjcl.ecc.point(this.curve).toJac(), multiples = affine.multiples();

    for (i=k.length-1; i>=0; i--) {
      for (j=sjcl.bn.prototype.radix-4; j>=0; j-=4) {
        out = out.doubl().doubl().doubl().doubl().add(multiples[k[i]>>j & 0xF]);
      }
    }

    return out;
  },

  /**
   * Multiply this point by k, added to affine2*k2, and return the answer in Jacobian coordinates.
   * @param {bigInt} k The coefficient to multiply this by.
   * @param {sjcl.ecc.point} affine This point in affine coordinates.
   * @param {bigInt} k2 The coefficient to multiply affine2 this by.
   * @param {sjcl.ecc.point} affine The other point in affine coordinates.
   * @return {sjcl.ecc.pointJac} The result of the multiplication and addition, in Jacobian coordinates.
   */
  mult2: function(k1, affine, k2, affine2) {
    if (typeof(k1) === "number") {
      k1 = [k1];
    } else if (k1.limbs !== undefined) {
      k1 = k1.normalize().limbs;
    }

    if (typeof(k2) === "number") {
      k2 = [k2];
    } else if (k2.limbs !== undefined) {
      k2 = k2.normalize().limbs;
    }

    var i, j, out = new sjcl.ecc.point(this.curve).toJac(), m1 = affine.multiples(),
        m2 = affine2.multiples(), l1, l2;

    for (i=Math.max(k1.length,k2.length)-1; i>=0; i--) {
      l1 = k1[i] | 0;
      l2 = k2[i] | 0;
      for (j=sjcl.bn.prototype.radix-4; j>=0; j-=4) {
        out = out.doubl().doubl().doubl().doubl().add(m1[l1>>j & 0xF]).add(m2[l2>>j & 0xF]);
      }
    }

    return out;
  },

  negate: function() {
    return this.toAffine().negate().toJac();
  },

  isValid: function() {
    var z2 = this.z.square(), z4 = z2.square(), z6 = z4.mul(z2);
    return this.y.square().equals(
             this.curve.b.mul(z6).add(this.x.mul(
               this.curve.a.mul(z4).add(this.x.square()))));
  }
};

/**
 * Construct an elliptic curve. Most users will not use this and instead start with one of the NIST curves defined below.
 *
 * @constructor
 * @param {bigInt} p The prime modulus.
 * @param {bigInt} r The prime order of the curve.
 * @param {bigInt} a The constant a in the equation of the curve y^2 = x^3 + ax + b (for NIST curves, a is always -3).
 * @param {bigInt} x The x coordinate of a base point of the curve.
 * @param {bigInt} y The y coordinate of a base point of the curve.
 */
sjcl.ecc.curve = function(Field, r, a, b, x, y) {
  this.field = Field;
  this.r = new sjcl.bn(r);
  this.a = new Field(a);
  this.b = new Field(b);
  this.G = new sjcl.ecc.point(this, new Field(x), new Field(y));
};

sjcl.ecc.curve.prototype.fromBits = function (bits) {
  var w = sjcl.bitArray, l = this.field.prototype.exponent + 7 & -8,
      p = new sjcl.ecc.point(this, this.field.fromBits(w.bitSlice(bits, 0, l)),
                             this.field.fromBits(w.bitSlice(bits, l, 2*l)));
  if (!p.isValid()) {
    throw new sjcl.exception.corrupt("not on the curve!");
  }
  return p;
};

sjcl.ecc.curves = {
  c192: new sjcl.ecc.curve(
    sjcl.bn.prime.p192,
    "0xffffffffffffffffffffffff99def836146bc9b1b4d22831",
    -3,
    "0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1",
    "0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012",
    "0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811"),

  c224: new sjcl.ecc.curve(
    sjcl.bn.prime.p224,
    "0xffffffffffffffffffffffffffff16a2e0b8f03e13dd29455c5c2a3d",
    -3,
    "0xb4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4",
    "0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21",
    "0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34"),

  c256: new sjcl.ecc.curve(
    sjcl.bn.prime.p256,
    "0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551",
    -3,
    "0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b",
    "0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296",
    "0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),

  c384: new sjcl.ecc.curve(
    sjcl.bn.prime.p384,
    "0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973",
    -3,
    "0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef",
    "0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7",
    "0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),
    
  c521: new sjcl.ecc.curve(
    sjcl.bn.prime.p521,
    "0x1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409",
    -3,
    "0x051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00",
    "0xC6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66",
    "0x11839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650"),

  k192: new sjcl.ecc.curve(
    sjcl.bn.prime.p192k,
    "0xfffffffffffffffffffffffe26f2fc170f69466a74defd8d",
    0,
    3,
    "0xdb4ff10ec057e9ae26b07d0280b7f4341da5d1b1eae06c7d",
    "0x9b2f2f6d9c5628a7844163d015be86344082aa88d95e2f9d"),

  k224: new sjcl.ecc.curve(
    sjcl.bn.prime.p224k,
    "0x010000000000000000000000000001dce8d2ec6184caf0a971769fb1f7",
    0,
    5,
    "0xa1455b334df099df30fc28a169a467e9e47075a90f7e650eb6b7a45c",
    "0x7e089fed7fba344282cafbd6f7e319f7c0b0bd59e2ca4bdb556d61a5"),

  k256: new sjcl.ecc.curve(
    sjcl.bn.prime.p256k,
    "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
    0,
    7,
    "0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    "0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")

};

sjcl.ecc.curveName = function (curve) {
  var curcurve;
  for (curcurve in sjcl.ecc.curves) {
    if (sjcl.ecc.curves.hasOwnProperty(curcurve)) {
      if (sjcl.ecc.curves[curcurve] === curve) {
        return curcurve;
      }
    }
  }

  throw new sjcl.exception.invalid("no such curve");
};

sjcl.ecc.deserialize = function (key) {
  var types = ["elGamal", "ecdsa"];

  if (!key || !key.curve || !sjcl.ecc.curves[key.curve]) { throw new sjcl.exception.invalid("invalid serialization"); }
  if (types.indexOf(key.type) === -1) { throw new sjcl.exception.invalid("invalid type"); }

  var curve = sjcl.ecc.curves[key.curve];

  if (key.secretKey) {
    if (!key.exponent) { throw new sjcl.exception.invalid("invalid exponent"); }
    var exponent = new sjcl.bn(key.exponent);
    return new sjcl.ecc[key.type].secretKey(curve, exponent);
  } else {
    if (!key.point) { throw new sjcl.exception.invalid("invalid point"); }
    
    var point = curve.fromBits(sjcl.codec.hex.toBits(key.point));
    return new sjcl.ecc[key.type].publicKey(curve, point);
  }
};

/** our basicKey classes
*/
sjcl.ecc.basicKey = {
  /** ecc publicKey.
  * @constructor
  * @param {curve} curve the elliptic curve
  * @param {point} point the point on the curve
  */
  publicKey: function(curve, point) {
    this._curve = curve;
    this._curveBitLength = curve.r.bitLength();
    if (point instanceof Array) {
      this._point = curve.fromBits(point);
    } else {
      this._point = point;
    }

    this.serialize = function () {
      var curveName = sjcl.ecc.curveName(curve);
      return {
        type: this.getType(),
        secretKey: false,
        point: sjcl.codec.hex.fromBits(this._point.toBits()),
        curve: curveName
      };
    };

    /** get this keys point data
    * @return x and y as bitArrays
    */
    this.get = function() {
      var pointbits = this._point.toBits();
      var len = sjcl.bitArray.bitLength(pointbits);
      var x = sjcl.bitArray.bitSlice(pointbits, 0, len/2);
      var y = sjcl.bitArray.bitSlice(pointbits, len/2);
      return { x: x, y: y };
    };
  },

  /** ecc secretKey
  * @constructor
  * @param {curve} curve the elliptic curve
  * @param exponent
  */
  secretKey: function(curve, exponent) {
    this._curve = curve;
    this._curveBitLength = curve.r.bitLength();
    this._exponent = exponent;

    this.serialize = function () {
      var exponent = this.get();
      var curveName = sjcl.ecc.curveName(curve);
      return {
        type: this.getType(),
        secretKey: true,
        exponent: sjcl.codec.hex.fromBits(exponent),
        curve: curveName
      };
    };

    /** get this keys exponent data
    * @return {bitArray} exponent
    */
    this.get = function () {
      return this._exponent.toBits();
    };
  }
};

/** @private */
sjcl.ecc.basicKey.generateKeys = function(cn) {
  return function generateKeys(curve, paranoia, sec) {
    curve = curve || 256;

    if (typeof curve === "number") {
      curve = sjcl.ecc.curves['c'+curve];
      if (curve === undefined) {
        throw new sjcl.exception.invalid("no such curve");
      }
    }
    sec = sec || sjcl.bn.random(curve.r, paranoia);

    var pub = curve.G.mult(sec);
    return { pub: new sjcl.ecc[cn].publicKey(curve, pub),
             sec: new sjcl.ecc[cn].secretKey(curve, sec) };
  };
};

/** elGamal keys */
sjcl.ecc.elGamal = {
  /** generate keys
  * @function
  * @param curve
  * @param {int} paranoia Paranoia for generation (default 6)
  * @param {secretKey} sec secret Key to use. used to get the publicKey for ones secretKey
  */
  generateKeys: sjcl.ecc.basicKey.generateKeys("elGamal"),
  /** elGamal publicKey.
  * @constructor
  * @augments sjcl.ecc.basicKey.publicKey
  */
  publicKey: function (curve, point) {
    sjcl.ecc.basicKey.publicKey.apply(this, arguments);
  },
  /** elGamal secretKey
  * @constructor
  * @augments sjcl.ecc.basicKey.secretKey
  */
  secretKey: function (curve, exponent) {
    sjcl.ecc.basicKey.secretKey.apply(this, arguments);
  }
};

sjcl.ecc.elGamal.publicKey.prototype = {
  /** Kem function of elGamal Public Key
  * @param paranoia paranoia to use for randomization.
  * @return {object} key and tag. unkem(tag) with the corresponding secret key results in the key returned.
  */
  kem: function(paranoia) {
    var sec = sjcl.bn.random(this._curve.r, paranoia),
        tag = this._curve.G.mult(sec).toBits(),
        key = sjcl.hash.sha256.hash(this._point.mult(sec).toBits());
    return { key: key, tag: tag };
  },
  
  getType: function() {
    return "elGamal";
  }
};

sjcl.ecc.elGamal.secretKey.prototype = {
  /** UnKem function of elGamal Secret Key
  * @param {bitArray} tag The Tag to decrypt.
  * @return {bitArray} decrypted key.
  */
  unkem: function(tag) {
    return sjcl.hash.sha256.hash(this._curve.fromBits(tag).mult(this._exponent).toBits());
  },

  /** Diffie-Hellmann function
  * @param {elGamal.publicKey} pk The Public Key to do Diffie-Hellmann with
  * @return {bitArray} diffie-hellmann result for this key combination.
  */
  dh: function(pk) {
    return sjcl.hash.sha256.hash(pk._point.mult(this._exponent).toBits());
  },

  /** Diffie-Hellmann function, compatible with Java generateSecret
  * @param {elGamal.publicKey} pk The Public Key to do Diffie-Hellmann with
  * @return {bitArray} undigested X value, diffie-hellmann result for this key combination,
  * compatible with Java generateSecret().
  */
  dhJavaEc: function(pk) {
    return pk._point.mult(this._exponent).x.toBits();
  }, 

  getType: function() {
    return "elGamal";
  }
};

/** ecdsa keys */
sjcl.ecc.ecdsa = {
  /** generate keys
  * @function
  * @param curve
  * @param {int} paranoia Paranoia for generation (default 6)
  * @param {secretKey} sec secret Key to use. used to get the publicKey for ones secretKey
  */
  generateKeys: sjcl.ecc.basicKey.generateKeys("ecdsa")
};

/** ecdsa publicKey.
* @constructor
* @augments sjcl.ecc.basicKey.publicKey
*/
sjcl.ecc.ecdsa.publicKey = function (curve, point) {
  sjcl.ecc.basicKey.publicKey.apply(this, arguments);
};

/** specific functions for ecdsa publicKey. */
sjcl.ecc.ecdsa.publicKey.prototype = {
  /** Diffie-Hellmann function
  * @param {bitArray} hash hash to verify.
  * @param {bitArray} rs signature bitArray.
  * @param {boolean}  fakeLegacyVersion use old legacy version
  */
  verify: function(hash, rs, fakeLegacyVersion) {
    if (sjcl.bitArray.bitLength(hash) > this._curveBitLength) {
      hash = sjcl.bitArray.clamp(hash, this._curveBitLength);
    }
    var w = sjcl.bitArray,
        R = this._curve.r,
        l = this._curveBitLength,
        r = sjcl.bn.fromBits(w.bitSlice(rs,0,l)),
        ss = sjcl.bn.fromBits(w.bitSlice(rs,l,2*l)),
        s = fakeLegacyVersion ? ss : ss.inverseMod(R),
        hG = sjcl.bn.fromBits(hash).mul(s).mod(R),
        hA = r.mul(s).mod(R),
        r2 = this._curve.G.mult2(hG, hA, this._point).x;
    if (r.equals(0) || ss.equals(0) || r.greaterEquals(R) || ss.greaterEquals(R) || !r2.equals(r)) {
      if (fakeLegacyVersion === undefined) {
        return this.verify(hash, rs, true);
      } else {
        throw (new sjcl.exception.corrupt("signature didn't check out"));
      }
    }
    return true;
  },

  getType: function() {
    return "ecdsa";
  }
};

/** ecdsa secretKey
* @constructor
* @augments sjcl.ecc.basicKey.publicKey
*/
sjcl.ecc.ecdsa.secretKey = function (curve, exponent) {
  sjcl.ecc.basicKey.secretKey.apply(this, arguments);
};

/** specific functions for ecdsa secretKey. */
sjcl.ecc.ecdsa.secretKey.prototype = {
  /** Diffie-Hellmann function
  * @param {bitArray} hash hash to sign.
  * @param {int} paranoia paranoia for random number generation
  * @param {boolean} fakeLegacyVersion use old legacy version
  */
  sign: function(hash, paranoia, fakeLegacyVersion, fixedKForTesting) {
    if (sjcl.bitArray.bitLength(hash) > this._curveBitLength) {
      hash = sjcl.bitArray.clamp(hash, this._curveBitLength);
    }
    var R  = this._curve.r,
        l  = R.bitLength(),
        k  = fixedKForTesting || sjcl.bn.random(R.sub(1), paranoia).add(1),
        r  = this._curve.G.mult(k).x.mod(R),
        ss = sjcl.bn.fromBits(hash).add(r.mul(this._exponent)),
        s  = fakeLegacyVersion ? ss.inverseMod(R).mul(k).mod(R)
             : ss.mul(k.inverseMod(R)).mod(R);
    return sjcl.bitArray.concat(r.toBits(l), s.toBits(l));
  },

  getType: function() {
    return "ecdsa";
  }
};

</script>
<h1>Telink Flasher for Mi Thermostat</h1>
<div class="navbar">
	<div class="container nav-container">
		<input class="checkbox" type="checkbox" name="" id="">
		<div class="hamburger-lines">
		  <span class="line line1"></span>
		  <span class="line line2"></span>
		  <span class="line line3"></span>
		</div>
	  <div class="menu-items">
			<li> GitHub </li>
			<li><a href="https://github.com/atc1441/ATC_MiThermometer">© atc1441</a> <a href="https://github.com/pvvx/ATC_MiThermometer">&#9432; pvvx</a></li>
			<li> Live Data </li>
			<li><a href="GraphAtc.html">Graph Atc 1</a></li>
			<li><a href="GraphAtc1.html">Graph Atc 2</a></li>
			<li><a href="GraphAtc2.html">Graph Atc 3</a></li>
			<li><a href="DevPoint.html">Dev Point</a></li>
			<li><a href="Advertising.html">Advertising</a></li>
			<li>Stored data</li>
			<li><a href="GraphMemo.html">Memo Graph</a></li>
			<li><a href="GraphMemoOriginal.html">LYWSD03MMC Memo Graph </a></li>
			<li>Others & Flasher</li>
			<li><a href="TelinkMiFlasher.html">Flasher</a></li>
			<li><a href="TelinkOTA.html">OTA Flasher</a></li>
			<li><a href="USBCOMFlashTx.html">Windows USB-COM Flasher</a></li>
	  </div>
	</div>
</div>
<hr>
<!-- Copyright: Aaron Christophel / Atc1441	 <a href="https://atcnetz.de">https://ATCnetz.de</a><br> -->
<div style="height: auto; width: auto;">
  <input type="checkbox" title="Web Experimental Features!" id="advmac">
  <label for="advmac">Get Advertising MAC</label>
  <br>
  <label for="namePrefix">BLE device name prefix filter(s)</label>
  <input type="text" id="namePrefix" value="" placeholder="LYWSD03,ATC"><br>
  <button type="button" onclick="connect();">Connect</button>
  <button type="button" onclick="disconnect();">Disconnect</button>
  <button type="button" onclick="reConnect();">Reconnect</button><br>
 </div>
 <div id="percent">Status: waiting for you to connect a device</div>
 <div id="tempHumiData">Temp/Humidity: waiting for data after connecting</div><hr>
 <div id="MAC"></div>
 <div>
	<hr>
	<div id="ldfile" hidden="true">
		Select Firmware: <input type="file" accept=".bin,.zigbee" id="file"/></div>
	<div id="ldfrmw"></div>
 </div>
  <div id="custcfg"></div>
  <hr>
  <button type="button" onclick="clearLog();">Clear Log</button>
  <div id="log"></div>

</body></html>
